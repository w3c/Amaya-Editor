<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN//2.0">
<HTML>
<HEAD>
<!-- Document generated by Thot -->
<TITLE>APIman-E</TITLE>
<LINK HREF="APIman.toc.html" REL="ToC">
</HEAD>
<BODY>
<PRE>
<EM>Thot V2.0</EM></PRE>
<PRE>
Date: Draft, December 27, 1996</PRE>

<H1>The Thot Tool Kit API</H1>
<ADDRESS>Vincent QUINT, Ir&egrave;ne VATTON</ADDRESS>

<HR>

<P>The Thot tool kit is a comprehensive set of editing functions that can be
used for building applications that handle structured documents in the Unix /
X Window environment. It is constituted by a set of C libraries that can be
linked to any program. It allows application programs to perform the same kind
of operations as a user working with a structured document editor. Typically,
an application can use the tool kit for creating new documents, for modifying
existing documents, for extracting information from documents, for displaying
(parts of) documents, etc. The tool kit can be used either for automatic
manipulations performed solely by a program or for allowing a human user to
cooperate with a program that processes documents. In this latter case, it
uses OSF/Motif for implementing the user interface.</P>

<P>The functions provided by the tool are based on the Thot document model.
Documents produced with the tool kit can be stored as Unix files in the same
standard format as documents produced by the Thot editor (pivot format
indicated by the .PIV suffix). Thot editor is also able to save documents in
other formats and obviously this capability is provided by the tool kit. Thot
documents can be processed by all tools available in the Thot environment and
by all applications developed with the tool kit. The Thot environment includes
in particular flexible tools for editing, printing and translating
documents.</P>

<H2><A NAME="secta1">1</A> Introduction to the document model</H2>

<H3><A NAME="sectb11">1.1</A> Logical structure</H3>

<P>In the editing tool kit, a <EM>document</EM> is primarily considered as an
abstract structure that assembles typed <EM>elements</EM>. Examples of
elements types are titles, chapters, sections, paragraphs, lists, notes, etc.
The structure itself is basically a hierarchy of such elements; it is called
an <EM>abstract tree</EM>. The lowest level elements (also called <EM>basic
elements</EM>) represent the actual <EM>contents</EM> of the document:
character stings, mathematical symbols, pictures, and graphical elements. In
addition to this tree structure, non-hierarchical links (also called
<EM>references</EM>) relate elements independently of the tree structure, thus
representing cross- references and other types of hypertext links.</P>

<P>As the type of an element is not always sufficient for completely
representing the role of that element in the document logical structure, the
notion of <EM>logical attribute</EM> has been introduced. A logical attribute
is an information associated with an element that adds semantics to that
element.</P>

<P>The logical structure of a document is constrained by a model, called a
<EM>structure schema</EM>. Several structure schemas can be used, one for each
type of document. A structure schema defines a document type, by specifying
all types of elements that can be used in the logical structure of a document
of that type. It also specifies the attributes that can be associated with
each type of element and all structural relationships that can be set between
elements. Structure schemas are written in a specific declarative language,
called S. A compiler for the S language is available, so that new document
types can be defined, according to the requirements of applications.</P>

<H3><A NAME="sectb12">1.2</A> Presentation</H3>

<P>The graphical appearance of a document (also called <EM>presentation</EM>)
is derived from its logical structure and is generically specified by a
<EM>presentation schema</EM>. A presentation schema is associated with a
structure schema and specifies the appearance of documents of  the type
defined by the structure schema. For each type of element defined in the
structure schema, the presentation schema contains a set of presentation rules
that define the style and the format of the logical elements. Using these
rules, the system can then produce the graphical representation of a document,
on the basis of its logical structure.</P>

<P>Presentation schemas are written in the language P and a compiler for that
language is available. New presentation schemas can then be developed. Notice
that several presentation schemas can be associated with the same structure
schema, thus defining alternative presentations for the same type of
document.</P>

<P>In addition, each presentation schema may define different <EM>views</EM>.
A view is a subset of the document that can be formatted in a different way
and displayed separately: each view is presented in a different window on the
screen.</P>

<P>For balancing this rigid principle of presentation with a certain degree of
flexibility, it is possible to associate with some element instances a special
type of attribute, called <EM>specific presentation rule</EM>. A specific
presentation rule is a presentation rule of the same kind as those of the
presentation schema, but it applies only to the element instance with which it
is associated, not to all elements of that type.</P>

<P>With that approach to document representation, documents are first
specified generically, by writing structure schemas and presentation schemas.
Then end-users and application programs can manipulate document instances very
simply, by referring to the schemas. Most of the work consists in handling a
logical structure consistent with the chosen structure schema and in handling
the contents (the basic elements) of that structure. All the rest, especially
formatting and displaying, is done by the tool kit. In addition, the logical
structure is a very efficient help for moving across the document and for
locating the parts to be modified.</P>

<H2><A NAME="secta2">2</A> Tool kit structure</H2>

<H3><A NAME="sectb21">2.1</A> Structure of this manual</H3>

<P>The tool kit contains about 200 functions. For the sake of clarity, they
are presented by groups, each group focusing on a different aspect of
documents.</P>

<UL>
<LI>Group <EM>application</EM> (section <A HREF="#secta6">6</A>) concerns the
administration of the tool kit by the application.
<LI>Group <EM>interface</EM> (section <A HREF="#secta7">7</A>) allows the
application program to modify and extend the Thot editor.
<LI>Group <EM>document</EM> (section <A HREF="#secta8">8</A>) allows the
application to manage schemas and whole documents.
<LI>Group <EM>tree</EM> (section <A HREF="#secta9">9</A>) handles the
hierarchical logical structure of documents.
<LI>Group <EM>contents</EM> (section <A HREF="#secta10">10</A>) allows the
application to manipulate the contents of the leaves of the structure.
<LI>Group <EM>attribute</EM> (section <A HREF="#secta11">11</A>) concerns
logical attributes.
<LI>Group <EM>reference</EM> (section <A HREF="#secta12">12</A>) contains
functions for manipulating non hierarchical relationships (hypertext links).
<LI>Group <EM>language</EM> (section <A HREF="#secta13">13</A>) concerns
natural languages used in text contents.
<LI>Group <EM>presentation</EM> (section <A HREF="#secta14">14</A>) handles
specific presentation.
<LI>Group <EM>view</EM> (section <A HREF="#secta15">15</A>) handles views.
<LI>Group <EM>selection</EM> (section <A HREF="#secta16">16</A>) contains the
functions that handle the selection.
<LI>Group <EM>message</EM> (section <A HREF="#secta17">17</A>) allows the
application program to display messages intended to the user.
<LI>Group <EM>dialogue</EM> (section <A HREF="#secta18">18</A>) allows the
application program to manage menus and forms intended to the user.
</UL>

<P>Each section presenting a group of functions is divided into subsections
which correspond to the following four broad categories:</P>

<UL>
<LI><EM>constructors</EM> are functions that create or generate new things. By
extension, they also include reverse functions, which delete or destroy the
same things.
<LI><EM>modificators</EM> are functions that modify existing things in
different ways.
<LI><EM>accessors</EM> are the functions that allow the application program to
access things.
<LI><EM>locators</EM> are the functions that search various kind of things in
document, according to different criteria.
</UL>

<H3><A NAME="sectb22">2.2</A> Libraries</H3>

<P>The Thot editing tool kit is accessed through an API that is defined in
sections <A HREF="#secta6">6</A> to <A HREF="#secta18">18</A>. The tool kit
takes the form of two libraries for editing documents. Each library is suited
to a different type of application and an application uses only one of the two
editing libraries: the second library includes the  first one.</P>

<H4><A NAME="sectc221">2.2.1</A> Thot Kernel library</H4>

<P>The first library allows an application to handle the logical structure and
the contents of Thot documents in automatic mode. This subset of the tool kit,
called Thot Kernel, does not produce the graphical aspect of documents. It
does not provide either any service for the user interface. It is typically
designed for applications performing automatic operations on the logical
structure and contents of documents without direct manipulation by a user.</P>

<P>The last five groups of functions (those handling views, selections, and
user interface to the editor) are not part of that library. Sections <A
HREF="#secta15">15</A> to <A HREF="#secta18">18</A> of that document do not
concern that library.</P>

<H4><A NAME="sectc222">2.2.2</A> Thot Editor library</H4>

<P>The second library, called Thot Editor, includes all facilities provided by
the Kernel, with the same interface, and provides additional services for
displaying the graphical aspect of documents. It also contains the whole Thot
editor with its user interface. All editing functions of Thot can be accessed
by the user and by application programs. The Thot Editor tool kit is typically
intended to interactive applications that handle documents under the control
of a user and that add new functions to the editor.</P>

<P>All groups of functions presented in this document are part of that
library. Functions that are also part of the Thot Kernel have exactly the same
interface when used in the context of Thot Editor. The only difference is
that, in the case of Thot Kernel, they do not display anything, and that, in
the case of Thot Editor, some of them (namely constructors and modificators)
modify the picture displayed on the screen. As a consequence, application
programs that have been developed for automatic processing can be reused in
the context of an interactive application without any change: the Thot Editor
automatically takes in charge all displaying problems that are not handled by
the Thot Kernel.</P>

<H2><A NAME="secta3">3</A> Using the Thot tool kit</H2>

<H3><A NAME="sectb31">3.1</A> Errors</H3>

<P>Almost all functions of the tool kit can detect errors. In that case the
function is not performed and an error code is set. The tool kit provides the
application program with the function TtaGetErrorCode for accessing the error
code. That function returns the completion code of the last tool kit function
called by the application. Only the completion code of the most recently
called function is available. A 0 completion code means a successful
operation; other values are defined in files <EM>application.h</EM>.</P>

<P>In addition to the error code returned to the application program by the
function TtaGetErrorCode, the tool kit prints an error message on the standard
error file stderr whenever an error is raised. Error messages are printed by
default, but the application program can ask the tool kit to stop printing
these messages, by calling the function TtaSetErrorMessages.</P>

<H3><A NAME="sectb32">3.2</A> Include files</H3>

<P>Each group of functions has an associated include file. Available include
files are: application.h, document.h, tree.h, content.h, attribute.h,
reference.h, language.h, presentation.h, view.h, selection.h, interface.h.
These files must be included in each module of the application program that
calls at least one function of the corresponding group. They contain the
interface definition of the functions and the types and constants (#define)
used by these functions.</P>

<H3><A NAME="sectb33">3.3</A> Buffers</H3>

<P>Whenever a function may return a long character string (20 characters or
more), the buffer must be provided by the application when calling the
function. If the buffer is too small, the tool kit raises an error. But the
size of the character string can generally be asked before calling such
functions, by using another function.</P>

<H2><A NAME="secta4">4</A> <A NAME="L398">Types used by the Thot editing tool
kit</A></H2>

<P>The tool kit performs operations on various entities, such as schemas,
documents, elements, attributes, views, etc. Each entity is identified by a
unique identifier which is assigned by Thot. Therefore, an application program
must get that identifier before manipulating any entity. An identifier can be
obtained by constructors, accessors and locators.</P>

<P>The following types are used by the editing tool kit:</P>

<DL>
<DT>SSchema</DT>

<DD>a structure schema loaded by the tool kit.
<DT>Document</DT>

<DD>a document loaded or created by the tool kit.
<DT>Element</DT>

<DD>an element in the logical structure of a document.
<DT>Attribute</DT>

<DD>a logical attribute.
<DT>PRule</DT>

<DD>a specific presentation rule.
<DT>TypeUnit</DT>

<DD>UnRelative, UnXHeight, UnPoint, UnPixel, UnPercent
<DT>View</DT>

<DD>a view created by the editor (Thot Editor only).
<DT>ElementType</DT>

<DD>the type of an element.
<DT>AttributeType</DT>

<DD>the type of an attribute.
<DT>Language</DT>

<DD>the identifier of a natural language.
</DL>

<P>SSchemas, Elements, Attributes, and PRules are pointers (addresses),
whereas Documents and Views are integers. Language is an unsigned character.
Both ElementType and AttributeType are structures containing a SSchema (the
schema that defines the corresponding element type or attribute type) and an
integer which is the number of the element type or attribute type in that
structure schema. Structure ElementType is defined in file
<EM>tree.h</EM>:</P>

<PRE>
typedef struct _ElementType
    {
    SSchema ElSSchema;
    int ElTypeNum;
    } ElementType;
</PRE>

<P>Structure AttributeType is defined in file <EM>attribute.h</EM>:</P>

<PRE>
typedef struct _AttributeType
    {
    SSchema AttrSSchema;
    int AttrTypeNum;
    } AttributeType;
</PRE>

<P>In addition some integers are used for exchanging parameters between the
application program and the tool kit. Available parameters with their possible
values are:</P>

<DL>
<DT>Search domain</DT>

<DD>SearchForward, SearchBackward, SearchInTree.
<DT>Access rights</DT>

<DD>ReadWrite, ReadOnly, Hidden, Inherited.
<DT>Construct</DT>

<DD>ConstructIdentity, ConstructList, ConstructChoice,
ConstructOrderedAggregate, ConstructUnorderedAggregate, ConstructConstant,
ConstructReference, ConstructBasicType, ConstructNature, ConstructPair.
<DT>Presentation rules</DT>

<DD>PRSize, PRStyle, PRFont, PRUnderline, PRThickness, PRIndent,
PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle, PRLineWeight,
PRFillPattern, PRBackground, PRForeground, PRHyphenate.
<DT>Display modes</DT>

<DD>DisplayImmediately, DeferredDisplay, NoComputedDisplay.
</DL>

<H2><A NAME="secta5">5</A> Initialization</H2>

<P>Group application contains the functions for managing the tool kit API.
These functions require that file <EM>application.h</EM> be included in the
module that calls them.</P>

<P>Applications generated by an interface schema EDITOR.A don't have to call
these functions.</P>

<H3><A NAME="sectb51">5.1</A> Constructors</H3>

<H4><A NAME="sectc511">5.1.1</A> TtaInitialize</H4>

<P>Initializes the Thot editing tool kit for an application. This function
must be called before any other function of the tool kit.</P>

<HR>

<P>void   TtaInitialize(char *applicationName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>applicationName</EM>: name of the application that requires services
from the tool kit. This name is used for accessing the ressources defined in
the Registry.
</DL>

<H4><A NAME="sectc512">5.1.2</A> TtaQuit</H4>

<P>Quits the Thot tool kit. No other function of the tool kit can then be
called by the application.</P>

<HR>

<P>void TtaQuit()</P>

<HR>

<H4><A NAME="sectc513">5.1.3</A> TtaInitializeAppRegistry</H4>

<P>Initialize the Thot Registry. This is done by default by TtaInitialize. On
Unix platforms the Registry is physically stored in the <TT>Thot.ini</TT>
file, on Windows platforms the native Registry is used.</P>

<HR>

<P>void TtaInitializeAppRegistry(char *applicationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>applicationName</EM>: name of the application.
</DL>

<H4><A NAME="sectc514">5.1.4</A> TtaSaveAppRegistry</H4>

<P>Commit the changes made to the Thot Registry. This is done by default by
TtaQuit.</P>

<HR>

<P>void TtaSaveAppRegistry()</P>

<HR>

<H4><A NAME="sectc515">5.1.5</A> TtaGetEnvString</H4>

<P>Reads an entry from the Thot Registry. It returns a <B>non-modifiable</B>
string associated to the name given as parameter. Thot first looks for a
specific value associated to the current application, and if not found try to
find one in the "thot" section. Hence settings saved in the "thot" section are
shared by all applications based on the Thot library, but can be refined to
fit each application specific needs. If no value is found for the requested
entry, the function returns NULL.</P>

<HR>

<P>char *TtaGetEnvString(const char *name)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
</DL>

<H2><A NAME="secta6">6</A> <A NAME="L576">Application</A></H2>

<P>Group application contains the functions for managing the tool kit API.
These functions require that file <EM>application.h</EM> be included in the
module that calls them.</P>

<H3><A NAME="sectb61">6.1</A> Constructors</H3>

<H4><A NAME="sectc611">6.1.1</A> TtaGetMemory</H4>

<P>Allocates dynamically a buffer of a specific size.</P>

<HR>

<P>char *TtaGetMemory(int size)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>size</EM>: size in bytes (like using malloc) of the desired allocated
buffer.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the address of the allocated buffer.
</DL>

<DL>
<DT>See also:</DT>

<DD>TtaFreeMemory.
</DL>

<H4><A NAME="sectc612">6.1.2</A> TtaFreeMemory</H4>

<P>Frees the memory allocated to a buffer by TtaGetMemory.</P>

<HR>

<P>void  TtaFreeMemory(char *buffer)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>buffer</EM>: the address of the buffer.
</DL>

<DL>
<DT>See also:</DT>

<DD>TtaGetMemory.
</DL>

<H3><A NAME="sectb62">6.2</A> Modificators</H3>

<H4><A NAME="sectc621">6.2.1</A> TtaSetErrorMessages</H4>

<P>Indicates to the tool kit whether error messages must be printed or
not.</P>

<HR>

<P>void TtaSetErrorMessages(int on)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>on</EM>: 1 if error messages must be printed, 0 if not.
</DL>

<H4><A NAME="sectc622">6.2.2</A> TtaSetEnvString</H4>

<P>Set an entry in the Thot Registry for the current application. </P>

<HR>

<P>int TtaSetEnvString(const char *name, const char *value, int overwrite)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value associated to the entry.</P>

<P><EM>overwrite</EM>: should we overwrite an existing entry ?</P>

</DL>

<H3><A NAME="sectb63">6.3</A> Accessors</H3>

<H4><A NAME="sectc631">6.3.1</A> TtaGetVersion</H4>

<P>Returns the identifier of the current version of the Thot editing tool
kit.</P>

<HR>

<P>char *TtaGetVersion()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>identifier of the current version.
</DL>

<H4><A NAME="sectc632">6.3.2</A> TtaGetErrorCode</H4>

<P>Returns the error code set by the last call to the Thot editing tool kit.
See file <EM>application.h</EM> for the possible values.</P>

<HR>

<P>int TtaGetErrorCode()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>last error code, 0 if the last call was successful.
</DL>

<H4><A NAME="sectc633">6.3.3</A> TtaGetStrError</H4>

<P>Returns a pointer to the message text for a given error code.</P>

<HR>

<P>char *TtaGetStrError(int errorCode)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>errorCode</EM>: an error code.
</DL>

<DL>
<DT>Return value:</DT>

<DD>pointer to the message text of the error.
</DL>

<DL>
<DT>See also:</DT>

<DD>TtaGetErrorCode
</DL>

<H2><A NAME="secta7">7</A> <A NAME="L8356">Interface</A></H2>

<P>The functions described in this section require that file
<EM>interface.h</EM> be included in the module that calls them. They are
available only in the Thot Editor library.</P>

<H3><A NAME="sectb71">7.1</A> Constructors</H3>

<H4><A NAME="sectc711">7.1.1</A> TtaSetCallback</H4>

<P>This function reserves a set of reference for creating dialogue elements
(forms, menus, submenus, labels, etc.) and specifies the procedure that is
called back when the user activates these dialogue elements.</P>

<P>Dialogue elements have to be created by the application using references
between the "base" value returned by this function and the value
"base+numberOfRef-1". So, this function must be called first.</P>

<P> It is possible to define different sets of dialogue elements by calling
this function more than one time with different <TT>callbackProcedure</TT>
procedure in the same application.</P>

<P>The <TT>callbackProcedure</TT> procedure declared  is called for each event
concerning these specific dialogue items. It receives three parameters: the
dialogue item reference, the data type, and the data value:</P>
<TT>
<P>
  void callbakProcedure(reference, datatype, data)
     int reference;
     int datatype;</P>
</TT><TT>
<P>     char *data; </P>
</TT>
<HR>

<P>int TtaSetCallback(void (*callbackProcedure) (), int numberOfRef)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>callbakProcedure</EM>: the application callback procedure.
<P><EM>numberOfRef</EM>: the nmber of reference reserved.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the "base" value for the <TT>numberOfRef</TT> specific dialogue elements
to be created.
</DL>

<H4><A NAME="sectc712">7.1.2</A> TtaHandlePendingEvents</H4>

<P>This function manages all Thot and Motif pending events. The application
have to call this function to allow user's interactions and display updates to
be managed during long treatments.</P>

<HR>

<P>void TtaHandlePendingEvents()</P>

<HR>

<H4><A NAME="sectc713">7.1.3</A> TtaHandleOneEvent</H4>

<P>This function processes one event within Thot and Motif. The application
which controls a local loop of events have to call this function to allow
managment of specific Thot and Motif events.</P>

<HR>

<P>void TtaHandlePendingEvents(XEvent *event)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>event</EM>: the X event to be managed.
</DL>

<H4><A NAME="sectc714">7.1.4</A> TtaCreatePixmapLogo</H4>

<P>Creates a logo pixmap from an XPM pixmap description: width, height, number
of colors, colors and pixels. This logo can be displayed within the
application window (see function TtaOpenMainWindow).</P>

<HR>

<P>Pixmap TtaCreatePixmapLogo(char 8data)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>data</EM>: data of the XPM file.
</DL>

<DL>
<DT>Return value:</DT>

<DD>The created pixmap for the logo.
</DL>

<H4><A NAME="sectc715">7.1.5</A> TtaCreateBitmapLogo</H4>

<P>Creates a logo pixmap from a bitmap description: width, height and bit
array. This logo can be used as the icon of the application window (see
function TtaOpenMainWindow).</P>

<HR>

<P>Pixmap TtaCreateBitmapLogo(int width, int height, char *bits)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>width</EM>: the width value of the bitmap.
<P><EM>height</EM>: the height value of the bitmap.</P>

<P><EM>bits</EM>: the bit array.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The created pixmap for the logo.
</DL>

<H4><A NAME="sectc716">7.1.6</A> TtaAddButton</H4>

<P>Adds a new button into the document view button bar. This function must
specify a valid view of a valid document. The procedure parameter gives the
call back procedure that will be run when user select the button. This
procedure will receive two parametrers: the document and the view
concerned.</P>

<P>An example of callback procedure is.</P>

<PRE>
void callback_procedure (document, view)
Document document;
View view;
{
....
}
</PRE>

<P>If the icon parameter in NULL, a space button is generated and the callback
procedure is ignored.</P>

<HR>

<P>int TtaAddButton(Document document, View view, Pixmap icon, void
(*procedure) ())</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>icon</EM>: the pixmap of the new button or NULL.</P>

<P><EM>procedure</EM>: procedure to be executed when the button is selected by
the user or NULL.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The button index.
</DL>

<H4><A NAME="sectc717">7.1.7</A> TtaAddTextZone</H4>

<P>Adds a new text-zone into the document view commands. This function must
specify a valid view of a valid document. The editable parameter indicates
that user can edit this text-zone. The procedure parameter gives the call back
procedure that will be run when user changes the text-zone: the user press the
<TT>Return</TT> key. This procedure will receive two parametrers: the document
and the view concerned.</P>

<P>An example of callback procedure is.</P>

<PRE>
void callback_procedure (document, view)
Document document;
View view;
{
....
}
</PRE>

<P>If the text-zone is not editable the procedure have to be NULL.</P>

<HR>

<P>int TtaAddTextZone(Document document, View view, char *label, boolean
editable, void (*procedure) ())</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>label</EM>: the label of the text-zone.</P>

<P><EM>editable</EM>: True is user can edit the text-zone.</P>

<P><EM>procedure</EM>: procedure to be executed when the text is modified by
the user.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The text-zone index.
</DL>

<H3><A NAME="sectb72">7.2</A> Accessors</H3>

<H4><A NAME="sectc721">7.2.1</A> TtaGetCurrentDisplay</H4>

<P>Returns the current display descriptor.</P>

<HR>

<P>Display *TtaGetCurrentDisplay()</P>

<HR>

<H4><A NAME="sectc722">7.2.2</A> TtaGetScreenDepth</H4>

<P>Returns the screen depth of the display.</P>

<HR>

<P>int TtaGetScreenDepth()</P>

<HR>

<H4><A NAME="sectc723">7.2.3</A> TtaClickAnElement</H4>

<P>Waits for a click from end-user and returns the element and document
selected. If the user clicks out of any document view, the returned values are
null.</P>

<HR>

<P>void TtaClickAnElement(Document document, Element element)</P>

<HR>

<DL>
<DT>Parameters</DT>

<DD><EM>document</EM>: the document selected by the user or 0.
<P><EM>element</EM>: the element selected by the user or 0.</P>

</DL>

<H3><A NAME="sectb73">7.3</A> Modificators</H3>

<H4><A NAME="sectc731">7.3.1</A> TtaChangeButton</H4>

<P>This function changes the button icon. This function must specify a valid
view of a valid document and a valid button index.</P>

<HR>

<P>void TtaChangeButton(Document document, View view, int buttonIndex, Pixmap
icon)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>buttonIndex</EM>: the button index, numbered from 1 to n.</P>

<P><EM>icon</EM>: the pixmap of the new button or NULL.</P>

</DL>

<H4><A NAME="sectc732">7.3.2</A> TtaSetTextZone</H4>

<P>This function gets the text to be displayed in the text-zone. This function
must specify a valid view of a valid document and a valid text-zone index.</P>

<HR>

<P>void TtaSetTextZone(Document document, View view, int textIndex, char
*text)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>textIndex</EM>: the button index, numbered from 1 to n.</P>

<P><EM>text</EM>: the text to be displayed into the text-zone.</P>

</DL>

<H4><A NAME="sectc733">7.3.3</A> TtaSetMenuOff</H4>

<P>Sets inactive a menu in the menu bar of the view of the document. If the
document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetMenuOff(Document document, View view, int menuID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the menu identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc734">7.3.4</A> TtaSetMenuOn</H4>

<P>Sets active a menu in the menu bar of the view of the document. If the
document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetMenuOn(Document document, View view, int menuID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the menu identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc735">7.3.5</A> TtaSetActionOff</H4>

<P>Sets inactive a menu action in the menu bar of the view of the document. If
the document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetActionOff(Document document, View view, int menuID, int
itemID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the main menu (even if the item is located into a submenu)
identification in the EDITOR.h file.</P>

<P><EM>itemID</EM>: the item identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc736">7.3.6</A> TtaSetActionOn</H4>

<P>Sets active a menu action in the menu bar of the view of the document. If
the document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetActionOn(Document document, View view, int menuID, int
itemID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the main menu (even if the item is located into a submenu)
identification in the EDITOR.h file.</P>

<P><EM>itemID</EM>: the item identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc737">7.3.7</A> TtaSetToggleItem</H4>

<P>Sets on/off the toggle of an item in the menu bar of the view of the
document. If the document and view parameters are null, the menu is a
application window menu.</P>

<HR>

<P>void TtaSetActionOn(Document document, View view, int menuID, int itemID,
boolean on)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the main menu (even if the item is located into a submenu)
identification in the EDITOR.h file.</P>

<P><EM>itemID</EM>: the item identification in the EDITOR.h file.</P>

<P><EM>on</EM>: the value True or False to be set.</P>

</DL>

<H4><A NAME="sectc738">7.3.8</A> TtaSetCursorWatch</H4>

<P>Displays the cursor watch within the view of the document. If the document
and view parameters are NULL, displays the cursor watch within all views of
documents.</P>

<HR>

<P>void TtaSetCursorWatch (Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

</DL>

<H4><A NAME="sectc739">7.3.9</A> TtaResetCursor</H4>

<P>Resets the standard cursor within the view of the document. If the document
and view parameters are NULL, resets the standard cursor within all views of
documents.</P>

<HR>

<P>void TtaResetCursor(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>dument</EM>: the documen or 0.
<P><EM>view</EM>: the view or 0.</P>

</DL>

<H2><A NAME="secta8">8</A> <A NAME="L822">Documents and schemas</A></H2>

<P>The functions described in this section require that file
<EM>document.h</EM> be included in the module that calls them.</P>

<DL>
<DT>Document identification</DT>

<DD>An application program using the Thot editing tool kit can handle several
documents at the same time. These documents can be defined by the same
structure schema or by different structure schemas as well. Before any other
operation can be performed, a document must be either created
(TtaNewDocument), if it does not exist yet, or opened (TtaOpenDocument), if it
exists in a file. These two functions return a value of type Document that is
then used for identifying the document to which subsequent operations apply.
The only exception is the function TtaGiveSchemasOfDocument which accesses a
document by its name.
<P>The name of a document is a character string (maximum length is 19
characters, not including the extension) that is used for naming the file
containing the document and that appears in the user dialogue (Thot Editor
only).</P>

</DL>

<DL>
<DT>Document files</DT>

<DD>Documents are stored in Unix files. Actually, a single document is
represented by several files. All these files have the same name as the
document, with different extensions:
<UL>
<LI>The .PIV file contains the last version of the document (logical
structure, contents, logical attributes and specific presentation rules). A
.PIV file is created each time the document is saved, either by the user or by
the application program (function TtaSaveDocument). The .PIV file is the file
read by the TtaOpenDocument function.
<LI>The .OLD file contains the previous version of the document. It is a copy
of the .PIV file before the last save operation.
<LI>The .BAK file contains a version of the document that is written
periodically for allowing recovery from crashes. It is removed each time the
document is saved successfully, but if the system or the application crashes,
it must be renamed .PIV and can be used as an ordinary document file. 
<LI>The .SAV file is also a backup file. It is created by the tool kit when an
internal error occurs and when it can save the document. This file contains
the state of the document at the very moment of the crash. It can be used in
the same way as the .BAK file.
<LI>The .EXT and .REF files contain the representation of the links that
relate the document with other documents. These files do not exist if the
document has no relations (references) with other documents. If they exist,
they must be in the same directory as the .PIV file. They are read by the
function TtaOpenDocument.
</UL>

</DL>

<DL>
<DT>Directories</DT>

<DD>A list of directories, called the <EM>document path</EM>, is used for
searching the files needed when opening a document (.PIV, .REF and .EXT
files). This path is initially set by the environment variable THOTDOC and it
can be changed at any time by the function TtaSetDocumentPath. When a document
is created (TtaNewDocument), all corresponding files are created in the first
directory of the document path.
<P>Another list of directories is used when searching the schemas needed by a
document that is created (TtaNewDocument) or opened (TtaOpenDocument). The
<EM>schema path</EM> is initially set by the environment variable THOTSCH and
it can be changed at any time by the function TtaSetSchemaPath. This path is
also used by the function TtaNewNature.</P>

</DL>

<DL>
<DT>Access mode</DT>

<DD>When using Thot Editor, the application program may ask the tool kit to
prevent the user from modifying the document: an access mode (allowed values
are read/write and read only) is associated with the whole document. The
functions of the editing tool kit are not affected by the access mode; an
application program can modify a document even if it is in read only mode. The
access mode only applies to the operations performed by the user, who cannot
modify a document that is in read only mode. When creating or opening a
document, the access mode is set to read/write, but it can be changed at any
time by the function TtaSetDocumentAccessMode.
<P>An application program can more precisely control the operations that the
user is allowed to perform, by associating an access mode with each element in
a document. This is explained in section <A HREF="#secta9">9</A>.</P>

</DL>

<DL>
<DT>Natures</DT>

<DD>Many structured documents contain objects of different <EM>natures</EM>,
such as tables, equations, drawings, bibliographic items, etc. which are
themselves logically structured. For avoiding to define the structure of these
objects in the structure schemas of all document types, these objects are
defined in separate structure schemas, one for each nature of objects, and
they can be dynamically linked to document structure schemas. This can be
repeated recursively: if an object of a given nature includes objects of other
natures, its structure schema must include the structure schemas of the
included natures.
<P>When the first object of a given nature is created in a document or in an
object of another nature, the structure schema that defines the new nature
must be linked to the structure schema that defines the document or object in
which it is included. This is achieved by calling the function
TtaNewNature.</P>

</DL>

<DL>
<DT>Schema extensions</DT>

<DD>Documents produced by Thot may be processed by other applications, which
are either independent from the editor or included in it. Examples of such
applications are the comparison of two versions of a document (independent
from the editor) or the electronic index (included in the editor). Many of
these applications make use of their own structural elements or attributes,
which are related to the application itself and which are necessary for the
application, whatever the document type. A <EM>structure schema extension</EM>
is a special type of structure schema that defines attributes and elements of
that kind and that can be associated to the main structure schema of any
document for allowing an application to create in the document its own
attributes and elements, which are not defined in the document structure
schema. When several applications have to work on the same document, several
schema extensions can be associated to the main structure schema of that
document.
</DL>

<H3><A NAME="sectb81">8.1</A> Constructors</H3>

<H4><A NAME="sectc811">8.1.1</A> TtaNewDocument</H4>

<P>Creates the internal representation of a new document according to a given
structure schema. No file is created immediately, but the backup files (.BAK
and .SAV) and the document file (.PIV, see TtaNewDocument) will be created in
the first directory of the document path (see TtaSetDocumentPath).</P>

<HR>

<P>Document TtaNewDocument(char *structureSchema, char *documentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>structureSchema</EM>: name of the structure schema that defines the
type of document to be created.
<P><EM>documentName</EM>: name of the document to be created (maximum length
19 characters). The directory name is not part of this parameter (see
TtaSetDocumentPath).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the document that has been created or 0 if the document has not been
created.
</DL>

<H4><A NAME="sectc812">8.1.2</A> TtaOpenDocument</H4>

<P>Opens an existing document for subsequent operations.</P>

<HR>

<P>Document TtaOpenDocument(char *documentName, int accessMode)</P>

<HR>

<PRE>
Document TtaOpenDocument(documentName, accessMode)
char *documentName;
int accessMode;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>documentName</EM>: name of the file containing the document to be
open. (maximum length 19 characters). The directory name is not part of this
parameter (see TtaSetDocumentPath).
<P><EM>accessMode</EM>: 0 = read only, 1 = read-write.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the opened document, or 0 if the document cannot be open.
</DL>

<H4><A NAME="sectc813">8.1.3</A> TtaSaveDocument</H4>

<P>Saves a document into a file in Thot format (.PIV). The document is not
closed by the function and can still be accessed by the application
program.</P>

<HR>

<P>void TtaSaveDocument(Document document, char *documentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to be saved.
<P><EM>documentName</EM>: name of the file in which the document must be
saved. (maximum length 19 characters). The directory name is not part of this
parameter (see TtaSetDocumentPath). If the documentName is not the same as the
one used when opening (see TtaOpenDocument) or creating (see TtaNewDocument)
the document, a new file is created and the file with the old name is
unchanged, i. e. a new version is created. If necessary, the old file can be
removed by the function TtaRemoveDocument.</P>

</DL>

<H4><A NAME="sectc814">8.1.4</A> TtaExportDocument</H4>

<P>Saves a document into a file in a particular format. The output format is
specified by a translation schema. The document is not closed by the function
and it can still be accessed by the application program.</P>

<HR>

<P>void TtaExportDocument(Document document, char *fileName, char
*TSchemaName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to be exported.
<P><EM>fileName</EM>: name of the file in which the document must be saved,
including the directory name.</P>

<P><EM>TSchemaName</EM>: name of the translation schema to be used. The
directory name must not be specified in parameter TSchemaName. See function
TtaSetSchemaPath.</P>

</DL>

<H4><A NAME="sectc815">8.1.5</A> TtaCloseDocument</H4>

<P>Closes a document that is no longer needed and releases all ressources
allocated to the document. This function does not save the document.</P>

<HR>

<P>void TtaCloseDocument(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document to be closed.
</DL>

<H4><A NAME="sectc816">8.1.6</A> TtaRemoveDocument</H4>

<P>Closes a document, releases all ressources allocated to that document,
removes all files related to the document and updates all links connecting the
removed document with other documents.</P>

<HR>

<P>void TtaRemoveDocument(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document to be removed.
</DL>

<H4><A NAME="sectc817">8.1.7</A> TtaSetDocumentPath</H4>

<P>Sets a new list of document directories. This list replaces the existing
one. It is used for searching a document when it is open either by the user or
by the application program (see TtaOpenDocument). The first directory in the
list is used when a new document is created (see TtaNewDocument).</P>

<HR>

<P>void TtaSetDocumentPath(char *path)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>path</EM>: the directory list, where directory names are separated by
the character ':'.
</DL>

<H4><A NAME="sectc818">8.1.8</A> TtaAppendDocumentPath</H4>

<P>Appends a new directory in the list of document directories. The function
controls that the parameter is the name of an existing directory and sets an
error if it is not. If the new directory is within the list of document
directories yet, the function has no effect.</P>

<HR>

<P>void TtaAppendDocumentPath(aDirectory)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>aDirectory</EM>: the new directory name.
</DL>

<H4><A NAME="sectc819">8.1.9</A> TtaSetSchemaPath</H4>

<P>Sets a new list of schema directories. This list replaces the existing one.
It is used for searching schemas.</P>

<HR>

<P>void TtaSetSchemaPath(char *path)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>path</EM>: the directory list, where directory names are separated by
the character ':'.
</DL>

<H3><A NAME="sectb82">8.2</A> Modificators</H3>

<H4><A NAME="sectc821">8.2.1</A> TtaNewNature</H4>

<P>Adds a new nature in a structure schema and returns the structure schema of
the new nature. If the nature already exists in that structure schema, the
function simply returns the structure schema of that nature.</P>

<HR>

<P>SSchema TtaNewNature(SSchema schema, char *natureName, char
*presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>schema</EM>: the structure schema to which the nature is added.
<P><EM>natureName</EM>: name of the nature to be added in the structure
schema.</P>

<P><EM>presentationName</EM>: name of the presentation schema to be associated
with the extension schema. If presentationName is an empty string, the default
presentation schema is associated. If the nature already exists,
presentationName is ignored.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the structure schema of the new nature; NULL if the structure schema has
not been loaded.
</DL>

<H4><A NAME="sectc822">8.2.2</A> TtaNewSchemaExtension</H4>

<P>Loads a structure schema extension and associates it with a given
document.</P>

<HR>

<P>SSchema TtaNewSchemaExtension(Document document, char *extensionName, char
*presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose structure schema must be extended.
<P><EM>extensionName</EM>: name of the extension schema.</P>

<P><EM>presentationName</EM>: name of the presentation schema to be associated
with the extension schema. If presentationName is an empty string, the default
presentation schema is associated.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the extension schema, NULL if the extension schema has not been loaded.
</DL>

<H4><A NAME="sectc823">8.2.3</A> TtaRemoveSchemaExtension</H4>

<P>Removes a structure schema extension from a given document. Removes also
from the document all attributes and elements defined in that structure schema
extension.</P>

<HR>

<P>void TtaRemoveSchemaExtension(Document document, SSchema extension, int
*removedElements, int *removedAttributes)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>extension</EM>: the structure schema extension to be removed.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>removedElements</EM>: number of elements actually removed.
<P><EM>removedAttributes</EM>: number of attributes actually removed.</P>

</DL>

<H4><A NAME="sectc824">8.2.4</A> TtaSetPSchema</H4>

<P>Sets or changes the main presentation schema of a document. The document
must be open, but no view must be open for that document.</P>

<HR>

<P>void TtaSetPSchema(Document document, char *presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>presentationName</EM>: Name of the presentation schema to be associated
with the document.</P>

</DL>

<H4><A NAME="sectc825">8.2.5</A> TtaSetDocumentDirectory</H4>

<P>Sets the directory to which the document will be saved when calling
TtaSaveDocument.</P>

<HR>

<P>void TtaSetDocumentDirectory(Document document, char *directory)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose directory is set.
<P><EM>directory</EM>: new document directory.</P>

</DL>

<H4><A NAME="sectc826">8.2.6</A> TtaSetDocumentName</H4>

<P>Sets or changes the name of a document. The document must be loaded.</P>

<HR>

<P>void TtaSetDocumentName(Document document, char *documentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose name is set.
<P><EM>documentName</EM>: new document name. This is only the name, without
any suffix, without directory name. See function TtaSetDocumentDirectory for
changing the directory of a document.
The name must not exceed 31 characters.</P>

</DL>

<H4><A NAME="sectc827">8.2.7</A> TtaSetDocumentAccessMode</H4>

<P>Sets the access mode for a document.</P>

<HR>

<P>void TtaSetDocumentAccessMode(Document document, int accessMode)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose access mode is changed.
<P><EM>accessMode</EM>: 0 = read only, 1 = read-write.</P>

</DL>

<H4><A NAME="sectc828">8.2.8</A> TtaSetDocumentBackUpInterval</H4>

<P>Sets the backup interval for a document.</P>

<HR>

<P>void TtaSetDocumentBackUpInterval(Document document, int interval)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose backup interval is changed.
<P><EM>interval</EM>: 0 : the backup mechanism must be disabled
positive integer : number of characters typed which triggers automatic save of
the document into a .BAK file.</P>

</DL>

<H4><A NAME="sectc829">8.2.9</A> TtaSetNotificationMode</H4>

<P>Sets the ECF notification mode for a document.</P>

<HR>

<P>void TtaSetNotificationMode(Document document, int notificationMode)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose notification mode is changed.
<P><EM>notificationMode</EM>: 0 = only roots of created, copied and deleted
subtrees must be notified, 1 = all elements of created, copied and deleted
subtrees must be notified.</P>

</DL>

<H4><A NAME="sectc8210">8.2.10</A> TtaSetDocumentModified</H4>

<P>Notifies the tool kit that a document has been modified by the application.
As a consequence, the user will be asked to save the document when closing
it.</P>

<HR>

<P>void TtaSetDocumentModified(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<H4><A NAME="sectc8211">8.2.11</A> TtaSetDocumentUnmodified</H4>

<P>Notifies the tool kit that a document must be considered as not modified.
As a consequence, if no further modification is made to that document, the
user will not be asked to save the document when closing it.</P>

<HR>

<P>void TtaSetDocumentUnmodified(Document document)</P>

<HR>

<DL>
<DT>Parameter :</DT>

<DD>
<P><EM>document</EM> : the document.</P>

</DL>

<H3><A NAME="sectb83">8.3</A> Accessors</H3>

<H4><A NAME="sectc831">8.3.1</A> TtaGetSchemaExtension</H4>

<P>Returns the extension structure schema associated with the given
document.</P>

<HR>

<P>SSchema TtaGetSchemaExtension(Document document, char *ExtensionName)</P>

<HR>

<DL>
<DT>Parameter :</DT>

<DD>
<P><EM>document</EM> : the document for which the extension structure schema
is asked.</P>

<P><EM>ExtensionName</EM> : the extension name.</P>

</DL>

<H4><A NAME="sectc832">8.3.2</A> TtaGetDocumentName</H4>

<P>Returns the name of a document.</P>

<HR>

<P>char *TtaGetDocumentName(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>
<P><EM>document</EM>: the document whose name is asked.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that document.
</DL>

<H4><A NAME="sectc833">8.3.3</A> TtaGetDocumentFromName</H4>

<P>Returns the document having a given name.</P>

<HR>

<P>Document TtaGetDocumentFromName(char *documentName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>
<P><EM>documentName</EM>: the document name.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the document having that name.
</DL>

<H4><A NAME="sectc834">8.3.4</A> TtaGetDocumentSSchema</H4>

<P>Returns the main structure schema of a document.</P>

<HR>

<P>SSchema TtaGetDocumentSSchema(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the structure schema is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the structure schema of that document.
</DL>

<H4><A NAME="sectc835">8.3.5</A> TtaGetSSchemaName</H4>

<P>Returns the name of a structure schema.</P>

<HR>

<P>char *TtaGetSSchemaName(SSchema schema)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>schema</EM>: the structure schema of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that structure schema.
</DL>

<H4><A NAME="sectc836">8.3.6</A> TtaGetPSchemaName</H4>

<P>Returns the name of the presentation schema currently associated with a
given structure schema.</P>

<HR>

<P>char *TtaGetPSchemaName(SSchema schema)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>schema</EM>: the structure schema of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of the associated presentation schema.
</DL>

<H4><A NAME="sectc837">8.3.7</A> TtaGetDocumentDirectory</H4>

<P>Returns the directory to which the document is supposed to be saved.</P>

<HR>

<P>void TtaGetDocumentDirectory(Document document, char *buffer, int
bufferLength)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>document</EM>: the document whose directory is asked.</P>

<P><EM>buffer</EM>: a buffer provided by the caller.</P>

<P><EM>bufferLength</EM>: the length of that buffer.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: the document directory.
</DL>

<H4><A NAME="sectc838">8.3.8</A> TtaGetSSchema</H4>

<P>Returns a structure schema whose name is known and that is used in a given
document.</P>

<HR>

<P>SSchema TtaGetSSchema(char *name, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: the name of the structure schema of interest.
<P><EM>document</EM>: the document that uses this structure schema.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the structure schema having this name, or NULL if this structure schema is
not loaded or not used by the document.
</DL>

<H4><A NAME="sectc839">8.3.9</A> TtaSameSSchemas</H4>

<P>Compares two structure schemas.</P>

<HR>

<P>int TtaSameSSchemas(SSchema schema1, SSchema schema2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>schema1</EM>: first structure schema.
<P><EM>schema2</EM>: second structure schema.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both schemas are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc8310">8.3.10</A> TtaGiveSchemasOfDocument</H4>

<P>Returns the names of the main structure schema and presentation schema
associated with a given document. The document does not need to be open and
the schemas are not loaded by this function.</P>

<HR>

<P>void TtaGiveSchemasOfDocument(char *documentName, char *structureName, char
*presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>documentName</EM>: Name of the document to be checked (maximum length
19 characters).
<P><EM>structureName</EM>: buffer.</P>

<P><EM>presentationName</EM>: buffer.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD><EM>structureName</EM>: Name of the document structure schema.
<P><EM>presentationName</EM>: Name of the document presentation schema.</P>

</DL>

<H4><A NAME="sectc8311">8.3.11</A> TtaNextSchemaExtension</H4>

<P>Returns a structure schema extension associated with a given document.</P>

<HR>

<P>void TtaNextSchemaExtension(Document document, SSchema *extension)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document of interest.
<P><EM>extension</EM>: a schema extension of that document. NULL for accessing
the first schema extension.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>extension</EM>: the schema extension that follows or the first schema
extension of the document if parameter extension is NULL. NULL if there is no
more schema extension.
</DL>

<H4><A NAME="sectc8312">8.3.12</A> TtaNextNature</H4>

<P>Returns the structure schema of a nature used in a given document.</P>

<HR>

<P>void TtaNextNature(Document document, SSchema *nature)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document of interest.
<P><EM>nature</EM>: the structure schema of a nature for that document. NULL
for accessing the first nature.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>nature</EM>: the structure schema of the next nature, or the structure
schema of the first nature of the document if parameter nature was NULL when
calling. NULL if there is no more nature for the document.
</DL>

<H4><A NAME="sectc8313">8.3.13</A> TtaIsDocumentModified</H4>

<P>Indicates whether a document has been modified by the user or not.
Modifications made by the application program are not considered, except when
explicitly notified by TtaSetDocumentModified.</P>

<HR>

<P>int TtaIsDocumentModified(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the document has been modified by the user since it has been saved,
loaded or created, 0 if it has not been modified.
</DL>

<H4><A NAME="sectc8314">8.3.14</A> TtaGetDocumentBackUpInterval</H4>

<P>Returns the backup interval for a document.</P>

<HR>

<P>int TtaGetDocumentBackUpInterval(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document whose backup interval is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>0 : the backup mechanism is disabled
positive integer : number of typed characters which trigger an autamatic save
of the document into a .BAK file.
</DL>

<H4><A NAME="sectc8315">8.3.15</A> TtaGetDocumentAccessMode</H4>

<P>Returns the access mode for a document.</P>

<HR>

<P>int TtaGetDocumentAccessMode(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document whose access mode is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if access mode is read only, 1 if access mode is read-write.
</DL>

<H4><A NAME="sectc8316">8.3.16</A> TtaGetNotificationMode</H4>

<P>Returns the ECF notification mode for a document.</P>

<HR>

<P>int TtaGetNotificationMode(Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose notification mode is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>0 = if only roots of created and deleted subtrees must be notified,
<P>1 = all elements of created and deleted subtrees must be notified.</P>

</DL>

<H4><A NAME="sectc8317">8.3.17</A> TtaGetDocumentPath</H4>

<P>Returns the current list of the directories used when a document is open
(see TtaOpenDocument).</P>

<HR>

<P>void TtaGetDocumentPath(char *buffer, int bufferLength)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>buffer</EM>: a buffer provided by the caller.
<P><EM>bufferLength</EM>: the length of that buffer.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: the list of directories. Directory names are separated by
the character ':'.
</DL>

<H4><A NAME="sectc8318">8.3.18</A> TtaGetSchemaPath</H4>

<P>Returns the current list of directories used for accessing schemas.</P>

<HR>

<P>void TtaGetSchemaPath(char *buffer, int bufferLength)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>buffer</EM>: a buffer provided by the caller.
<P><EM>bufferLength</EM>: the length of that buffer.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: the list of directories. Directory names are separated by
the character ':'.
</DL>

<H4><A NAME="sectc8319">8.3.19</A> TtaGetDocumentOfSavedElements</H4>

<P>Returns the document for which the last Copy or Cut command has been
issued.</P>

<HR>

<P>Document TtaGetDocumentOfSavedElements()</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>no parameter
</DL>

<DL>
<DT>Return value:</DT>

<DD>the document for which the last Copy or Cut command has been issued. 0 if
the clipboard is empty.
</DL>

<H2><A NAME="secta9">9</A> <A NAME="L2176">Tree structures</A></H2>

<P>The largest group of functions in the editing tool kit handles the tree
structures that represent the logical organization of a document.</P>

<P>The functions described in this section require that file <EM>tree.h</EM>
be included in the module that calls them.</P>

<DL>
<DT>Main tree and associated trees</DT>

<DD>A document is in fact represented by a <EM>forest</EM>, as several trees
may be necessary for representing its abstract structure. The <EM>main
tree</EM> represents the main stream of information in a document. In addition
to that tree, there may exist some <EM>associated trees</EM>, which represent
other streams of information, such as notes, illustrations, comments, etc.
These associated trees are specified in the structure schema of the document.
</DL>

<DL>
<DT>Structure of abstract trees</DT>

<DD>Several functions in this group allow to build or modify the structure of
an abstract tree. As stated above, the structure of these trees is constrained
by structure schemas. Therefore the programmer must be careful when handling
abstract trees. All functions that change a tree structure check that the
result will be consistent with the structure schema and they raise an error in
case of inconsistency.
<P>Checking can be made in two modes, a strict mode and a relaxed mode. In
strict mode, all mandatory elements must always be present. In relaxed mode,
even elements that are not stated optional in their structure schema can be
omitted. The checking mode apply to the operations made by the application
program, but also to the editing commands issued by the end-user, when using
ThotEditor. The function TtaSetCheckingMode (see section <A
HREF="#sectc928">9.2.8</A>) changes checking mode.</P>

<P>For building a correct tree, the programmer must follow the structure
schema. He or she can also consider existing Thot documents as examples. For
that purpose, the function TtaListAbstractTree (see section <A
HREF="#sectc951">9.5.1</A>) can produce a human-readable form of an abstract
tree.</P>

</DL>

<DL>
<DT>Element types</DT>

<DD>When creating or searching elements in an abstract tree, the type of the
concerned elements must be given. As presented in section <A
HREF="#secta4">4</A>, an element type contains a type number, but this number
does not appear explicitly in a structure schema: it is generated by the
schema compiler. For obtaining all type numbers of a structure schema, use the
command:
<EM>       printsch -h SchemaName
</EM>which lists on the standard output a file that can be included into a C
program. This file also contains all attribute numbers of the schema
</DL>

<DL>
<DT>Order of operations</DT>

<DD>As a general rule, as soon as an element or a tree has been created (by
functions TtaNewElement, TtaNewTree, or TtaCopyTree), it must be included into
the main tree or an associated tree of a document (by functions
TtaInsertSibling, TtaInsertFirstChild, or TtaAttachNewTree), prior any other
function can be performed.
</DL>

<DL>
<DT>Labels</DT>

<DD>Each element in a document has a unique identifier called a
<EM>label</EM>. Labels are automatically assigned to elements by all functions
that create new elements (TtaNewElement, TtaNewTree, or TtaCopyTree). Labels
can be accessed by functions TtaSearchElementByLabel and TtaGetElementLabel.
</DL>

<DL>
<DT>Access rights</DT>

<DD>An access right can be associated with each element. Three access rights
are defined:
<DL>
<DT>Read/write</DT>

<DD>The element can be seen and modified by the user.
<DT>Read only</DT>

<DD>The element can be seen by the user, but no changes are allowed.
<DT>Hidden</DT>

<DD>The element is not displayed and cannot be changed by the user.
</DL>

<P>These rights only apply to the end user who manipulates a document
interactively with the commands provided by the Thot editor. They do not apply
to the application program that manipulate the document through the editing
tool kit.</P>

</DL>

<H3><A NAME="sectb91">9.1</A> Constructors</H3>

<H4><A NAME="sectc911">9.1.1</A> TtaNewElement</H4>

<P>Creates a new element of a given type.</P>

<HR>

<P>Element TtaNewElement(Document document, ElementType elementType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the element is created.
<P><EM>elementType</EM>: type of the element to be created.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the created element.
</DL>

<H4><A NAME="sectc912">9.1.2</A> TtaNewTree</H4>

<P>Creates a new element of a given type and all its descendants, according to
the structure schema.</P>

<HR>

<P>Element TtaNewTree(Document document, ElementType elementType , char
*label)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the tree is created.
<P><EM>elementType</EM>: type of the root element of the tree to be
created.</P>

<P><EM>label</EM>: label of the root element to be created. Empty string if
the value of the label is undefined.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the root element of the created tree.
</DL>

<H4><A NAME="sectc913">9.1.3</A> TtaCopyTree</H4>

<P>Creates a copy of a tree.</P>

<HR>

<P>Element TtaCopyTree(Element sourceElement, Document sourceDocument,
Document destinationDocument, Element parent)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>sourceElement</EM>: element to be copied.
<P><EM>sourceDocument</EM>: the document containing the element to be
copied.</P>

<P><EM>destinationDocument</EM>: the document for which the copy must be
created.</P>

<P><EM>parent</EM>: element that will become the parent of the created
tree.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the root element of the created tree.
</DL>

<H4><A NAME="sectc914">9.1.4</A> TtaCreateDescent</H4>

<P>Creates a new element of a given type and inserts it in the tree as a
descendant of a given element. All elements of the descent required by the
structure schema are also created.</P>

<HR>

<P>Element TtaCreateDescent(Document document, Element element, ElementType
elementType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the tree is created.
<P><EM>element</EM>: the element for which a descent will be created.</P>

<P><EM>elementType</EM>: type of the element to be created as the last
descendant.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the last descendant created or NULL if the element cannot be created. This
element is empty.
</DL>

<H4><A NAME="sectc915">9.1.5</A> TtaCreateDescentWithContent</H4>

<P>Creates a new element of a given type and inserts it in the tree as a
descendant of a given element. All elements of the descent required by the
structure schema are created, as well as the content of the requested
element.</P>

<HR>

<P>Element TtaCreateDescentWithContent(Document document, Element element,
ElementType elementType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the tree is created.
<P><EM>element</EM>: the element for which a descent will be created.</P>

<P><EM>elementType</EM>: type of the element to be created as the last
descendant.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the last descendant created or NULL if the element cannot be created. If
not NULL, the minimum content of that element has been created.
</DL>

<H4><A NAME="sectc916">9.1.6</A> TtaDeleteTree</H4>

<P>Deletes a tree (or a single element) and frees it. All references that
points at any element of that tree are cancelled. The deleted element must not
be used later.</P>

<HR>

<P>void TtaDeleteTree(Element element, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element (or root of the tree) to be deleted.
<P><EM>document</EM>: the document containing the element to be deleted.</P>

</DL>

<H4><A NAME="sectc917">9.1.7</A> TtaAttachNewTree</H4>

<P>Attaches an entire tree (main tree or associated tree) to a document.</P>

<HR>

<P>void TtaAttachNewTree(Element tree, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>tree</EM>: root of the tree to be attached. This tree must be a valid
main tree or associated tree according to the document structure schema.
<P><EM>document</EM>: the document to which the tree is to be attached.</P>

</DL>

<H3><A NAME="sectb92">9.2</A> Modificators</H3>

<H4><A NAME="sectc921">9.2.1</A> TtaInsertSibling</H4>

<P>Inserts an element in a tree, as an immediate sibling of a given element.
The element to be inserted must not yet be part of a document. You can call
<TT>TtaCanInsertSibling</TT> before to check whether that insertion is allowed
or not (see section <A HREF="#"></A>).</P>

<HR>

<P>void TtaInsertSibling(Element newElement, Element sibling, boolean before,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>newElement</EM>: the element (or root of the tree) to be inserted.
<P><EM>sibling</EM>: an element belonging to a tree. This element must not be
the root of a tree.</P>

<P><EM>before</EM>: if True, inserts newElement as previous sibling of
sibling, if False, inserts newElement as next sibling of sibling.</P>

<P><EM>document</EM>: the document to which both elements belong.</P>

</DL>

<H4><A NAME="sectc922">9.2.2</A> TtaInsertFirstChild</H4>

<P>Inserts an element in a tree, as the first child of a given element. The
element to be inserted must not yet be part of a document. This function can
also be used for attaching an option to a choice. You can call
<TT>TtaCanInsertFirstChild</TT> before to check whether that insertion is
allowed or not (see section <A HREF="#sectc9330">9.3.30</A>).</P>

<HR>

<P>void TtaInsertFirstChild(Element *newElement, Element parent, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>newElement</EM>: the element (or root of the tree) to be inserted.
<P><EM>parent</EM>: an element belonging to a tree.</P>

<P><EM>document</EM>: the document to which both elements belong.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD>If newElement is an option that replaces the choice, newElement takes
<P>the value of parent.</P>

</DL>

<H4><A NAME="sectc923">9.2.3</A> TtaCreateElement</H4>

<P>Creates an element of a given type and insert it at the current position
within a given document. The current position is defined by the current
selection. If the current position is a single position (insertion point) the
new element is simply inserted at that position. If one or several characters
and/or elements are selected, the new element is created at that position and
the selected characters/elements become the content of the new element,
provided the  structure schema allows it.</P>

<HR>

<P>void TtaCreateElement(ElementType elementType, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType</EM>: type of the element to be created.
<P><EM>document</EM>: the document for which the element is created.</P>

</DL>

<H4><A NAME="sectc924">9.2.4</A> TtaInsertElement</H4>

<P>Creates an element of a given type and insert it at the current position
within a given document. The current position is defined by the current
selection. If the current position is a single position (insertion point) the
new element is simply inserted at that position. If one or several characters
and/or elements are selected, the new element is created before the first
selected character/element and the selected characters/elements are not
changed.</P>

<HR>

<P>void TtaInsertElement(ElementType elementType, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType</EM>: type of the element to be created.
<P><EM>document</EM>: the document for which the element is created.</P>

</DL>

<H4><A NAME="sectc925">9.2.5</A> TtaRemoveTree</H4>

<P>Removes a tree (or a single element) from its tree, without freeing it.</P>

<HR>

<P>void TtaRemoveTree(Element element, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element (or root of the tree) to be removed.
<P><EM>document</EM>: the document containing the element to be removed.</P>

</DL>

<H4><A NAME="sectc926">9.2.6</A> TtaSetAccessRight</H4>

<P>Sets the access rights for a given element. Access rights apply only during
the current editing session; they are not saved with the document. They must
be set each time the document is loaded.</P>

<HR>

<P>void TtaSetAccessRight(Element element, AccessRight right, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element.
<P><EM>right</EM>: access right for that element (ReadOnly, ReadWrite, Hidden,
Inherited).</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc927">9.2.7</A> TtaHolophrastElement</H4>

<P>Changes the holophrasting status of a given element.</P>

<HR>

<P>void TtaHolophrastElement(Element element, boolean holophrast, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element.
<P><EM>holophrast</EM>: True: the element gets holophrasted if it is not,
False: if the element is holphrasted, it gets expanded.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc928">9.2.8</A> <A NAME="L2778">TtaSetCheckingMode</A></H4>

<P>Changes checking mode.</P>

<HR>

<P>void TtaSetCheckingMode(boolean strict)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>strict</EM>: if True, the presence of all mandatory elements is
checked.
</DL>

<H3><A NAME="sectb93">9.3</A> Accessors</H3>

<H4><A NAME="sectc931">9.3.1</A> TtaGetMainRoot</H4>

<P>Returns the root element of the main abstract tree representing a
document.</P>

<HR>

<P>Element TtaGetMainRoot(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the root element of the main abstract tree.
</DL>

<H4><A NAME="sectc932">9.3.2</A> TtaNextAssociatedRoot</H4>

<P>Returns the root element of the associated tree that follows the tree to
which a given element belongs.</P>

<HR>

<P>void TtaNextAssociatedRoot(Document document, Element root)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>root</EM>: the element for which the next associated tree is searched.
That element does not need to be the root of a tree. If root is NULL or if
root is an element in the main tree, the root of the first associated tree is
returned.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>root</EM>: the root element of the next associated tree. NULL if there
is no next associated tree for the document.
</DL>

<H4><A NAME="sectc933">9.3.3</A> TtaGetFirstChild</H4>

<P>Returns the first child element of a given element.</P>

<HR>

<P>Element TtaGetFirstChild(Element parent)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parent</EM>: the element for which the first child element is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the first child element of parent; NULL if parent has no child.
</DL>

<H4><A NAME="sectc934">9.3.4</A> TtaGetLastChild</H4>

<P>Returns the last child element of a given element.</P>

<HR>

<P>Element TtaGetLastChild(Element parent)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parent</EM>: the element for which the last child element is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the last child element of parent; NULL if parent has no child.
</DL>

<H4><A NAME="sectc935">9.3.5</A> TtaPreviousSibling</H4>

<P>Returns the previous sibling element of a given element.</P>

<HR>

<P>void TtaPreviousSibling(Element *element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose previous sibling is asked.
</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>element</EM>: the previous sibling element, or NULL if there is no
previous sibling.
</DL>

<H4><A NAME="sectc936">9.3.6</A> TtaNextSibling</H4>

<P>Returns the next sibling element of a given element.</P>

<HR>

<P>void TtaNextSibling(Element *element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose next sibling is asked.
</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>element</EM>: the next sibling element, or NULL if there is no next
sibling.
</DL>

<H4><A NAME="sectc937">9.3.7</A> TtaGetSuccessor</H4>

<P>Returns the element that follows a given element at the same level or at
the first upper level where there is a following element.</P>

<HR>

<P>Element TtaGetSuccessor(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose successor is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the successor, or NULL if there is no successor.
</DL>

<H4><A NAME="sectc938">9.3.8</A> TtaGetPredecessor</H4>

<P>Returns the element that precedes a given element at the same level or at
the first upper level where there is a preceding element.</P>

<HR>

<P>Element TtaGetPredecessor(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose predecessor is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the predecessor, or NULL if there is no predecessor.
</DL>

<H4><A NAME="sectc939">9.3.9</A> TtaGetParent</H4>

<P>Returns the parent element (i.e. first ancestor) of a given element.</P>

<HR>

<P>Element TtaGetParent(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose the parent is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the parent element, or NULL if there is no parent (root).
</DL>

<H4><A NAME="sectc9310">9.3.10</A> TtaGetCommonAncestor</H4>

<P>Returns the common ancestor element of two given elements.</P>

<HR>

<P>Element TtaGetCommonAncestor(Element element1, Element element2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element1</EM>: the first element whose ancestor is asked.
<P><EM>element2</EM>: the second element whose ancestor is asked.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the common ancestor, or NULL if there is no common ancestor.
</DL>

<H4><A NAME="sectc9311">9.3.11</A> TtaGetTypedAncestor</H4>

<P>Returns the first ancestor of a given type for a given element.</P>

<HR>

<P>Element TtaGetTypedAncestor(Element element, ElementType ancestorType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element whose ancestor is asked.
<P><EM>ancestorType</EM>: type of the asked ancestor.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the ancestor, or NULL if there is no ancestor of that type.
</DL>

<H4><A NAME="sectc9312">9.3.12</A> TtaGetElementType</H4>

<P>Returns the type of a given element.</P>

<HR>

<P>ElementType TtaGetElementType(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>type of the element.
</DL>

<H4><A NAME="sectc9313">9.3.13</A> TtaGetElementTypeName</H4>

<P>Returns the name of an element type.</P>

<HR>

<P>char *TtaGetElementTypeName(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: element type.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that type.
</DL>

<H4><A NAME="sectc9314">9.3.14</A> TtaGiveTypeFromName</H4>

<P>Gives an element type whose name is known (the structure schema that
defines that type must be loaded). That type is searched in a given structure
schema (elementType.ElSSchema) and in all structure schemas that are
extensions of that structure schema or natures used in that structure
schema.</P>

<HR>

<P>void TtaGiveTypeFromName(ElementType *elementType, char *name)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType.ElSSchema</EM>: the structure schema of interest.
<P><EM>name</EM>: the name of the type of interest.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>elementType</EM>: the type having this name, or elementType.ElTypeNum
= 0 if the type is not found.
</DL>

<H4><A NAME="sectc9315">9.3.15</A> TtaSameTypes</H4>

<P>Compares two element types.</P>

<HR>

<P>int TtaSameTypes(ElementType type1, ElementType type2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>type1</EM>: first element type.
<P><EM>type2</EM>: second element type.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both types are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc9316">9.3.16</A> TtaGetElementLabel</H4>

<P>Returns the label of a given element.</P>

<HR>

<P>char *TtaGetElementLabel(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>label of the element.
</DL>

<H4><A NAME="sectc9317">9.3.17</A> TtaIsConstant</H4>

<P>Indicates whether an element type is a constant.</P>

<HR>

<P>int TtaIsConstant(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: type to be tested.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 = the type is a constant, 0 = the type is not a constant.
</DL>

<H4><A NAME="sectc9318">9.3.18</A> TtaIsLeaf</H4>

<P>Indicates whether an element type is a leaf.</P>

<HR>

<P>int TtaIsLeaf(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: type to be tested.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the type is a leaf, 0 if the type is not a leaf.
</DL>

<H4><A NAME="sectc9319">9.3.19</A> TtaGetConstructOfType</H4>

<P>Returns the construct of an element type.</P>

<HR>

<P>Construct TtaGetConstructOfType(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: the element type of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the construct that defines the structure of that element type.
</DL>

<H4><A NAME="sectc9320">9.3.20</A> TtaGetConstruct</H4>

<P>Returns the construct of an element.</P>

<HR>

<P>Construct TtaGetConstruct(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the construct that defines the structure of that element.
</DL>

<H4><A NAME="sectc9321">9.3.21</A> TtaGetAccessRight</H4>

<P>Returns the access rights for a given element.</P>

<HR>

<P>AccessRight TtaGetAccessRight(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>access right for that element (ReadOnly, ReadWrite, Hidden, Inherited).
</DL>

<H4><A NAME="sectc9322">9.3.22</A> TtaIsHolophrasted</H4>

<P>Tests whether a given element is holphrasted or not.</P>

<HR>

<P>int TtaIsHolophrasted(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is holphrasted, 0 if not.
</DL>

<H4><A NAME="sectc9323">9.3.23</A> TtaIsReadOnly</H4>

<P>Tests whether a given element is protected against user modifications
(ReadOnly).</P>

<HR>

<P>int TtaIsReadOnly(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is protected, 0 if not.
</DL>

<H4><A NAME="sectc9324">9.3.24</A> TtaIsHidden</H4>

<P>Tests whether a given element is hidden to the user (Hidden).</P>

<HR>

<P>int TtaIsHidden(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is hidden, 0 if not.
</DL>

<H4><A NAME="sectc9325">9.3.25</A> TtaIsInAnInclusion</H4>

<P>Tests whether a given element is (in) an included element. An included
element is a "live" copy of another element.</P>

<HR>

<P>int TtaIsInAnInclusion(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is included, 0 if not.
</DL>

<H4><A NAME="sectc9326">9.3.26</A> TtaIsAncestor</H4>

<P>Tests if an element is an ancestor of another element.</P>

<HR>

<P>int TtaIsAncestor(Element element, Element ancestor)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: an element.
<P><EM>ancestor</EM>: the supposed ancestor of element.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if ancestor in an ancestor of element, 0 if not.
</DL>

<H4><A NAME="sectc9327">9.3.27</A> TtaIsBefore</H4>

<P>Tests if an element precedes another element in the preorder traversal of
the tree.</P>

<HR>

<P>int TtaIsBefore(Element element1, Element element2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element1</EM>: the first element.
<P><EM>element2</EM>: the second element.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the first element precedes the second element, 0 if not.
</DL>

<H4><A NAME="sectc9328">9.3.28</A> TtaIsFirstPairedElement</H4>

<P>Indicates if a given paired element is the first or the second of the
pair.</P>

<HR>

<P>int TtaIsFirstPairedElement(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the paired element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if it is the first element of the pair, 0 if it is the second.
</DL>

<H4><A NAME="sectc9329">9.3.29</A> TtaCanInsertSibling</H4>

<P>Checks whether an element of a given type can be inserted in an abstract
tree as an immediate sibling of an existing element.</P>

<HR>

<P>boolean TtaCanInsertSibling(ElementType elementType, Element sibling,
boolean before, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: the element type to be checked.
<P><EM>sibling</EM>: an existing element which is part of an abstract
tree.</P>

<P><EM>before</EM>: if True, checks if insertion is allowed before element
"sibling".
If False, checks if insertion is allowed after element "sibling".</P>

<P><EM>document</EM>: the document to which element "sibling" belongs.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True if that element type can be inserted, False if the structure schema
does not allow that insertion.
</DL>

<H4><A NAME="sectc9330">9.3.30</A> <A
NAME="L32256">TtaCanInsertFirstChild</A></H4>

<P>Checks whether an element of a given type can be inserted in an abstract
tree as the first child of an existing element (parent).</P>

<HR>

<P>boolean TtaCanInsertFirstChild(ElementType elementType, Element parent,
Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: the element type to be checked.
<P><EM>parent</EM>: an existing element which is part of an abstract tree.</P>

<P><EM>document</EM>: the document to which element "parent" belongs.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True if that element type can be inserted, False if the structure schema
does not allow that insertion.
</DL>

<H4><A NAME="sectc9331">9.3.31</A> TtaGetDocument</H4>

<P>Returns the document containing a given element</P>

<HR>

<P>Document TtaGetDocument(Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element for which document is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the document containing that element or 0 if the element does not belong
to any document.
</DL>

<H4><A NAME="sectc9332">9.3.32</A> TtaNextCopiedElement</H4>

<P>Returns one of the elements that have been copied into the ``clipboard'' by
the last Copy or Cut command. (This function is available only in the
ThotEditor library).</P>

<HR>

<P>void TtaNextCopiedElement(Element *element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: NULL if the first element of the clipboard is asked; an
element of the clipboard if the next one is asked.
</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>element</EM>: the asked element if it exists, or NULL if there is no
next element in the clipboard or if the clipboard is empty.
</DL>

<H4><A NAME="sectc9333">9.3.33</A> TtaGetCopiedDocument</H4>

<P>Returns the document from which the current content of the clipboard has
been copied or cut. (This function is available only in the ThotEditor
library).</P>

<HR>

<P>Document TtaGetCopiedDocument()</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>No parameter.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the document from which the current content of the clipboard has been
copied or cut; 0 if the clipboard is empty.
</DL>

<H3><A NAME="sectb94">9.4</A> Locators</H3>

<H4><A NAME="sectc941">9.4.1</A> TtaSearchTypedElement</H4>

<P>Returns the first element of a given type. Searching can be done in a tree
or starting from a given element towards the beginning or the end of the
abstract tree.</P>

<HR>

<P>Element TtaSearchTypedElement(ElementType searchedType, SearchDomain scope,
Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedType</EM>: type of element to be searched. If
searchedType.ElSSchema is NULL, searchedType must be a basic type ; then the
next basic element of that type will be returned, whatever its structure
schema.
<P><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.</P>

<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if no element has been found.
</DL>

<H4><A NAME="sectc942">9.4.2</A> TtaSearchElementByLabel</H4>

<P>Searches the element that has a given label. The search is done in a given
tree.</P>

<HR>

<P>Element TtaSearchElementByLabel(char *searchedLabel, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedLabel</EM>: label of element to be searched.
<P><EM>element</EM>: the element that is the root of the tree in which the
search is done.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if no element has been found.
</DL>

<H4><A NAME="sectc943">9.4.3</A> TtaSearchEmptyElement</H4>

<P>Searches the next empty element. An empty element is either a compound
element without child or a leaf without content. Searching can be done in a
tree or starting from a given element towards the beginning or the end of the
abstract tree.</P>

<HR>

<P>Element TtaSearchEmptyElement(SearchDomain scope, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.
<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD>the element found, or NULL if not found.
</DL>

<H4><A NAME="sectc944">9.4.4</A> TtaSearchOtherPairedElement</H4>

<P>Returns the element that is part of the same pair as a given element.</P>

<HR>

<P>Element TtaSearchOtherPairedElement(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose paired element is searched.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the paired element.
</DL>

<H4><A NAME="sectc945">9.4.5</A> TtaSearchNoPageBreak</H4>

<P>Returns the first sibling element that is not a page break.</P>

<HR>

<P>Element TtaSearchNoPageBreak(Element element, boolean forward)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
<P><EM>forward</EM>: True for skipping the next page breaks, False for
skipping the previous ones.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the first sibling element, or NULL if there are only page breaks.
</DL>

<H3><A NAME="sectb95">9.5</A> Help</H3>

<H4><A NAME="sectc951">9.5.1</A> <A NAME="L4054">TtaListAbstractTree</A></H4>

<P>Produces in a file a human-readable form of an abstract tree.</P>

<HR>

<P>void TtaListAbstractTree(Element root, FILE *fileDescriptor)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>root</EM>: the root element of the tree to be listed.
<P><EM>fileDescriptor</EM>: file descriptor of the file that will contain the
list. This file must be open when calling the function.</P>

</DL>

<H2><A NAME="secta10">10</A> <A NAME="L4085">Contents</A></H2>

<P>The functions described in this section require that file
<EM>content.h</EM> be included in the module that calls them.</P>

<H3><A NAME="sectb101">10.1</A> Modificators</H3>

<H4><A NAME="sectc1011">10.1.1</A> TtaSetTextContent</H4>

<P>Changes the content of a Text basic element. The full content (if any) is
deleted and replaced by the new one. This function can also be used for
changing the content (the file name) of a Picture basic element.</P>

<HR>

<P>void TtaSetTextContent(Element element, char *content, Language language,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>content</EM>: new content for that element.</P>

<P><EM>language</EM>: language of that Text element (see section <A
HREF="#secta13">13</A>).</P>

<P><EM>document</EM>: the document containing that element.</P>

</DL>

<H4><A NAME="sectc1012">10.1.2</A> TtaAppendTextContent</H4>

<P>Appends a character string at the end of a Text basic element.</P>

<HR>

<P>void TtaAppendTextContent(Element element, char *content, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>content</EM>: the character string to be appended.</P>

<P><EM>document</EM>: the document containing that element.</P>

</DL>

<H4><A NAME="sectc1013">10.1.3</A> TtaInsertTextContent</H4>

<P>Inserts a character string in a text basic element.</P>

<HR>

<P>void TtaInsertTextContent(Element element, int position, char *content,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>position</EM>: rank of the character after which the new string must be
inserted. 0 for inserting before the first character.</P>

<P><EM>content</EM>: the character string to be inserted.</P>

<P><EM>document</EM>: the document containing the text element.</P>

</DL>

<H4><A NAME="sectc1014">10.1.4</A> TtaDeleteTextContent</H4>

<P>Deletes a character string in a text basic element.</P>

<HR>

<P>void TtaDeleteTextContent(Element element, int position, int length,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>position</EM>: rank of the first character to be deleted.</P>

<P><EM>length</EM>: length of the character string to be deleted.</P>

<P><EM>document</EM>: the document containing the text element.</P>

</DL>

<H4><A NAME="sectc1015">10.1.5</A> TtaSplitText</H4>

<P>Divides a text element into two elements.</P>

<HR>

<P>void TtaSplitText(Element element, int position, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the text element to be divided. A new text element
containing the second part of the text is created as the next sibling.
<P><EM>position</EM>: rank of the character after which the element must be
cut.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1016">10.1.6</A> TtaMergeText</H4>

<P>Merges two text elements.</P>

<HR>

<P>void TtaMergeText(Element element, Document document)</P>

<HR>

<PRE>
void TtaMergeText(element, document)
Element element;
Document document;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the first text element. Merging occurs only if
<P>the next sibling is a text element with the same attributes.</P>

<P><EM>document</EM>: the document to which the text element belongs.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True if successful..
</DL>

<H4><A NAME="sectc1017">10.1.7</A> TtaSetGraphicsShape</H4>

<P>Changes the shape of a Graphics or Symbol basic element.</P>

<HR>

<P>void TtaSetGraphicsShape(Element element, char shape, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Graphics or Symbol.
<P><EM>shape</EM>: new shape for that element.</P>

<P><EM>document</EM>: the document containing that element.</P>

</DL>

<H4><A NAME="sectc1018">10.1.8</A> TtaAddPointInPolyline</H4>

<P>Adds a new point in a Polyline basic element.</P>

<HR>

<P>void TtaAddPointInPolyline(Element element, int rank, TypeUnit unit, int x,
int y, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the new point to be inserted. If rank is greater
than the actual number of points, the new point is appended. rank must be
strictly positive.</P>

<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

<P>x, y: coordinate of the new point, in units, relatively to the upper left
corner of the box. x and y must be positive or null.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc1019">10.1.9</A> TtaDeletePointInPolyline</H4>

<P>Deletes a point in a Polyline basic element.</P>

<HR>

<P>void TtaDeletePointInPolyline(Element element, int rank, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the point to be deleted. If rank is greater than the
actual number of points, the last point is deleted. rank must be strictly
positive.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc10110">10.1.10</A> TtaModifyPointInPolyline</H4>

<P>Changes the coordinates of a point in a Polyline basic element.</P>

<HR>

<P>void TtaModifyPointInPolyline(Element element, int rank, TypeUnit unit, int
x, int y, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the point to be modified. If rank is greater than
the actual number of points, the last point is changed. rank must be strictly
positive.</P>

<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

<P>x, y: new coordinates of the point, in units, relatively to the upper left
corner of the enclosing rectangle. x and y must be positive or null.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc10111">10.1.11</A> TtaChangeLimitOfPolyline</H4>

<P>Changes the coordinates of the lower left corner of the box containing a
Polyline basic element.</P>

<HR>

<P>void TtaChangeLimitOfPolyline(Element element, TypeUnit unit, int x, int y,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

<P>x, y: new coordinates of the lower left corner, in units, relatively to the
upper left corner of the box. x and y must be positive or null and the box
must contain all points of the polyline.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc10112">10.1.12</A> TtaCopyPage</H4>

<P>Copies the page element source into the page element destination. Both page
elements must be in an abstract tree.</P>

<HR>

<P>void TtaCopyPage(Element destination, Element source)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>destination</EM>: identifier of the page element to be modified.
<P><EM>source</EM>: identifier of the source page element.</P>

</DL>

<H3><A NAME="sectb102">10.2</A> Accessors</H3>

<H4><A NAME="sectc1021">10.2.1</A> TtaGetTextLength</H4>

<P>Returns the length of a Text basic element.</P>

<HR>

<P>int TtaGetTextLength(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Text.
</DL>

<DL>
<DT>Return value:</DT>

<DD>length (number of characters) of the character string contained in the
element. The null character terminating a C string is not counted.
</DL>

<H4><A NAME="sectc1022">10.2.2</A> TtaGiveTextContent</H4>

<P>Returns the content of a Text basic element.</P>

<HR>

<P>void TtaGiveTextContent(Element element, char *buffer, int *length,
Language *language)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Text.
<P><EM>buffer</EM>: the buffer that will contain the text.</P>

<P><EM>length</EM>: maximum length of that buffer.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>buffer</EM>: (the buffer contains the text, including the terminating
null character).
<P><EM>length</EM>: actual length of the text in the buffer, excluding the
null character terminating the string.</P>

<P><EM>language</EM>: language of the text (see section <A
HREF="#secta13">13</A>).</P>

</DL>

<H4><A NAME="sectc1023">10.2.3</A> TtaGiveSubString</H4>

<P>Returns a substring from a Text basic element.</P>

<HR>

<P>void TtaGiveSubString(Element element, char *buffer, int position, int
length)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Text.
<P><EM>buffer</EM>: the buffer that will contain the substring. This buffer
must be at least of size length.</P>

<P><EM>position</EM>: the rank of the first character of the substring. rank
must be strictly positive.</P>

<P><EM>length</EM>: the length of the substring. Must be strictly
positive.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: (the buffer contains the substring).
</DL>

<H4><A NAME="sectc1024">10.2.4</A> TtaGetGraphicsShape</H4>

<P>Returns the content of a Graphics or Symbol basic element.</P>

<HR>

<P>char TtaGetGraphicsShape(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Graphics or Symbol.
</DL>

<DL>
<DT>Return value:</DT>

<DD>a single character representing the shape of the graphics element or
symbol contained in the element.
</DL>

<H4><A NAME="sectc1025">10.2.5</A> TtaGetPolylineLength</H4>

<P>Returns the number of points in a Polyline basic element.</P>

<HR>

<P>int TtaGetPolylineLength(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the Polyline element. This element must be a basic
element of type Polyline.
</DL>

<H4><A NAME="sectc1026">10.2.6</A> TtaGivePolylinePoint</H4>

<P>Returns the coordinates of a point in a Polyline basic element.</P>

<HR>

<P>void TtaGivePolylinePoint(Element element, int rank, TypeUnit unit, int *x,
int *y)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Polyline element. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the point in the PolyLine. If rank is greater than
the actual number of points, an error is raised. rank must be strictly
positive.</P>

<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD>x, y: coordinates of the point, in units, relatively to the upper left
corner of the enclosing rectangle.
</DL>

<H4><A NAME="sectc1027">10.2.7</A> TtaGetPageNumber</H4>

<P>Returns the page number of a Page basic element.</P>

<HR>

<P>int TtaGetPageNumber(Element pageElement)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>pageElement</EM>: the page element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>page number of that page element.
</DL>

<H4><A NAME="sectc1028">10.2.8</A> TtaGetPageView</H4>

<P>Returns the view corresponding to a Page basic element.</P>

<HR>

<P>int TtaGetPageView(Element pageElement)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>pageElement</EM>: the page element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>view of that page.
</DL>

<H2><A NAME="secta11">11</A> <A NAME="L4874">Logical attributes</A></H2>

<P>The functions described in this section require that file
<EM>attribute.h</EM> be included in the module that calls them.</P>

<P>When creating or searching attributes in an abstract tree, the type of the
concerned attributes must be given. As presented in section <A
HREF="#secta4">4</A>, an attribute type contains an attribute number, but this
number does not appear explicitly in a structure schema: it is generated by
the schema compiler. For obtaining all attribute numbers of a structure
schema, use the command:
<EM>       printsch -h SchemaName
</EM>which lists on the standard output a file that can be included into a C
program.</P>

<P>When a new attribute is created (function TtaNewAttribute), it must be
attached (function TtaAttachAttribute) to an element which is itself part of
an abstract tree of a document, before any other action can be performed on
that attribute.</P>

<H3><A NAME="sectb111">11.1</A> Constructors</H3>

<H4><A NAME="sectc1111">11.1.1</A> TtaNewAttribute</H4>

<P>Creates an attribute that will be attached to an element.</P>

<HR>

<P>Attribute TtaNewAttribute(AttributeType attributeType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attributeType</EM>: type of the attribute to be created.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the attribute that has been created.
</DL>

<H4><A NAME="sectc1112">11.1.2</A> TtaAttachAttribute</H4>

<P>Attaches an attribute to an element.</P>

<HR>

<P>void TtaAttachAttribute(Element element, Attribute attribute, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to which the attribute has to be attached.
<P><EM>attribute</EM>: the attribute to be attached.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1113">11.1.3</A> TtaRemoveAttribute</H4>

<P>Removes an attribute from an element and release that attribute.</P>

<HR>

<P>void TtaRemoveAttribute(Element element, Attribute attribute, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element with which the attribute is associated.
<P><EM>attribute</EM>: the attribute to be removed.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H3><A NAME="sectb112">11.2</A> Modificators</H3>

<H4><A NAME="sectc1121">11.2.1</A> TtaSetAttributeValue</H4>

<P>Changes the value of an attribute of type integer or enumerate.</P>

<HR>

<P>void TtaSetAttributeValue(Attribute attribute, int value, Element element,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute to be modified.
<P><EM>value</EM>: new value of the attribute.</P>

<P><EM>element</EM>: the element with which the attribute is associated, NULL
if the attribute is not yet associated with an element.</P>

<P><EM>document</EM>: the document to which the element belongs. Must be 0 if
element is NULL.</P>

</DL>

<H4><A NAME="sectc1122">11.2.2</A> TtaSetAttributeText</H4>

<P>Changes the value of an attribute of type text.</P>

<HR>

<P>void TtaSetAttributeText(Attribute attribute, char *buffer, Element
element, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute to be modified.
<P><EM>buffer</EM>: character string representing the new value of the
attribute.</P>

<P><EM>element</EM>: the element with which the attribute is associated, NULL
if the attribute is not yet associated with an element.</P>

<P><EM>document</EM>: the document to which the element belongs. Must be 0 if
element is NULL.</P>

</DL>

<H3><A NAME="sectb113">11.3</A> Accessors</H3>

<H4><A NAME="sectc1131">11.3.1</A> TtaNextAttribute</H4>

<P>Returns the first attribute associated with a given element (if attribute
is NULL) or the attribute that follows a given attribute of a given
element.</P>

<HR>

<P>void TtaNextAttribute(Element element, Attribute *attribute)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>attribute</EM>: an attribute of that element, or NULL if the first
attribute is asked.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>attribute</EM>: the next attribute, or NULL if attribute is the last
attribute of the element.
</DL>

<H4><A NAME="sectc1132">11.3.2</A> TtaGetAttribute</H4>

<P>Returns an attribute of a given type associated with a given element.</P>

<HR>

<P>Attribute TtaGetAttribute(Element element, AttributeType 
attributeType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>attributeType</EM>: type of the desired attribute.. If the attribute
"Language" is searched, attributeType.AttrTypeNum must be 1. If the attribute
"Language" is searched whatever its structure schema,
attributeType.AttrSSchema must be NULL. A NULL attributeType.AttrSSchema is
accepted only when an attribute "Language" is searched.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the attribute found, or NULL if the element does not have this type of
attribute.
</DL>

<H4><A NAME="sectc1133">11.3.3</A> TtaGiveAttributeType</H4>

<P>Returns the type of a given attribute.</P>

<HR>

<P>void TtaGiveAttributeType(Attribute attribute, AttributeType 
attributeType, int *attrKind)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
<P><EM>attrKind</EM>: kind of the attribute: 0 = Enumerate, 1 = Integer, 2 =
Text, 3 = Reference</P>

</DL>

<H4><A NAME="sectc1134">11.3.4</A> TtaGiveAttributeTypeFromName</H4>

<P>Retrieves the type of an attribute from its name.</P>

<HR>

<P>void TtaGiveAttributeTypeFromName(char *name, Element element,
AttributeType  attributeType, int *attrKind)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: name of the attribute.
<P><EM>element</EM>: the element with which the attribute is associated.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
<P><EM>attrKind</EM>: kind of the attribute: 0 = Enumerate, 1 = Integer, 2 =
Text, 3 = Reference</P>

</DL>

<H4><A NAME="sectc1135">11.3.5</A> TtaGetAttributeName</H4>

<P>Returns the name of an attribute type.</P>

<HR>

<P>char *TtaGetAttributeName(AttributeType attributeType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that type.
</DL>

<H4><A NAME="sectc1136">11.3.6</A> TtaSameAttributeTypes</H4>

<P>Compares two attribute types.</P>

<HR>

<P>int TtaSameAttributeTypes(AttributeType type1, AttributeType type2)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>type1</EM>: first attribute type.
<P><EM>type2</EM>: second attribute type.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both types are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc1137">11.3.7</A> TtaGetAttributeValue</H4>

<P>Returns the value of a given attribute of type integer or enumerate.</P>

<HR>

<P>int TtaGetAttributeValue(Attribute attribute)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>Value of that attribute.
</DL>

<H4><A NAME="sectc1138">11.3.8</A> TtaGetTextAttributeLength</H4>

<P>Returns the length of a given attribute of type text.</P>

<HR>

<P>int TtaGetTextAttributeLength(Attribute attribute)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return values:</DT>

<DD>length of the character string contained in the attribute.
</DL>

<H4><A NAME="sectc1139">11.3.9</A> TtaGiveTextAttributeValue</H4>

<P>Returns the value of a given attribute of type text.</P>

<HR>

<P>void TtaGiveTextAttributeValue(Attribute attribute, char *buffer, int
*length)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
<P><EM>buffer</EM>: address of the buffer that will contain the value of the
attribute.</P>

<P><EM>length</EM>: size of the buffer (in bytes).</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD><EM>buffer</EM>: character string representing the value of the attribute.
<P><EM>length</EM>: actual length of the character string.</P>

</DL>

<H3><A NAME="sectb114">11.4</A> Locators</H3>

<H4><A NAME="sectc1141">11.4.1</A> TtaSearchAttribute</H4>

<P>Searches the next element that has a given attribute. Searching can be done
in a subtree or starting from a given element towards the beginning or the end
of the abstract tree.</P>

<HR>

<P>void TtaSearchAttribute(AttributeType searchedAttribute, SearchDomain
scope, Element element, Element *elementFound, Attribute *attributeFound)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedAttribute</EM>: attribute to be searched. If
searchedAttribute.AttrSSchema is NULL, the next element that has an attribute
is seached, whatever the attribute.
<P><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.</P>

<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>elementFound</EM>: the element found, or NULL if not found.
<P><EM>attributeFound</EM>: the searched attribute, or NULL if not found.</P>

</DL>

<H2><A NAME="secta12">12</A> <A NAME="L5513">References and links</A></H2>

<P>The functions described in this section require that file
<EM>reference.h</EM> be included in the module that calls them.</P>

<H3><A NAME="sectb121">12.1</A> Modificators</H3>

<H4><A NAME="sectc1211">12.1.1</A> TtaSetReference</H4>

<P>Changes (or sets) the target of a reference element. The reference element
must be part of an abstract tree.</P>

<HR>

<P>void TtaSetReference(Element element, Document document, Element target,
Document targetDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the reference element to be set.
<P><EM>document</EM>: the document containing the reference element.</P>

<P><EM>target</EM>: the target element (NULL for resetting the reference).</P>

<P><EM>targetDocument</EM>: the document containing the target element.</P>

</DL>

<H4><A NAME="sectc1212">12.1.2</A> TtaNewInclusion</H4>

<P>Creates an inclusion of a given element.</P>

<HR>

<P>Element TtaNewInclusion(Document document, Element target, Document
targetDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the inclusion is created.
<P><EM>target</EM>: the element to be included.</P>

<P><EM>targetDocument</EM>: the document containing the element to be
included.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the created inclusion.
</DL>

<H4><A NAME="sectc1213">12.1.3</A> TtaCopyReference</H4>

<P>Copies a reference element into another reference element. Both reference
elements must be in an abstract tree.</P>

<HR>

<P>void TtaCopyReference(Element element, Element source)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the reference element to be set.
<P><EM>source</EM>: the element to be copied.</P>

</DL>

<H4><A NAME="sectc1214">12.1.4</A> TtaSetAttributeReference</H4>

<P>Changes the value of an attribute of type reference</P>

<HR>

<P>void TtaSetAttributeReference(Attribute attribute, Element element,
Document document, Element target, Document targetDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute to be changed.
<P><EM>element</EM>: the element with which the attribute is associated.</P>

<P><EM>document</EM>: the document containing the attribute.</P>

<P><EM>target</EM>: the target element (NULL for resetting the reference).</P>

<P><EM>targetDocument</EM>: the document containing the target element.</P>

</DL>

<H4><A NAME="sectc1215">12.1.5</A> TtaCopyAttributeReference</H4>

<P>Copies the reference attribute source into the reference attribute
attribute. Both attributes must be attached to an element in an abstract
tree.</P>

<HR>

<P>void TtaCopyAttributeReference(Attribute attribute, Element element,
Attribute source)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the reference attribute to be set.
<P><EM>element</EM>: the element to which attribute is attached.</P>

<P><EM>source</EM>: the source attribute.</P>

</DL>

<H3><A NAME="sectb122">12.2</A> Accessors</H3>

<H4><A NAME="sectc1221">12.2.1</A> TtaGiveReferredElement</H4>

<P>Returns the element referred by a given reference element.</P>

<HR>

<P>void TtaGiveReferredElement(Element element, Element *target, char
*targetDocumentName, Document *targetDocument)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the reference element.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>target</EM>: the referred element, or NULL if that element is not
accessible (empty reference or referred document not open).
<P><EM>targetDocumentName</EM>: name of the document containing the referred
element; empty string if the referred element is in the same document as the
reference element.</P>

<P><EM>targetDocument</EM>: the document containing the referred element; 0 if
the document containing the referred element is not loaded or if the referred
element is in the same document as the reference element.</P>

</DL>

<H4><A NAME="sectc1222">12.2.2</A> TtaIsElementTypeReference</H4>

<P>Indicates whether an element type is a reference.</P>

<HR>

<P>int TtaIsElementTypeReference(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: type to be tested.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 = the type is a reference, 0 = the type is not a reference.
</DL>

<H4><A NAME="sectc1223">12.2.3</A> TtaSameReferences</H4>

<P>Compares two reference elements.</P>

<HR>

<P>int TtaSameReferences(Element element1, Element element2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element1</EM>: first reference element.
<P><EM>element2</EM>: second reference element.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both references are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc1224">12.2.4</A> TtaGiveReferenceAttributeValue</H4>

<P>Returns the value of a given attribute of type reference</P>

<HR>

<P>void TtaGiveReferenceAttributeValue(Attributeattribute, Element *target,
char *targetDocumentName, Document *targetDocument)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>target</EM>: the element referred by the attribute, or NULL if that
element is not accessible (empty reference or referred document not loaded)
<P><EM>targetDocumentName</EM>: name of the document containing the referred
element; empty string if the referred element is in the same document as the
attribute.</P>

<P><EM>targetDocument</EM>: the document containing the referred element; 0 if
the document containing the referred element is not loaded or if the referred
element is in the same document as the attribute.</P>

</DL>

<H4><A NAME="sectc1225">12.2.5</A> TtaIsElementReferred</H4>

<P>Tells whether a given element is the target of a reference or not.</P>

<HR>

<P>int TtaIsElementReferred(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the element is referred by another element or an attribute, 0 if not.
</DL>

<H4><A NAME="sectc1226">12.2.6</A> TtaSameReferenceAttributes</H4>

<P>Compares two reference attributes.</P>

<HR>

<P>int TtaSameReferenceAttributes(Attribute attribute1, Attribute
attribute2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute1</EM>: first reference attribute.
<P><EM>attribute2</EM>: second reference attribute.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both references are different, 1 if they are identical.
</DL>

<H3><A NAME="sectb123">12.3</A> Locators</H3>

<H4><A NAME="sectc1231">12.3.1</A> TtaNextLoadedReference</H4>

<P>Searches a reference that has a given element as a target and that belongs
to a document currently loaded.</P>

<HR>

<P>void TtaNextLoadedReference(Element target, Document targetDocument,
Element *referenceElement, Attribute *referenceAttribute, Document
*referenceDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>target</EM>: the target element.
<P><EM>targetDocument</EM>: the document to which the target element
belongs.</P>

<P><EM>referenceElement</EM>: previous element found by the function; NULL if
the first reference is searched. (Both referenceElement and referenceAttribute
must be NULL if the first reference is searched.)</P>

<P><EM>referenceAttribute</EM>: previous reference attribute found; NULL if
the first reference is searched or if the previous reference found by the
function was an element.</P>

<P><EM>referenceDocument</EM>: document to which the previous reference found
belongs; Zero if the first reference is searched.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>referenceAttribute</EM>: the reference attribute found. NULL if the
reference found is an element or if no reference is found.
<P><EM>referenceElement</EM>: the element found. If referenceAttribute is
NULL, this element is a reference element, else it is the element with which
the reference attribute found is associated. If both referenceAttribute and
referenceElement are NULL, then no reference has been found.</P>

<P><EM>referenceDocument</EM>: the document to which the reference found
belongs. Zero if no reference has been found.</P>

</DL>

<H4><A NAME="sectc1232">12.3.2</A> TtaNextUnloadedReferringDocument</H4>

<P>Returns the name of a document that is not currently loaded and that
contains references to a given target element.</P>

<HR>

<P>void TtaNextUnloadedReferringDocument(Element target, Document
targetDocument, char *referringDocumentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>target</EM>: the target element.
<P><EM>targetDocument</EM>: the document to which the target element
belongs.</P>

<P><EM>referringDocumentName</EM>: name of the previous document found. Empty
string if the first referring document is searched.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>referringDocumentName</EM>: name of the document found. Empty string
if no referring document has been found.
</DL>

<H4><A NAME="sectc1233">12.3.3</A> TtaSearchReferenceElement</H4>

<P>Searches the next reference element. Searching can be done in a subtree or
starting from a given element towards the beginning or the end of the abstract
tree.</P>

<HR>

<P>Element TtaSearchReferenceElement(SearchDomain scope, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.
<P><EM>element</EM>: the element that is the root of the subtree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if not found.
</DL>

<H2><A NAME="secta13">13</A> <A NAME="L6125">Languages</A></H2>

<P>Group language contains the functions for managing natural languages. These
functions require that file <EM>language.h</EM> be included in the module that
calls them.</P>

<P>Thot needs to know in which language each basic text element is written,
for instance for hyphenating words or for checking the spelling. Therefore, an
attribute called Language is defined by default in each structure schema and
it can be associated with any element (see section <A HREF="#secta11">11</A>).
A text element inherits the language specified by it first ancestor having a
Language attribute, unless it carries its own Language attribute.</P>

<P>The tool kit maintains a table of all languages used in the documents that
it handles. Each language has a name and an associated alphabet. Other
information may be associated to a language, such as a dictionary (for
hyphenation or spelling checking). A language is identified by an identifier
of type <EM>Language</EM>.</P>

<P>There are five predefined languages, whose names are : ISO_latin_1,
Fran&ccedil;ais, English, Symbol and Greek. ``Languages'' ISO_latin_1 and
Symbol are not natural languages in the same sense as Fran&ccedil;ais, English
or Greek. They are used when a character string must be written in the
corresponding alphabet, but is not candidate to such linguistic processing as
word hyphenation or spelling checking. For instance, a piece of C program
should be considered as written in the language ISO_latin_1; a mathematical
symbol such as &Iuml; or &yen; should be considered as written in the language
Symbol.</P>

<P>Other predefined languages, called <EM>typographic languages</EM>, are used
by a typographic checker (acronym, short, expo). The tool kit maintains a
table of all typographic languages used in the documents that it handles. Each
typographic language has a name and an associated alphabet. Other information
may be associated to a language, such as a dictionary (for typographic
checking). A typographic language is identified by an identifier of type
<EM>Language</EM>.</P>

<H3><A NAME="sectb131">13.1</A> Constructors</H3>

<H4><A NAME="sectc1311">13.1.1</A> TtaNewLanguage</H4>

<P>Declares a new language, its alphabet and optionally the names of the
principal and secondary dictionaries. All languages used in a Thot document
must be explicitly declared, except for predefined languages. Thot registers
all declared languages and allocates a different identifier to each of them.
his function does not load dictionaries but loads their name. If
<EM>principalDictionary</EM> and/or <EM>secondDictionary</EM> are not NULL
values, dictionaries are loaded when necessary from files
$DICOPAR/principalDictionary and or $DICOPAR/secondDictionary. If an
application redeclares an existing language, this new declaration has no
effect.</P>

<HR>

<P>Language TtaNewLanguage(char *languageName, char languageAlphabet, char
*principalDictionary, char *secondDictionary)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageName</EM>: name of the language.
<P><EM>languageAlphabet</EM>: alphabet to be used for writing that
language:</P>

<P>`L' for ISO-Latin-1, `G' for Symbol (Greek).</P>

<P><EM>principalDictionary</EM>: name of the principal dictionary or NULL.</P>

<P><EM>secondDictionary</EM>: name of the secondary dictionary or NULL.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>identifier of the new language or 0 if the language cannot be added.
</DL>

<H4><A NAME="sectc1312">13.1.2</A> TtaLoadLanguageDictionaries</H4>

<P>Loads the dictionary associated with a language, if it is not loaded yet
and registers that a dictionary associated with this language has been
loaded.</P>

<HR>

<P>boolean TtaLoadLanguageDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: name of the concerned language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>-1 if the mandatory dictionary can not be loaded.
<P>0 if no dictionary has been loaded.</P>

<P>1 if the mandatory dictionary is loaded.</P>

</DL>

<H4><A NAME="sectc1313">13.1.3</A> TtaUnLoadLanguageDictionaries</H4>

<P>Unloads dictionaries associated with a given language.</P>

<HR>

<P>void TtaUnLoadLanguageDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the language.
</DL>

<H4><A NAME="sectc1314">13.1.4</A> TtaLoadTypoDictionaries</H4>

<P>Loads the dictionary associated with a typographic language, if it is not
loaded yet and registers that a dictionary associated with this typographic
language has been loaded.</P>

<HR>

<P>boolean TtaLoadTypoDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the concerned typographic language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>-1 if the mandatory dictionary can not be loaded.
<P>0 if no dictionary has been loaded.</P>

<P>1 if the mandatory dictionary is loaded.</P>

</DL>

<H4><A NAME="sectc1315">13.1.5</A> TtaUnLoadTypoDictionaries</H4>

<P>Unloads dictionaries associated with a given typographic language.</P>

<HR>

<P>void TtaUnLoadTypoDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the concerned typographic language.
</DL>

<H3><A NAME="sectb132">13.2</A> Accessors</H3>

<H4><A NAME="sectc1321">13.2.1</A> TtaGetLanguageIdFromName</H4>

<P>Returns the identifier of a language that matches a language name. If this
language name is unknown, returns the identifier of a typographic language
that matches this language name..</P>

<HR>

<P>Language TtaGetLanguageIdFromName(char *languageName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageName</EM>: name of the language or of the typographic
language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>identifier of that language or of the typographic language or 0 if the
language is unknown.
</DL>

<H4><A NAME="sectc1322">13.2.2</A> TtaGetDefaultLanguage</H4>

<P>Returns the identifier of the default language.</P>

<HR>

<P>Language TtaGetDefaultLanguage()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>identifier of the default language.
</DL>

<H4><A NAME="sectc1323">13.2.3</A> TtaGetLanguageIdFromAlphabet</H4>

<P>Returns the identifier of the first language that uses a given
alphabet.</P>

<HR>

<P>Language TtaGetLanguageIdFromAlphabet(char *languageAlphabet)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageAlphabet</EM>: the alphabet of interest (`L' = latin, `G' =
greek).
</DL>

<DL>
<DT>Return value:</DT>

<DD>identifier of that language or 0 if the language is unknown.
</DL>

<H4><A NAME="sectc1324">13.2.4</A> TtaGetAlphabet</H4>

<P>Returns the alphabet associated with a given language.</P>

<HR>

<P>char TtaGetAlphabet(Language languageId)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageId</EM>: name of the language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>a character that identifies the alphabet (`L' = latin, `G' = greek).
</DL>

<H4><A NAME="sectc1325">13.2.5</A> TtaGetLanguageName</H4>

<P>Returns the name of a given language.</P>

<HR>

<P>char *TtaGetLanguageName(Language languageId)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageId</EM>: identifier of the language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the name of the language.
</DL>

<H4><A NAME="sectc1326">13.2.6</A> TtaGetPrincipalDictionary</H4>

<P>Returns a pointer to the principal dictionary associated to a language.</P>

<HR>

<P>Dictionary TtaGetPrincipalDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
language.
</DL>

<H4><A NAME="sectc1327">13.2.7</A> TtaGetSecondaryDictionary</H4>

<P>Returns a pointer to the secondary dictionary associated to a language.</P>

<HR>

<P>Dictionary TtaGetSecondaryDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
language.
</DL>

<H4><A NAME="sectc1328">13.2.8</A> TtaGetPrincipalTypoDictionary</H4>

<P>Returns a pointer to the principal dictionary associated to a typographic
language.</P>

<HR>

<P>Dictionary TtaGetPrincipalTypoDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
typographic language.
</DL>

<H4><A NAME="sectc1329">13.2.9</A> TtaGetSecondaryTypoDictionary</H4>

<P>Returns a pointer to the secondary dictionary associated to a typographic
language.</P>

<HR>

<P>Dictionary TtaGetSecondaryTypoDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
typographic language.
</DL>

<H4><A NAME="sectc13210">13.2.10</A> TtaGetNumberOfLanguages</H4>

<P>Returns the current number of languages known by Thot.</P>

<HR>

<P>int TtaGetNumberOfLanguages()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the current number of languages.
</DL>

<H2><A NAME="secta14">14</A> <A NAME="L6504">Specific presentation</A></H2>

<P>The functions described in this section require that file
<EM>presentation.h</EM> be included in the module that calls them.</P>

<P>When a new specific presentation rule is created (functions TtaNewPRule,
TtaNewPRuleForNamedView and TtaCopyPRule), it must be attached (function
TtaAttachPRule) to an element which is itself part of an abstract tree of a
document, before any other action can be performed on that specific
presentation rule.</P>

<H3><A NAME="sectb141">14.1</A> Constructors</H3>

<H4><A NAME="sectc1411">14.1.1</A> TtaNewPRule</H4>

<P>Creates a new presentation rule of a given type for a given view of a given
document.</P>

<HR>

<P>PRule TtaNewPRule(int presentationType, View view, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>presentationType</EM>: type of the presentation rule to be created.
Available values are PRSize, PRStyle, PRFont, PRUnderline, PRThickness,
PRIndent, PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle,
PRLineWeight, PRFillPattern, PRBackground, PRForeground, PRHyphenate.
<P><EM>view</EM>: the view (this view must be open).</P>

<P><EM>document</EM>: the document.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>new presentation rule.
</DL>

<H4><A NAME="sectc1412">14.1.2</A> TtaNewPRuleForNamedView</H4>

<P>Creates a new presentation rule of a given type for a given view of a given
document. The view is identified by its name.</P>

<HR>

<P>PRule TtaNewPRuleForNamedView(int presentationType, char *viewName,
Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>presentationType</EM>: type of the presentation rule to be created.
Available values are PRSize, PRStyle, PRFont, PRUnderline, PRThickness,
PRIndent, PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle,
PRLineWeight, PRFillPattern, PRBackground, PRForeground, PRHyphenate.
<P><EM>viewName</EM>: the name of the view (this view does not need to be
open).</P>

<P><EM>document</EM>: the document.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>new presentation rule.
</DL>

<H4><A NAME="sectc1413">14.1.3</A> TtaCopyPRule</H4>

<P>Creates a new presentation rule and initializes it with a copy of an
existing presentation rule.</P>

<HR>

<P>PRule TtaCopyPRule(PRule pRule)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>pRule</EM>: presentation rule to be copied.
</DL>

<DL>
<DT>Return value:</DT>

<DD>new presentation rule.
</DL>

<H4><A NAME="sectc1414">14.1.4</A> TtaAttachPRule</H4>

<P>Attaches a presentation rule to an element.</P>

<HR>

<P>void TtaAttachPRule(Element element, PRule pRule, Document document)</P>

<HR>

<PRE>
void TtaAttachPRule(element, pRule, document)
Element element;
PRule pRule;
Document document;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to which the presentation rule has to be
attached.
<P><EM>pRule</EM>: the presentation rule to be attached.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1415">14.1.5</A> TtaRemovePRule</H4>

<P>Removes a presentation rule from an element and release that rule.</P>

<HR>

<P>void TtaRemovePRule(Element element, PRule pRule, Document document</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element with which the presentation rule is
associated.
<P><EM>pRule</EM>: the presentation rule to be removed.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H3><A NAME="sectb142">14.2</A> Modificators</H3>

<H4><A NAME="sectc1421">14.2.1</A> TtaSetPRuleValue</H4>

<P>Changes the value of a presentation rule. The presentation rule must be
attached to an element that is part of a document.</P>

<HR>

<P>void TtaSetPRuleValue(Element element, PRule pRule, int value, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to which the presentation rule is attached.
<P><EM>pRule</EM>: the presentation rule to be changed.</P>

<P><EM>value</EM>: the value to be set.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<DL>
<DT>Valid values according to rule type:</DT>

<DD><EM>RSize</EM>: an integer between 6 and 72 (body size in points).
<P><EM>RStyle</EM>: StyleRoman, StyleBold, StyleItalics, StyleOblique,
StyleBoldItalics, StyleBoldOblique.</P>

<P><EM>RFont</EM>: FontTimes, FontHelvetica, FontCourier.</P>

<P><EM>RUnderline</EM>: NoUnderline, Underline, Overline, CrossOut.</P>

<P><EM>RThickness</EM>: ThinUnderline, ThickUnderline.</P>

<P><EM>RIndent</EM>: a positive, null or negative integer (indentation in
points).</P>

<P><EM>RLineSpacing</EM>: a positive integer (line spacing in points).</P>

<P><EM>RDepth</EM>: a positive integer (depth of the element).</P>

<P><EM>RAdjust</EM>: AdjustLeft, AdjustRight, Centered, LeftWithDots.</P>

<P><EM>RJustify</EM>: Justified, NotJustified.</P>

<P><EM>RHyphenate</EM>: Hyphenation, NoHyphenation.</P>

<P><EM>RLineStyle</EM>: SolidLine, DashedLine, DottedLine.</P>

<P><EM>RLineWeight</EM>: a positive or null integer (stroke width for
graphics).</P>

<P><EM>RFillPattern</EM>: rank of the pattern in the file thot.pattern.</P>

<P><EM>RBackground</EM>: rank of the background color in the file
thot.color.</P>

<P><EM>RForeground</EM>: rank of the foreground color in the file
thot.color.</P>

</DL>

<H4><A NAME="sectc1422">14.2.2</A> TtaChangeBoxSize</H4>

<P>Changes the height and width of the box corresponding to an element in a
given view.</P>

<HR>

<P>void TtaChangeBoxSize(Element element, Document document, View view, int
deltaX, int deltaY, TypeUnit unit)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>deltaX</EM>: width increment in units (positive, negative or zero).</P>

<P><EM>deltaY</EM>: height increment in units (positive, negative or
zero).</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<H4><A NAME="sectc1423">14.2.3</A> TtaChangeBoxPosition</H4>

<P>Moves the box of an element in a given view.</P>

<HR>

<P>void TtaChangeBoxPosition(Element element, Document document, View view,
int deltaX, int deltaY, TypeUnit unit)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>deltaX</EM>: horizontal shift in units (positive, negative or
zero).</P>

<P><EM>deltaY</EM>: vertical shift in units (positive, negative or zero).</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<H3><A NAME="sectb143">14.3</A> Accessors</H3>

<H4><A NAME="sectc1431">14.3.1</A> TtaGiveBoxSize</H4>

<P>Returns the height and width of the box corresponding to an element in a
given view.</P>

<HR>

<P>void TtaGiveBoxSize(Element element, Document document, View view, TypeUnit
unit, int *width, int *height)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>width</EM>: box width in units.
<P><EM>height</EM>: box height in units.</P>

</DL>

<H4><A NAME="sectc1432">14.3.2</A> TtaGiveBoxPosition</H4>

<P>Returns the x and y coordinates of the box corresponding to an element in a
given view. The returned coordinates indicate the distance in points between
the upper left corner of the box and the upper left corner of its parent
box.</P>

<HR>

<P>void TtaGiveBoxPosition(Element element, Document document, View view,
TypeUnit unit, int *xCoord, int *yCoord)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>xCoord</EM>: distance from the left edge of the parent box to the left
edge of the box, in units.
<P><EM>yCoord</EM>: distance from the top edge of the parent box to the top
edge of the box, in units.</P>

</DL>

<H4><A NAME="sectc1433">14.3.3</A> TtaNextPRule</H4>

<P>Returns the first presentation rule associated with a given element (if
pRule is NULL) or the presentation rule that follows a given rule of a given
element.</P>

<HR>

<P>void TtaNextPRule(Element element, PRule *pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>pRule</EM>: a presentation rule of that element, or NULL if the first
rule is asked.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>pRule</EM>: the next presentation rule, or NULL if pRule is the last
rule of the element.
</DL>

<H4><A NAME="sectc1434">14.3.4</A> TtaGetPRule</H4>

<P>Returns a presentation rule of a given type associated with a given
element.</P>

<HR>

<P>PRule TtaGetPRule(Element element, int presentationType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>presentationType</EM>: type of the desired presentation rule. Available
values are PRSize, PRStyle, PRFont, PRUnderline, PRThickness, PRIndent,
PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle, PRLineWeight,
PRFillPattern, PRBackground, PRForeground, PRHyphenate.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the presentation rule found, or NULL if the element does not have this
type of presentation rule.
</DL>

<H4><A NAME="sectc1435">14.3.5</A> TtaGetPRuleType</H4>

<P>Returns the type of a presentation rule.</P>

<HR>

<P>int TtaGetPRuleType(PRule pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>type of that presentation rule. Available values are PRSize, PRStyle,
PRFont, PRUnderline, PRThickness, PRIndent, PRLineSpacing, PRDepth, PRAdjust,
PRJustify, PRLineStyle, PRLineWeight, PRFillPattern, PRBackground,
PRForeground, PRHyphenate.
</DL>

<H4><A NAME="sectc1436">14.3.6</A> TtaGetPRuleValue</H4>

<P>Returns the value of a presentation rule.</P>

<HR>

<P>int TtaGetPRuleValue(PRule pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule of interest.
</DL>

<DL>
<DT>Return values according to rule type:</DT>

<DD><EM>RSize</EM>: an integer between 6 and 72 (body size in points).
<P><EM>RStyle</EM>: StyleRoman, StyleBold, StyleItalics, StyleOblique,
StyleBoldItalics, StyleBoldOblique.</P>

<P><EM>RFont</EM>: FontTimes, FontHelvetica, FontCourier.</P>

<P><EM>RUnderline</EM>: NoUnderline, Underline, Overline, CrossOut.</P>

<P><EM>RThickness</EM>: ThinUnderline, ThickUnderline.</P>

<P><EM>RIndent</EM>: a positive, null or negative integer (indentation in
points).</P>

<P><EM>RLineSpacing</EM>: a positive integer (line spacing in points).</P>

<P><EM>RDepth</EM>: a positive integer (depth of the element).</P>

<P><EM>RAdjust</EM>: AdjustLeft, AdjustRight, Centered, LeftWithDots.</P>

<P><EM>RJustify</EM>: Justified, NotJustified.</P>

<P><EM>RHyphenate</EM>: Hyphenation, NoHyphenation.</P>

<P><EM>RLineStyle</EM>: SolidLine, DashedLine, DottedLine.</P>

<P><EM>RLineWeight</EM>: a positive or null integer (stroke width for
graphics).</P>

<P><EM>RFillPattern</EM>: rank of the pattern in the file thot.pattern.</P>

<P><EM>RBackground</EM>: rank of the background color in the file
thot.color.</P>

<P><EM>RForeground</EM>: rank of the foreground color in the file
thot.color.</P>

</DL>

<H4><A NAME="sectc1437">14.3.7</A> TtaSamePRules</H4>

<P>Compares two presentation rules associated with the same element or with
different elements.</P>

<HR>

<P>int TtaSamePRules(PRule pRule1, PRule pRule2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule1</EM>: first presentation rule to be compared.
<P><EM>pRule2</EM>: second presentation rule to be compared.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both rules are different, 1 if they are identical.
</DL>

<H2><A NAME="secta15">15</A> <A NAME="L7272">Views</A></H2>

<P>The functions described in this section require that file <EM>view.h</EM>
be included in the module that calls them. They are available only in the Thot
Editor library.</P>

<H3><A NAME="sectb151">15.1</A> Constructors</H3>

<H4><A NAME="sectc1511">15.1.1</A> TtaOpenMainView</H4>

<P>Opens the main view of a document. This document must have a PSchema (see
TtaSetPSchema).</P>

<HR>

<P>View TtaOpenMainView(Document document, int x, int y, int w, int h)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which a window must be open.
<P><EM>x, y</EM>: coordinate (in millimeters) of the upper left corner of the
window that will display the view.</P>

<P><EM>w, h</EM>: width and height (in millimeters) of the upper left corner
of the window that will display the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view opened or 0 if the view cannot be opened.
</DL>

<H4><A NAME="sectc1512">15.1.2</A> TtaOpenView</H4>

<P>Opens a view for a document. This document must have a PSchema (see
TtaSetPSchema).</P>

<HR>

<P>View TtaOpenView(Document document, char *viewName, int x, int y, int w,
int h)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>viewName</EM>: name of the view to be opened.</P>

<P><EM>x, y</EM>: coordinate (in millimeters) of the upper left corner of the
window that will display the view.</P>

<P><EM>w, h</EM>: width and height (in millimeters) of the upper left corner
of the window that will display the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view opened or 0 if the view cannot be opened.
</DL>

<H4><A NAME="sectc1513">15.1.3</A> TtaOpenSubView</H4>

<P>Opens a view that shows only a subtree. This document must have a PSchema
(see TtaSetPSchema).</P>

<HR>

<P>View TtaOpenSubView(Document document, char *viewName, int x, int y, int w,
int h, Element subtree)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>viewName</EM>: name of the view to be opened.</P>

<P>x, y: coordinate (in millimeters) of the upper left corner of the</P>

<P>window that will display the view.</P>

<P>w, h: width and height (in millimeters) of the upper left corner of the</P>

<P>window that will display the view.</P>

<P><EM>subtree</EM>: root element of the subtree to be shown in the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view opened or 0 if the view cannot be opened.
</DL>

<H4><A NAME="sectc1514">15.1.4</A> TtaChangeViewTitle</H4>

<P>Changes the title of a view.</P>

<HR>

<P>void TtaChangeViewTitle(Document document, View view, char *title)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>view</EM>: the view .</P>

<P>title: the new title.</P>

</DL>

<H4><A NAME="sectc1515">15.1.5</A> TtaCloseView</H4>

<P>Closes a view.</P>

<HR>

<P>void TtaCloseView(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which a view must be closed.
<P><EM>view</EM>: the view to be closed.</P>

</DL>

<H3><A NAME="sectb152">15.2</A> Modificators</H3>

<H4><A NAME="sectc1521">15.2.1</A> TtaSetSensibility</H4>

<P>Changes the current sensibility used to display a given view of a given
document.</P>

<HR>

<P>void TtaSetSensibility(Document document, View view, int value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

<P><EM>value</EM>: new value of the sensibility.</P>

</DL>

<H4><A NAME="sectc1522">15.2.2</A> TtaSetZoom</H4>

<P>Changes the current zoom used to display a given view of a given
document.</P>

<HR>

<P>void TtaSetZoom(Document document, View view, int value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

<P><EM>value</EM>: new value of the zoom.</P>

</DL>

<H4><A NAME="sectc1523">15.2.3</A> TtaShowElement</H4>

<P>Shows a given element in a given view of a given document.</P>

<HR>

<P>void TtaShowElement(Document document, View view, Element element, int
position)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the element to be shown belongs.
Cannot be 0.
<P><EM>view</EM>: the view where the element must be shown.</P>

<P><EM>element</EM>: the element to be shown.</P>

<P><EM>position</EM>: position of the top of the element in the window.
Supposing that the y axis is oriented from the top of the window (coordinate
0) to the bottom (coordinate 100, whatever the actual height of the window),
position is the desired y coordinate of the top of the element.</P>

</DL>

<H4><A NAME="sectc1524">15.2.4</A> TtaRaiseView</H4>

<P>Maps and raises a given view of a given document.</P>

<HR>

<P>void TtaRaiseView(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the element to be shown belongs.
Cannot be 0.
<P><EM>view</EM>: the view where the element must be shown.</P>

</DL>

<H4><A NAME="sectc1525">15.2.5</A> TtaSetDisplayMode</H4>

<P>Changes display mode for a document. Three display modes are available
(DisplayImmediately, DeferredDisplay and NoComputedDisplay). In the immediate
mode, each modification made in the abstract tree of a document is immediately
reflected in all opened views where the modification can be seen. In the
deferred mode, the programmer can decide when the modifications are made
visible to the user; this avoids the image of the document to blink when
several elementary changes are made successively. Modifications are displayed
when mode is changed to DisplayImmediately. In the NoComputedDisplay mode, the
modifications are not displayed and not computed by the editor; the execution
is more rapid but the current image is lost. When mode is changed to
DisplayImmediately or DeferredDisplay, the image is completely redrawn by the
editor. An application that handles several documents at the same time can
choose different modes for different documents. When a document is open or
created, it is initially in the immediate mode.</P>

<HR>

<P>void TtaSetDisplayMode(Document document, DisplayMode newDisplayMode)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>NewDisplayMode</EM>: new display mode for that document.</P>

</DL>

<H3><A NAME="sectb153">15.3</A> Accessors</H3>

<H4><A NAME="sectc1531">15.3.1</A> TtaGetSensibility</H4>

<P>Reads the current sensibility used to display a given view of a given
document.</P>

<HR>

<P>int TtaGetSensibility(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>current value of the sensibility.
</DL>

<H4><A NAME="sectc1532">15.3.2</A> TtaGetZoom</H4>

<P>Reads the current zoom used to display a given view of a given
document.</P>

<HR>

<P>int TtaGetZoom(Document document, View view)</P>

<HR>

<PRE>
int TtaGetZoom(document, view)
Document document;
View view;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>current value of the zoom.
</DL>

<H4><A NAME="sectc1533">15.3.3</A> TtaGetDisplayMode</H4>

<P>Returns the current display mode for a document.</P>

<HR>

<P>DisplayMode TtaGetDisplayMode(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>current display mode for that document.
</DL>

<H4><A NAME="sectc1534">15.3.4</A> TtaIsPSchemaValid</H4>

<P>Checks if a presentation schema can be applied to a document of a given
class. No document is needed and the schemas are not loaded by this
function.</P>

<HR>

<P>int TtaIsPSchemaValid(char *structureName, char *presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>structureName</EM>: Name of the document class.
<P><EM>presentationName</EM>: Name of the presentation schema to be
checked.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the presentation schema can be applied, 0 if it can not.
</DL>

<H4><A NAME="sectc1535">15.3.5</A> TtaGiveViewsToOpen</H4>

<P>Returns the names of the views that can be opened for a document.</P>

<HR>

<P>void TtaGiveViewsToOpen(Document document, char *buffer, int nbViews)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>buffer</EM>: a buffer that will contain the result.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>buffer</EM>: list of view names. Each name is a character string with
a final '\0'. Names of views that are already open have a '*' at the end.
<P><EM>nbViews</EM>: number of names in the list, 0 if not any view can be
open.</P>

</DL>

<H4><A NAME="sectc1536">15.3.6</A> TtaGetViewName</H4>

<P>Returns the name of an open view.</P>

<HR>

<P>char *TtaGetViewName(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the view belongs.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>Name of the view. The buffer must be provided by the caller.
</DL>

<H4><A NAME="sectc1537">15.3.7</A> TtaGetViewFromName</H4>

<P>Returns the identifier of a view of a given document from its name.</P>

<HR>

<P>View TtaGetViewFromName(Document document, char *viewName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the view belongs.
<P><EM>viewName</EM>: the name of the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view. 0 if no view of that name is currently open for the document.
</DL>

<H4><A NAME="sectc1538">15.3.8</A> TtaGiveActiveView</H4>

<P>Returns the active view and the document to which that view belongs. The
active view is the one that receives the characters typed by the user.</P>

<HR>

<P>void TtaGiveActiveView(Document *document, View *view)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>No parameter.
</DL>

<DL>
<DT>Return values:</DT>

<DD><EM>document</EM>: the active document.
<P><EM>view</EM>: the active view.</P>

</DL>

<H4><A NAME="sectc1539">15.3.9</A> TtaIsViewOpened</H4>

<P>Indicates whether a view is opened.</P>

<HR>

<P>boolean TtaIsViewOpened(Document document, View view)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD> True if the view is already opened.
</DL>

<H3><A NAME="sectb154">15.4</A> Help</H3>

<H4><A NAME="sectc1541">15.4.1</A> TtaListView</H4>

<P>Produces in a file a human-readable form of the current picture of the
document view.</P>

<HR>

<P>void TtaListView(Document document, View view, FILE *fileDescriptor)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to be listed.
<P><EM>view</EM>: the view to be listed.</P>

<P><EM>fileDescriptor</EM>: file descriptor of the file that will contain the
list. This file must be open when calling the function.</P>

</DL>

<H2><A NAME="secta16">16</A> <A NAME="L7975">Selection</A></H2>

<P>The functions described in this section require that file
<EM>selection.h</EM> be included in the module that calls them. They are
available only in the Thot Editor library.</P>

<P>These functions allow an application program to change the selection set by
the user of the Thot Editor. The selection is the part of a document that will
be concerned by the next editing command issued by the end user. Tool kit
functions that modify a document are independent from the selection in the
sense that they can change any part of a document independently of the current
selection; but, when necessary, they can also have access to the current user
selection, by using the following functions.</P>

<H3><A NAME="sectb161">16.1</A> Constructors</H3>

<H4><A NAME="sectc1611">16.1.1</A> TtaSelectElement</H4>

<P>Selects a single element. This element is highlighted in all views where it
can be displayed. If it cannot be displayed in any existing view, a new view
is eventually open for displaying it.</P>

<HR>

<P>void TtaSelectElement(Document document, Element selectedElement)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document containing the element to be selected.
<P><EM>selectedElement</EM>: the element to be selected. NULL for cancelling
the selection in the document.</P>

</DL>

<H4><A NAME="sectc1612">16.1.2</A> TtaSelectString</H4>

<P>Selects a substring within a Text basic element. This substring is
highlighted in all views where it can be displayed.</P>

<HR>

<P>void TtaSelectString(Document document, Element textElement, int
firstCharacter, int lastCharacter)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document containing the string to be selected.
<P><EM>textElement</EM>: the Text element containing the string to be
selected.</P>

<P><EM>firstCharacter</EM>: position within the texte element of the first
character to be selected.</P>

<P><EM>lastCharacter</EM>: position within the texte element of the last
character to be selected.</P>

</DL>

<H4><A NAME="sectc1613">16.1.3</A> TtaExtendSelection</H4>

<P>Extends the current selection to a given element.</P>

<HR>

<P>void TtaExtendSelection(Document document, Element element, int
lastCharacter)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the selection must be extended.
<P><EM>element</EM>: the element to which the selection must be extended.</P>

<P><EM>lastCharacter</EM>: position within this element of the last character
to be selected. 0 if the whole element must be selected.</P>

</DL>

<H4><A NAME="sectc1614">16.1.4</A> TtaSelectInterval</H4>

<P>If a pair of paired elements is selected, select also all elements between
the two paired elements. Nothing is done if the current selection is not a
pair.</P>

<HR>

<P>void TtaSelectInterval()</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>No parameter
</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H4><A NAME="sectc1615">16.1.5</A> TtaUnselect</H4>

<P>Turns the selection off for a document.</P>

<HR>

<P>void TtaUnselect(Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the selection must be turned off
</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H4><A NAME="sectc1616">16.1.6</A> TtaSetSelectionMode</H4>

<P>Change selection mode. If withMenu = False functions TtaSelectElement,
TtaSelectString, TtaExtendSelection and TtaUnselect do not update the menus
that depend on the selection and do not display the selection message. Default
mode is withMenu = True.</P>

<HR>

<P>void TtaSetSelectionMode(boolean withMenu)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>withMenu</EM>: the new selection mode.
</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H3><A NAME="sectb162">16.2</A> Accessors</H3>

<H4><A NAME="sectc1621">16.2.1</A> TtaIs DocumentSelected</H4>

<P>Indicates whether a view is selected.</P>

<HR>

<P>boolean TtaIsDocumentSelected(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return values:</DT>

<DD>True if the current selection concerns this document.
</DL>

<H4><A NAME="sectc1622">16.2.2</A> TtaGiveFirstSelectedElement</H4>

<P>Returns the first element in the current selection in a given document. If
this element is a Text element and if only a substring is selected, return
also the rank of the first and last characters in the selection.</P>

<HR>

<P>void TtaGiveFirstSelectedElement(Document document, Element
*selectedElement, int *firstCharacter, int *lastCharacter)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the selection is asked.
</DL>

<DL>
<DT>Return values:</DT>

<DD><EM>selectedElement</EM>: the first selected element, NULL if no element
is selected in the document.
<P><EM>firstCharacter</EM>: rank of the first character in the selection, or 0
if the whole element is in the selection.</P>

<P><EM>lastCharacter</EM>: rank of the last character in the selection, or 0
if the</P>

<P>whole element is in the selection.</P>

</DL>

<H4><A NAME="sectc1623">16.2.3</A> TtaGiveNextSelectedElement</H4>

<P>Returns the element that follows a given element in the current selection
in a given document. If this element is a Text element and if only a substring
is selected, return also the rank of the first and last characters in the
selection.</P>

<HR>

<P>void TtaGiveNextSelectedElement(Document document, Element
*selectedElement, int *firstCharacter, int *lastCharacter)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the selection is asked.
<P><EM>selectedElement</EM>: the current element.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>selectedElement</EM>: the next selected element, NULL if this was the
last selected element in the document.
<P><EM>firstCharacter</EM>: rank of the first character in the selection, or 0
if the whole element is in the selection.</P>

<P><EM>lastCharacter</EM>: rank of the last character in the selection, or 0
if the</P>

<P>whole element is in the selection.</P>

</DL>

<H2><A NAME="secta17">17</A> <A NAME="L8857">Messages</A></H2>

<P>The functions described in this section require that file
<EM>message.h</EM> be included in the modules that call them.</P>

<P>The following functions are available in both the Thot Editor library and
the ThotKernel library. They allow an application program to manage messages
and dialogue text, as Thot tool kits do. Text of dialogue boxes and error
messages is defined out of the application code and is dynamically loaded when
the application is executed. This method allows application to adapt its
interface to the current user (English text for English user, French text for
French user, etc.). Each message is numbered, code referencing the message by
its number and an external file associating this number with its corresponding
text. An environment variable is used to reach the correct file that contains
text of messages at the execution time. If this file is not reachable, a
warning message is sent to the standard output, but the execution is not
automatically stopped. Nevertheless, the Thot Editor library stops execution
when its text file is not reachable because it cannot work without.</P>

<P>We give an example of an application that needs four messages. The
applicationMSG.h file is used to address correct message in source code and
the en-applicationTXT gives the English version of messages text:</P>

<TABLE BORDER=0>
  <TR>

<TD>

<P>#define APP_start              0</P>

<P>#define APP_abort             1</P>

<P>#define APP_no_file          2 </P>

<P>#define APP_complete      3</P>

<P>#define APP_MSG_MAX 4</P>

<P>applicationMSG.h</P>

<TD>

<P>0   Application</P>

<P>1   Application aborted</P>

<P>2   Unreachable file %s</P>

<P>3   End of application</P>

<P> </P>

<P>en-applicationTXT</P>

  </TR>
</TABLE>

<P> </P>

<P>The application has to load the rigth message table:</P>

<PRE>
errorTable = TtaGetMessageTable("applicationTXT", APP_MSG_MAX);
</PRE>

<P>and displays the third error message using one of available display
function (for example the TtaDisplayMessage function and TtaGetMessage):</P>

<PRE>
TtaDisplayMessage(FATAL, TtaGetMessage(errorTable, APP_no_file), filename);
</PRE>

<H3><A NAME="sectb171">17.1</A> Constructors</H3>

<H4><A NAME="sectc1711">17.1.1</A> TtaGetMessageTable</H4>

<P>Loads text of application messages in a dynamically allocated table and
returns the identifcation of this messages table. The <TT>msgFile</TT> is the
generic name of the message file to be loaded. The <TT>msgNumber</TT>
parameter denotes the number of messages to be read in the file.The full name
of the loaded file is  <TT>$THOTDIR/config/$LANG-msgFile</TT>, where
<TT>$THOTDIR</TT> represents the root path of Thot hierarchy and
<TT>$LANG</TT> represents the current language (for example <TT>en</TT>).
<TT>$THOTDIR</TT> is computed by the Thot toolkit and <TT>$LANG</TT> can be
set in the user registry <TT>thot.ini</TT>.</P>

<HR>

<P>int TtaGetMessageTable(char *msgFile, int msgNumber)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>msgFile</EM>: the generic name of the message file.
<P>msgNumber: the number of messages.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The messages table identifier or -1 if the table is not allocated and
loaded.
</DL>

<H3><A NAME="sectb172">17.2</A> Accessors</H3>

<H4><A NAME="sectc1721">17.2.1</A> TtaGetMessage</H4>

<P>Returns the text of the corresponding message.</P>

<HR>

<P>char *TtaGetMessage(int msgTableID, int msgIndex)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>msgTableID</EM>: identifier of the messages table.
<P><EM>msgIndex</EM>: index of the message.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>Text of the message (an empty text if the table or the message is not
found).
</DL>

<H4><A NAME="sectc1722">17.2.2</A> TtaDisplaySimpleMessage</H4>

<P>Displays the text of a simple message. This message is often displayed in
the message area of the main application window  if it exists  or directed
to the standard output for batch applications.</P>

<P>The msgType parameter defines the importance of the message:</P>

<UL>
<LI>INFO: the message is displayed in the message area of the main application
window just as an information.
<LI>OVERHEAD: the message replaces the previous message in the message area of
the main application window.
<LI>FATAL: the message stops the application with an  error code.
<LI>CONFIRM: the message pops a message box to display the message within and
waits for until the end user confirms the message has been read.
</UL>

<HR>

<P>void TtaDisplaySimpleMessage(int msgType, int msgTableID, int msgIndex)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>msgType</EM>: the message type (INFO,  OVERHEAD, FATAL, CONFIRM).</P>

<P><EM>msgTableID</EM>: identifier of the messages table (LIB for the standard
Thot messages).</P>

<P><EM>msgIndex</EM>: index of the message.</P>

</DL>

<H4><A NAME="sectc1723">17.2.3</A> TtaDisplayMessage</H4>

<P>Displays a message mixing static text (the text of the message) with a
variable number of parameters. The static text plays the role of a format
(like the prinf format) and may include necessary format commandes for each
parameter: a %s for a string, a %d for an integer. Number and type of variable
parameters depend on format commands included in the message text.</P>

<P>.</P>

<HR>

<P>void TtaDisplayMessage(int msgType, msgTableID, int msgIndex, ...)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>msgType</EM>: the message type (INFO,  OVERHEAD, FATAL, CONFIRM).</P>

<P><EM>msgTableID</EM>: identifier of the messages table (LIB for the standard
Thot messages).</P>

<P><EM>msgIndex</EM>: index of the message.</P>

<P><EM>...</EM>: variable parameters.</P>

</DL>

<H2><A NAME="secta18">18</A> <A NAME="L9217">Dialogue</A></H2>

<P>The Thot editing tool kit provides dialogue functions. There are high level
functions that hide most of the complex aspects of OSF/Motif and thus allows
an application to use OSF/Motif very easily and dynamically (all dialogue
entities such as menus, buttons, forms, etc. can be created and modified at
any time). As these dialogue functions are already used internally by the
editing tool kit, another reason for an application to use it, is to present
the user with a homogeneous and consistent look and feel for the whole
application.</P>

<P>The functions described in this section require that file
<EM>dialogue.h</EM> be included in the module that calls them. They are
available only in the Thot Editor library.</P>

<H3><A NAME="sectb181">18.1</A> Constructors</H3>

<H4><A NAME="sectc1811">18.1.1</A> TtaListDirectory</H4>

<P>Creates one or two selectors that allow end-user to select a directory
and/or a file included within the current specified directory. This function
supposes that the application had first created a form where selectors have to
be inserted. The application is able to create either only the directory
selector or only the file selector. A suffix can be specified if the
application wants to filter a specific class of files. It is the
responsibility of the application to receive and handle the selectors
callback.</P>

<HR>

<P>void TtaListDirectory(char *aDirectory, int formRef, char *dirTitle, int
dirRef, char *suffix, char *fileTitle, int fileRef)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>aDirectory</EM>: the current designated directory.
<P><EM>formRef</EM>: the form identification.</P>

<P><EM>dirTitle</EM>: the title of the directory selector.</P>

<P><EM>dirRef</EM>: the directory selector identification or -1 if this
selector is not desired.</P>

<P><EM>suffix</EM>: the suffix used for filtering files (for example
".PIV")</P>

<P><EM>fileTitle</EM>: the title of the file selector.</P>

<P><EM>fileRef</EM>: the file selector identification or -1 if this selector
is not desired.</P>

</DL>

<H4><A NAME="sectc1812">18.1.2</A> TtaIsSuffixFileIn</H4>

<P>Returns True if the specified directory contains files with the specified
suffix.</P>

<HR>

<P>boolean TtaIsSuffixFileIn(char *aDirectory, char *suffix)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>aDirectory</EM>: the current designated directory.
<P><EM>suffix</EM>: the suffix used for filtering files (for example
".PIV")</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True or False.
</DL>

</BODY>
</HTML>
