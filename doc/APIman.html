<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN//2.0">
<HTML>
<HEAD>
<!-- Document generated by Thot -->
<TITLE>APIman-E</TITLE>
<LINK HREF="APIman.toc.html" REL="ToC">
<LINK HREF="APIman.idx1.html" REL="Index">
</HEAD>
<BODY>
<PRE>
<EM>ThotLib V3</EM></PRE>
<PRE>
Date: 11 October, 1999</PRE>

<H1>The Thot Tool Kit API</H1>
<ADDRESS>Vincent QUINT, Ir&egrave;ne VATTON - W3C/INRIA</ADDRESS>

<HR>

<P>The Thot tool kit is a comprehensive set of editing functions that can be
used for building applications that handle structured documents in the Unix /
X Window environment. It is constituted by a set of C libraries that can be
linked to any program. It allows application programs to perform the same kind
of operations as a user working with a structured document editor. Typically,
an application can use the tool kit for creating new documents, for modifying
existing documents, for extracting information from documents, for displaying
(parts of) documents, etc. The tool kit can be used either for automatic
manipulations performed solely by a program or for allowing a human user to
cooperate with a program that processes documents. In this latter case, it
uses OSF/Motif for implementing the user interface.</P>

<P>The functions provided by the tool are based on the Thot document model.
Documents produced with the tool kit can be stored as Unix files in the same
standard format as documents produced by the Thot editor (pivot format
indicated by the .PIV suffix). Thot editor is also able to save documents in
other formats and obviously this capability is provided by the tool kit. Thot
documents can be processed by all tools available in the Thot environment and
by all applications developed with the tool kit. The Thot environment includes
in particular flexible tools for editing, printing and translating
documents.</P>

<H2><A NAME="secta1">1</A> Introduction to the document model</H2>

<H3><A NAME="sectb11">1.1</A> Logical structure</H3>

<P>In the editing tool kit, a <EM>document</EM> is primarily considered as an
abstract structure that assembles typed <EM>elements</EM>. Examples of
elements types are titles, chapters, sections, paragraphs, lists, notes, etc.
The structure itself is basically a hierarchy of such elements; it is called
an <EM>abstract tree</EM>. The lowest level elements (also called <EM>basic
elements</EM>) represent the actual <EM>contents</EM> of the document:
character stings, mathematical symbols, pictures, and graphical elements. In
addition to this tree structure, non-hierarchical links (also called
<EM>references</EM>) relate elements independently of the tree structure, thus
representing cross- references and other types of hypertext links.</P>

<P>As the type of an element is not always sufficient for completely
representing the role of that element in the document logical structure, the
notion of <EM>logical attribute</EM> has been introduced. A logical attribute
is information associated with an element that adds semantics to that
element.</P>

<P>The logical structure of a document is constrained by a model, called a
<EM>structure schema</EM>. Several structure schemas can be used, one for each
type of document. A structure schema defines a document type, by specifying
all types of elements that can be used in the logical structure of a document
of that type. It also specifies the attributes that can be associated with
each type of element and all structural relationships that can be set between
elements. Structure schemas are written in a specific declarative language,
called S. A compiler for the S language is available, so that new document
types can be defined, according to the requirements of applications.</P>

<H3><A NAME="sectb12">1.2</A> Presentation</H3>

<P>The graphical appearance of a document (also called <EM>presentation</EM>)
is derived from its logical structure and is generically specified by a
<EM>presentation schema</EM>. A presentation schema is associated with a
structure schema and specifies the appearance of documents of  the type
defined by the structure schema. For each type of element defined in the
structure schema, the presentation schema contains a set of presentation rules
that define the style and the format of the logical elements. Using these
rules, the system can then produce the graphical representation of a document,
on the basis of its logical structure.</P>

<P>Presentation schemas are written in the language P and a compiler for that
language is available. New presentation schemas can then be developed. Notice
that several presentation schemas can be associated with the same structure
schema, thus defining alternative presentations for the same type of
document.</P>

<P>In addition, each presentation schema may define different <EM>views</EM>.
A view is a subset of the document that can be formatted in a different way
and displayed separately: each view is presented in a different window on the
screen.</P>

<P>For balancing this rigid principle of presentation with a certain degree of
flexibility, it is possible to associate with some element instances a special
type of attribute, called <EM>specific presentation rule</EM>. A specific
presentation rule is a presentation rule of the same kind as those of the
presentation schema, but it applies only to the element instance with which it
is associated, not to all elements of that type.</P>

<P>With that approach to document representation, documents are first
specified generically, by writing structure schemas and presentation schemas.
Then end-users and application programs can manipulate document instances very
simply, by referring to the schemas. Most of the work consists in handling a
logical structure consistent with the chosen structure schema and in handling
the contents (the basic elements) of that structure. All the rest, especially
formatting and displaying, is done by the tool kit. In addition, the logical
structure is a very efficient help for moving across the document and for
locating the parts to be modified.</P>

<H2><A NAME="secta2">2</A> Tool kit structure</H2>

<H3><A NAME="sectb21">2.1</A> Structure of this manual</H3>

<P>The tool kit contains about 200 functions. For the sake of clarity, they
are presented by groups, each group focusing on a different aspect of
documents.</P>

<UL>
<LI>Group <EM>application</EM> (section <A HREF="#secta6">6</A>) concerns the
administration of the tool kit by the application.
<LI>Group <EM>interface</EM> (section <A HREF="#secta7">7</A>) allows the
application program to modify and extend the Thot editor.
<LI>Group <EM>document</EM> (section <A HREF="#secta10">10</A>) allows the
application to manage schemas and whole documents.
<LI>Group <EM>tree</EM> (section <A HREF="#secta11">11</A>) handles the
hierarchical logical structure of documents.
<LI>Group <EM>contents</EM> (section <A HREF="#secta12">12</A>) allows the
application to manipulate the contents of the leaves of the structure.
<LI>Group <EM>attribute</EM> (section <A HREF="#secta13">13</A>) concerns
logical attributes.
<LI>Group <EM>reference</EM> (section <A HREF="#secta14">14</A>) contains
functions for manipulating non hierarchical relationships (hypertext links).
<LI>Group <EM>language</EM> (section <A HREF="#secta15">15</A>) concerns
natural languages used in text contents.
<LI>Group <EM>presentation</EM> (section <A HREF="#secta16">16</A>) handles
specific presentation.
<LI>Group <EM>view</EM> (section <A HREF="#secta18">18</A>) handles views.
<LI>Group <EM>selection</EM> (section <A HREF="#secta19">19</A>) contains the
functions that handle the selection.
<LI>Group <EM>message</EM> (section <A HREF="#secta8">8</A>) allows the
application program to display messages intended to the user.
<LI>Group <EM>dialogue</EM> (section <A HREF="#secta9">9</A>) allows the
application program to manage menus and forms intended to the user.
</UL>

<P>Each section presenting a group of functions is divided into subsections
which correspond to the following four broad categories:</P>

<UL>
<LI><EM>constructors</EM> are functions that create or generate new things. By
extension, they also include reverse functions, which delete or destroy the
same things.
<LI><EM>modificators</EM> are functions that modify existing things in
different ways.
<LI><EM>accessors</EM> are the functions that allow the application program to
access things.
<LI><EM>locators</EM> are the functions that search various kind of things in
document, according to different criteria.
</UL>

<H3><A NAME="sectb22">2.2</A> Libraries</H3>

<P>The Thot editing tool kit is accessed through an API that is defined in
sections <A HREF="#secta6">6</A> to <A HREF="#secta9">9</A>. The tool kit
takes the form of two libraries for editing documents. Each library is suited
to a different type of application and an application uses only one of the two
editing libraries: the second library includes the  first one.</P>
<A NAME="L273"></A>
<H4><A NAME="sectc221">2.2.1</A> Thot Kernel library</H4>

<P>The first library allows an application to handle the logical structure and
the contents of Thot documents in automatic mode. This subset of the tool kit,
called Thot Kernel, does not produce the graphical aspect of documents. It
does not provide either any service for the user interface. It is typically
designed for applications performing automatic operations on the logical
structure and contents of documents without direct manipulation by a user.</P>

<P>The last five groups of functions (those handling views, selections, and
user interface to the editor) are not part of that library. Sections <A
HREF="#secta18">18</A> to <A HREF="#secta9">9</A> of that document do not
concern that library.</P>

<H4><A NAME="sectc222">2.2.2</A> Thot Editor library</H4>

<P>The second library, called Thot Editor, includes all facilities provided by
the Kernel, with the same interface, and provides additional services for
displaying the graphical aspect of documents. It also contains the whole Thot
editor with its user interface. All editing functions of Thot can be accessed
by the user and by application programs. The Thot Editor tool kit is typically
intended to interactive applications that handle documents under the control
of a user and that add new functions to the editor.</P>

<P>All groups of functions presented in this document are part of that
library. Functions that are also part of the Thot Kernel have exactly the same
interface when used in the context of Thot Editor. The only difference is
that, in the case of Thot Kernel, they do not display anything, and that, in
the case of Thot Editor, some of them (namely constructors and modificators)
modify the picture displayed on the screen. As a consequence, application
programs that have been developed for automatic processing can be reused in
the context of an interactive application without any change: the Thot Editor
automatically takes in charge all displaying problems that are not handled by
the Thot Kernel.</P>

<H2><A NAME="secta3">3</A> Using the Thot tool kit</H2>
<A NAME="L343"></A>
<H3><A NAME="sectb31">3.1</A> Errors</H3>

<P>Almost all functions of the tool kit can detect errors. In that case the
function is not performed and an error code is set. The tool kit provides the
application program with the function <A NAME="L351"></A>TtaGetErrorCode for
accessing the error code. That function returns the completion code of the
last tool kit function called by the application. Only the completion code of
the most recently called function is available. A 0 completion code means a
successful operation; other values are defined in files
<EM>application.h</EM>.</P>

<P>In addition to the error code returned to the application program by the
function <A NAME="L360"></A>TtaGetErrorCode, the tool kit prints an error
message on the standard error file stderr whenever an error is raised. Error
messages are printed by default, but the application program can ask the tool
kit to stop printing these messages, by calling the function <A
NAME="L364"></A>TtaSetErrorMessages.</P>

<H3><A NAME="sectb32">3.2</A> Include files</H3>

<P>Each group of functions has an associated include file. Available include
files are: application.h, document.h, tree.h, content.h, attribute.h,
reference.h, language.h, presentation.h, view.h, selection.h, interface.h.
These files must be included in each module of the application program that
calls at least one function of the corresponding group. They contain the
interface definition of the functions and the types and constants (#define)
used by these functions.</P>

<H3><A NAME="sectb33">3.3</A> Buffers</H3>

<P>Whenever a function may return a long character string (20 characters or
more), the buffer must be provided by the application when calling the
function. If the buffer is too small, the tool kit raises an error. But the
size of the character string can generally be asked before calling such
functions, by using another function.</P>

<H3><A NAME="sectb34">3.4</A> Naming conventions</H3>

<P>Functions in the Thot API belong to different categories regarding their
arguments and return value.  The naming scheme follows these categories:</P>

<UL>
<LI>TtaGet* are functions that return a single value as the value of the
function itself. Their arguments do not return any value.
<LI>TtaNext* or TtaPrevious* are void functions that return a single value
through an argument. You set that argument with an object before calling the
function and, when returning, this argument has a new value, which is the next
or previous object.  These functions are mainly used in loops to access
objects sequentially.
<LI>TtaGive* are void functions that return at least two values through their
arguments.
<LI>Functions that do not return any value just start with Tta.
</UL>

<H2><A NAME="secta4">4</A> <A NAME="L398">Types used by the Thot editing tool
kit</A></H2>

<P>The tool kit performs operations on various entities, such as schemas,
documents, elements, attributes, views, etc. Each entity is identified by a
unique identifier which is assigned by Thot. Therefore, an application program
must get that identifier before manipulating any entity. An identifier can be
obtained by constructors, accessors and locators.</P>

<P>The following types are used by the editing tool kit:</P>

<DL>
<DT>SSchema</DT>

<DD>a structure schema loaded by the tool kit.
<DT>Document</DT>

<DD>a document loaded or created by the tool kit.
<DT>Element</DT>

<DD>an element in the logical structure of a document.
<DT>Attribute</DT>

<DD>a logical attribute.
<DT>PRule</DT>

<DD>a specific presentation rule.
<DT>TypeUnit</DT>

<DD>UnRelative, UnXHeight, UnPoint, UnPixel, UnPercent
<DT>View</DT>

<DD>a view created by the editor (Thot Editor only).
<DT>ElementType</DT>

<DD>the type of an element.
<DT>AttributeType</DT>

<DD>the type of an attribute.
<DT>Language</DT>

<DD>the identifier of a natural language.
</DL>

<P>SSchemas, Elements, Attributes, and PRules are pointers (addresses),
whereas Documents and Views are integers. Language is an unsigned character.
Both ElementType and AttributeType are structures containing a SSchema (the
schema that defines the corresponding element type or attribute type) and an
integer which is the number of the element type or attribute type in that
structure schema. Structure ElementType is defined in file
<EM>tree.h</EM>:</P>

<PRE>
typedef struct _ElementType
    {
    SSchema ElSSchema;
    int ElTypeNum;
    } ElementType;
</PRE>

<P>Structure AttributeType is defined in file <EM>attribute.h</EM>:</P>

<PRE>
typedef struct _AttributeType
    {
    SSchema AttrSSchema;
    int AttrTypeNum;
    } AttributeType;
</PRE>

<P>In addition some integers are used for exchanging parameters between the
application program and the tool kit. Available parameters with their possible
values are:</P>

<DL>
<DT>Search domain</DT>

<DD>SearchForward, SearchBackward, SearchInTree.
<DT>Access rights</DT>

<DD>ReadWrite, ReadOnly, Hidden, Inherited.
<DT>Construct</DT>

<DD>ConstructIdentity, ConstructList, ConstructChoice,
ConstructOrderedAggregate, ConstructUnorderedAggregate, ConstructConstant,
ConstructReference, ConstructBasicType, ConstructNature, ConstructPair.
<DT>Presentation rules</DT>

<DD>PRSize, PRStyle, PRFont, PRUnderline, PRThickness, PRIndent,
PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle, PRLineWeight,
PRFillPattern, PRBackground, PRForeground, PRHyphenate.
<DT>Display modes</DT>

<DD>DisplayImmediately, DeferredDisplay, NoComputedDisplay.
</DL>

<H2><A NAME="secta5">5</A> Initialization</H2>

<P>Group application contains the functions for managing the tool kit API.
These functions require that file <EM>application.h</EM> be included in the
module that calls them.</P>

<P>Applications generated by an interface schema EDITOR.A don't have to call
these functions.</P>

<H3><A NAME="sectb51">5.1</A> Constructors</H3>

<H4><A NAME="sectc511">5.1.1</A> TtaInitialize</H4>
<A NAME="L591"></A>
<P>Initializes the Thot editing tool kit for an application. This function
must be called before any other function of the tool kit.</P>

<HR>

<P>void   TtaInitialize(char *applicationName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>applicationName</EM>: name of the application that requires services
from the tool kit. This name is used for accessing the ressources defined in
the Registry.
</DL>

<H4><A NAME="sectc512">5.1.2</A> TtaQuit</H4>
<A NAME="L615"></A>
<P>Quits the Thot tool kit. No other function of the tool kit can then be
called by the application.</P>

<HR>

<P>void TtaQuit()</P>

<HR>

<H4><A NAME="sectc513">5.1.3</A> TtaInitializeAppRegistry</H4>
<A NAME="L32621"></A>
<P>Initialize the Thot Registry. This is done by default by TtaInitialize. On
Unix platforms the Registry is physically stored in the <TT>Thot.ini</TT>
file, on Windows platforms the native Registry is used.</P>

<HR>

<P>void TtaInitializeAppRegistry(char *applicationName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>applicationName</EM>: name of the application.
</DL>

<H4><A NAME="sectc514">5.1.4</A> TtaSaveAppRegistry</H4>
<A NAME="L32629"></A>
<P>Commit the changes made to the Thot Registry. This is done by default by
TtaQuit.</P>

<HR>

<P>void TtaSaveAppRegistry()</P>

<HR>

<H2><A NAME="secta6">6</A> <A NAME="L576">Application</A></H2>

<P>Group application contains the functions for managing the tool kit API.
These functions require that file <EM>application.h</EM> be included in the
module that calls them.</P>

<H3><A NAME="sectb61">6.1</A> Constructors</H3>

<H4><A NAME="sectc611">6.1.1</A> TtaGetMemory</H4>
<A NAME="L629"></A>
<P>Allocates dynamically a buffer of a specific size.</P>

<HR>

<P>char *TtaGetMemory(int size)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>size</EM>: size in bytes (like using malloc) of the desired allocated
buffer.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the address of the allocated buffer.
</DL>

<DL>
<DT>See also:</DT>

<DD>TtaFreeMemory.
</DL>

<H4><A NAME="sectc612">6.1.2</A> TtaFreeMemory</H4>
<A NAME="L669"></A>
<P>Frees the memory allocated to a buffer by <A
NAME="L677"></A>TtaGetMemory.</P>

<HR>

<P>void  TtaFreeMemory(char *buffer)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>buffer</EM>: the address of the buffer.
</DL>

<DL>
<DT>See also:</DT>

<DD>TtaGetMemory.
</DL>

<H4><A NAME="sectc613">6.1.3</A> TtaGetEnvString</H4>
<A NAME="L32637"></A>
<P>Reads an entry from the Thot Registry. It returns a <B>non-modifiable</B>
string associated to the name given as parameter. Thot first looks for a
specific value associated to the current application, and if not found try to
find one in the "thot" section. Hence settings saved in the "thot" section are
shared by all applications based on the Thot library, but can be refined to
fit each application specific needs. If no value is found for the requested
entry, the function returns NULL.</P>

<HR>

<P>char *TtaGetEnvString(const char *name)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
</DL>

<H4><A NAME="sectc614">6.1.4</A> TtaGetDefEnvString</H4>
<A NAME="L58486"></A>
<P>Reads an entry from the Thot Registry. It returns a
<B>non-modifiable</B>default string associated to the name given as parameter.
Thot first looks for a specific value associated to the current application,
and if not found try to find one in the "thot" section. Hence settings saved
in the "thot" section are shared by all applications based on the Thot
library, but can be refined to fit each application specific needs. If no
value is found for the requested entry, the function returns NULL.</P>

<HR>

<P>char *TtaGetDefEnvString(const char *name)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
</DL>

<H4><A NAME="sectc615">6.1.5</A> TtaGetEnvInt</H4>
<A NAME="L58370"></A>
<P>Reads an entry from the Thot Registry. It returns the integer value
associated with the name given as a parameter. Thot first looks for a specific
value associated to the current application, and if not found try to find one
in the "thot" section. Hence settings saved in the "thot" section are shared
by all applications based on the Thot library, but can be refined to fit each
application specific needs. The function returns either TRUE or FALSE,
depending on whether the the registry entry exists or not.</P>

<HR>

<P>ThotBoolTtaGetEnvInt(const char *name, int *value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value of the entry.</P>

</DL>

<H4><A NAME="sectc616">6.1.6</A> TtaGetDefEnvInt</H4>
<A NAME="L58459"></A>
<P>Reads an entry from the Thot Registry. It returns the default integer value
associated with the name given as a parameter. Thot first looks for a specific
value associated to the current application, and if not found try to find one
in the "thot" section. Hence settings saved in the "thot" section are shared
by all applications based on the Thot library, but can be refined to fit each
application specific needs. The function returns either TRUE or FALSE,
depending on whether the the registry entry exists or not.</P>

<HR>

<P>ThotBoolTtaGetDefEnvInt(const char *name, int *value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value of the entry.</P>

</DL>

<H4><A NAME="sectc617">6.1.7</A> TtaGetEnvBoolean</H4>
<A NAME="L58400"></A>
<P>Reads an entry from the Thot Registry. It returns the ThotBool value
associated with the name given as a parameter. Thot first looks for a specific
value associated to the current application, and if not found try to find one
in the "thot" section. Hence settings saved in the "thot" section are shared
by all applications based on the Thot library, but can be refined to fit each
application specific needs. The function returns either TRUE or FALSE,
depending on whether the the registry entry exists or not.</P>

<HR>

<P>ThotBoolTtaGetEnvBoolean(const char *name, ThotBool *value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value of the entry.</P>

</DL>

<H4><A NAME="sectc618">6.1.8</A> TtaGetDefEnvBoolean</H4>
<A NAME="L58432"></A>
<P>Reads an entry from the Thot Registry. It returns the default ThotBool
value associated with the name given as a parameter. Thot first looks for a
specific value associated to the current application, and if not found try to
find one in the "thot" section. Hence settings saved in the "thot" section are
shared by all applications based on the Thot library, but can be refined to
fit each application specific needs. The function returns either TRUE or
FALSE, depending on whether the the registry entry exists or not.</P>

<HR>

<P>ThotBoolTtaGetDefEnvBoolean(const char *name, ThotBool *value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value of the entry.</P>

</DL>

<H4><A NAME="sectc619">6.1.9</A> TtaIsBlank</H4>
<A NAME="L57533"></A>
<P>TtaSkipBlanks skips all spaces, tabs, linefeeds and newlines at the
beginning of the string and returns the pointer to the new position.</P>

<HR>

<P>ThotBool TtaIsBlank (char *ptr);</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ptr</EM>: the source string.
</DL>

<H4><A NAME="sectc6110">6.1.10</A> TtaSkipBlanks</H4>
<A NAME="L57558"></A>
<P>TtaSkipBlanks skips all spaces, tabs, linefeeds and newlines at the
beginning of the string and returns the pointer to the new position.</P>

<HR>

<P>char *TtaSkipBlanks (char *ptr)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ptr</EM>: the source string.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the pointer to the new position in the source string.
</DL>

<H3><A NAME="sectb62">6.2</A> Modificators</H3>

<H4><A NAME="sectc621">6.2.1</A> TtaSetErrorMessages</H4>
<A NAME="L709"></A>
<P>Indicates to the tool kit whether error messages must be printed or
not.</P>

<HR>

<P>void TtaSetErrorMessages(int on)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>on</EM>: 1 if error messages must be printed, 0 if not.
</DL>

<H4><A NAME="sectc622">6.2.2</A> TtaSetEnvString</H4>
<A NAME="L32577"></A>
<P>Set an entry in the Thot Registry for the current application. </P>

<HR>

<P>void TtaSetEnvString(const char *name, const char *value, int
overwrite)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value associated to the entry.</P>

<P><EM>overwrite</EM>: should we overwrite an existing entry ?</P>

</DL>

<H4><A NAME="sectc623">6.2.3</A> TtaSetDefEnvString</H4>
<A NAME="L58511"></A>
<P>Sets the default value of an entry in the Thot Registry for the current
application. </P>

<HR>

<P>void TtaSetDefEnvString(const char *name, const char *value, int
overwrite)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value associated to the entry.</P>

<P><EM>overwrite</EM>: should we overwrite an existing entry ?</P>

</DL>

<H4><A NAME="sectc624">6.2.4</A> TtaSetEnvInt</H4>
<A NAME="L58225"></A>
<P>Set an entry in the Thot Registry for the current application. </P>

<HR>

<P>void TtaSetEnvInt(const char *name, const int value, int overwrite)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value associated to the entry.</P>

<P><EM>overwrite</EM>: should we overwrite an existing entry ?</P>

</DL>

<H4><A NAME="sectc625">6.2.5</A> TtaSetEnvBoolean</H4>
<A NAME="L58254"></A>
<P>Set an entry in the Thot Registry for the current application. </P>

<HR>

<P>void TtaSetEnvBoolean(const char *name, const ThotBool value, int
overwrite)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>name</EM>: name of the entry.
<P><EM>value</EM>: value associated to the entry.</P>

<P><EM>overwrite</EM>: should we overwrite an existing entry ?</P>

</DL>

<H3><A NAME="sectb63">6.3</A> Accessors</H3>

<H4><A NAME="sectc631">6.3.1</A> TtaGetVersion</H4>
<A NAME="L737"></A>
<P>Returns the identifier of the current version of the Thot eRediting tool
kit.</P>

<HR>

<P>char *TtaGetVersion()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>identifier of the current version.
</DL>

<H4><A NAME="sectc632">6.3.2</A> TtaGetErrorCode</H4>
<A NAME="L759"></A>
<P>Returns the error code set by the last call to the Thot editing tool kit.
See file <EM>application.h</EM> for the possible values.</P>

<HR>

<P>int TtaGetErrorCode()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>last error code, 0 if the last call was successful.
</DL>

<H4><A NAME="sectc633">6.3.3</A> TtaGetStrError</H4>
<A NAME="L782"></A>
<P>Returns a pointer to the message text for a given error code.</P>

<HR>

<P>char *TtaGetStrError(int errorCode)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>errorCode</EM>: an error code.
</DL>

<DL>
<DT>Return value:</DT>

<DD>pointer to the message text of the error.
</DL>

<DL>
<DT>See also:</DT>

<DD>TtaGetErrorCode
</DL>

<H2><A NAME="secta7">7</A> <A NAME="L8356">Interface</A></H2>

<P>The functions described in this section require that file
<EM>interface.h</EM> be included in the module that calls them. They are
available only in the Thot Editor library.</P>

<H3><A NAME="sectb71">7.1</A> Constructors</H3>

<H4><A NAME="sectc711">7.1.1</A> TtaSetCallback</H4>
<A NAME="L8372"></A>
<P>This function reserves a set of reference for creating dialogue elements
(forms, menus, submenus, labels, etc.) and specifies the procedure that is
called back when the user activates these dialogue elements.</P>

<P>Dialogue elements have to be created by the application using references
between the "base" value returned by this function and the value
"base+numberOfRef-1". So, this function must be called first.</P>

<P> It is possible to define different sets of dialogue elements by calling
this function more than one time with different <TT>callbackProcedure</TT>
procedure in the same application.</P>

<P>The <TT>callbackProcedure</TT> procedure declared  is called for each event
concerning these specific dialogue items. It receives three parameters: the
dialogue item reference, the data type, and the data value:</P>

<PRE>
void callbakProcedure(reference, datatype, data)
     int reference;
     int datatype;
     char *data;
</PRE>

<HR>

<P>int TtaSetCallback(void (*callbackProcedure) (), int numberOfRef)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>callbakProcedure</EM>: the application callback procedure.
<P><EM>numberOfRef</EM>: the nmber of reference reserved.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the "base" value for the <TT>numberOfRef</TT> specific dialogue elements
to be created.
</DL>

<H4><A NAME="sectc712">7.1.2</A> TtaHandlePendingEvents</H4>
<A NAME="L8412"></A>
<P>This function manages all Thot and Motif pending events. The application
have to call this function to allow user's interactions and display updates to
be managed during long treatments.</P>

<HR>

<P>void TtaHandlePendingEvents()</P>

<HR>

<H4><A NAME="sectc713">7.1.3</A> TtaHandleOneEvent</H4>
<A NAME="L25485"></A>
<P>This function processes one event within Thot and Motif. The application
which controls a local loop of events have to call this function to allow
managment of specific Thot and Motif events.</P>

<HR>

<P>void TtaHandlePendingEvents(XEvent *event)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>event</EM>: the X event to be managed.
</DL>

<H4><A NAME="sectc714">7.1.4</A> TtaAddButton</H4>
<A NAME="L8491"></A>
<P>Adds a new button into the document view button bar. This function must
specify a valid view of a valid document. The procedure parameter gives the
call back procedure that will be run when user select the button. This
procedure will receive two parametrers: the document and the view
concerned.</P>

<P>An example of callback procedure is.</P>

<PRE>
void callback_procedure (document, view)
Document document;
View view;
{
....
}
</PRE>

<P>If the icon parameter in None, a space button is generated and the callback
procedure is ignored. The parameters type and state are only used by on
Windows platforms.</P>

<HR>

<P>int TtaAddButton(Document document, View view, ThotIcon icon, STRING
functionName, STRING info, void (*procedure) (), BYTE type, ThotBool
state)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>icon</EM>: the pixmap of the new button or None,.</P>

<P><EM>functionName</EM>: the internal name of the function used to connect
shortcuts,.</P>

<P><EM>info</EM> the text displayed when the cursor stays on the button,.</P>

<P><EM>procedure</EM>: procedure to be executed when the button is selected by
the user or NULL.</P>

<P><EM>type</EM>: it could be TBSTYLE_BUTTON or TBSTYLE_CHECK.</P>

<P><EM>state</EM>: is TRUE if the button is in an active state,.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The button index.
</DL>

<H4><A NAME="sectc715">7.1.5</A> TtaAddTextZone</H4>
<A NAME="L32957"></A>
<P>Adds a new text-zone into the document view commands. This function must
specify a valid view of a valid document. The editable parameter indicates
that user can edit this text-zone. The procedure parameter gives the call back
procedure that will be run when user changes the text-zone: the user press the
<TT>Return</TT> key. This procedure will receive two parametrers: the document
and the view concerned.</P>

<P>An example of callback procedure is.</P>

<PRE>
void callback_procedure (document, view)
Document document;
View view;
{
....
}
</PRE>

<P>If the text-zone is not editable the procedure have to be NULL.</P>

<HR>

<P>int TtaAddTextZone(Document document, View view, char *label, ThotBool
editable, void (*procedure) ())</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>label</EM>: the label of the text-zone.</P>

<P><EM>editable</EM>: True is user can edit the text-zone.</P>

<P><EM>procedure</EM>: procedure to be executed when the text is modified by
the user.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The text-zone index.
</DL>

<H3><A NAME="sectb72">7.2</A> Accessors</H3>

<H4><A NAME="sectc721">7.2.1</A> TtaGetCurrentDisplay</H4>

<P>Returns the current display descriptor.</P>

<HR>

<P>Display *TtaGetCurrentDisplay()</P>

<HR>

<H4><A NAME="sectc722">7.2.2</A> TtaGetScreenDepth</H4>

<P>Returns the screen depth of the display.</P>

<HR>

<P>int TtaGetScreenDepth()</P>

<HR>

<H4><A NAME="sectc723">7.2.3</A> TtaClickAnElement</H4>
<A NAME="L8691"></A>
<P>Waits for a click from end-user and returns the element and document
selected. If the user clicks out of any document view, the returned values are
null.</P>

<HR>

<P>void TtaClickAnElement(Document document, Element element)</P>

<HR>

<DL>
<DT>Parameters</DT>

<DD><EM>document</EM>: the document selected by the user or 0.
<P><EM>element</EM>: the element selected by the user or 0.</P>

</DL>

<H3><A NAME="sectb73">7.3</A> Modificators</H3>

<H4><A NAME="sectc731">7.3.1</A> TtaChangeButton</H4>
<A NAME="L8724"></A>
<P>This function changes the button icon. This function must specify a valid
view of a valid document and a valid button index.</P>

<HR>

<P>void TtaChangeButton(Document document, View view, int buttonIndex,
ThotIcon icon, ThotBool state)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>buttonIndex</EM>: the button index, numbered from 1 to n.</P>

<P><EM>icon</EM>: the pixmap of the new button or None.</P>

<P><EM>state</EM>: TRUE if the button is an active button..</P>

</DL>

<H4><A NAME="sectc732">7.3.2</A> TtaSetTextZone</H4>
<A NAME="L33061"></A>
<P>This function gets the text to be displayed in the text-zone. This function
must specify a valid view of a valid document and a valid text-zone index.</P>

<HR>

<P>void TtaSetTextZone(Document document, View view, int textIndex, char
*text)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the concerned document.
<P><EM>view</EM>: the concerned view.</P>

<P><EM>textIndex</EM>: the button index, numbered from 1 to n.</P>

<P><EM>text</EM>: the text to be displayed into the text-zone.</P>

</DL>

<H4><A NAME="sectc733">7.3.3</A> TtaSetMenuOff</H4>
<A NAME="L8761"></A>
<P>Sets inactive a menu in the menu bar of the view of the document. If the
document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetMenuOff(Document document, View view, int menuID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the menu identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc734">7.3.4</A> TtaSetMenuOn</H4>
<A NAME="L33126"></A>
<P>Sets active a menu in the menu bar of the view of the document. If the
document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetMenuOn(Document document, View view, int menuID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the menu identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc735">7.3.5</A> TtaSetActionOff</H4>
<A NAME="L33157"></A>
<P>Sets inactive a menu action in the menu bar of the view of the document. If
the document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetActionOff(Document document, View view, int menuID, int
itemID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the main menu (even if the item is located into a submenu)
identification in the EDITOR.h file.</P>

<P><EM>itemID</EM>: the item identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc736">7.3.6</A> TtaSetActionOn</H4>
<A NAME="L33188"></A>
<P>Sets active a menu action in the menu bar of the view of the document. If
the document and view parameters are null, the menu is a application window
menu.</P>

<HR>

<P>void TtaSetActionOn(Document document, View view, int menuID, int
itemID)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the main menu (even if the item is located into a submenu)
identification in the EDITOR.h file.</P>

<P><EM>itemID</EM>: the item identification in the EDITOR.h file.</P>

</DL>

<H4><A NAME="sectc737">7.3.7</A> TtaSetToggleItem</H4>
<A NAME="L33225"></A>
<P>Sets on/off the toggle of an item in the menu bar of the view of the
document. If the document and view parameters are null, the menu is a
application window menu.</P>

<HR>

<P>void TtaSetActionOn(Document document, View view, int menuID, int itemID,
ThotBool on)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

<P><EM>menuID</EM>: the main menu (even if the item is located into a submenu)
identification in the EDITOR.h file.</P>

<P><EM>itemID</EM>: the item identification in the EDITOR.h file.</P>

<P><EM>on</EM>: the value True or False to be set.</P>

</DL>

<H4><A NAME="sectc738">7.3.8</A> TtaSetCursorWatch</H4>
<A NAME="L8797"></A>
<P>Displays the cursor watch within the view of the document. If the document
and view parameters are NULL, displays the cursor watch within all views of
documents.</P>

<HR>

<P>void TtaSetCursorWatch (Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document concerned or 0.
<P><EM>view</EM>: the view concerned or 0.</P>

</DL>

<H4><A NAME="sectc739">7.3.9</A> TtaResetCursor</H4>
<A NAME="L8827"></A>
<P>Resets the standard cursor within the view of the document. If the document
and view parameters are NULL, resets the standard cursor within all views of
documents.</P>

<HR>

<P>void TtaResetCursor(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>dument</EM>: the documen or 0.
<P><EM>view</EM>: the view or 0.</P>

</DL>

<H2><A NAME="secta8">8</A> <A NAME="L8857">Messages</A></H2>

<P>The functions described in this section require that file
<EM>message.h</EM> be included in the modules that call them.</P>

<P>The following functions are available in both the Thot Editor library and
the ThotKernel library. They allow an application program to manage messages
and dialogue text, as Thot tool kits do. Text of dialogue boxes and error
messages is defined out of the application code and is dynamically loaded when
the application is executed. This method allows application to adapt its
interface to the current user (English text for English user, French text for
French user, etc.). Each message is numbered, code referencing the message by
its number and an external file associating this number with its corresponding
text. An <A NAME="L8869"></A>environment variable is used to reach the correct
file that contains text of messages at the execution time. If this file is not
reachable, a warning message is sent to the standard output, but the execution
is not automatically stopped. Nevertheless, the Thot Editor library stops
execution when its text file is not reachable because it cannot work
without.</P>

<P>We give an example of an application that needs four messages. The
applicationMSG.h file is used to address correct message in source code and
the en-applicationTXT gives the English version of messages text:</P>

<TABLE BORDER=0>
  <TR>

<TD width=50%>

<P>#define APP_start              0</P>

<P>#define APP_abort             1</P>

<P>#define APP_no_file          2 </P>

<P>#define APP_complete      3</P>

<P>#define APP_MSG_MAX 4</P>

<P>applicationMSG.h</P>

<TD width=50%>

<P>0   Application</P>

<P>1   Application aborted</P>

<P>2   Unreachable file %s</P>

<P>3   End of application</P>

<P> </P>

<P>en-applicationTXT</P>

  </TR>
</TABLE>

<P> </P>

<P>The application has to load the rigth message table:</P>

<PRE>
errorTable = TtaGetMessageTable("applicationTXT", APP_MSG_MAX);
</PRE>

<P>and displays the third error message using one of available display
function (for example the TtaDisplayMessage function and TtaGetMessage):</P>

<PRE>
TtaDisplayMessage(FATAL, TtaGetMessage(errorTable, APP_no_file), filename);
</PRE>

<H3><A NAME="sectb81">8.1</A> Constructors</H3>

<H4><A NAME="sectc811">8.1.1</A> TtaGetMessageTable</H4>
<A NAME="L8927"></A>
<P>Loads text of application messages in a dynamically allocated table and
returns the identifcation of this messages table. The <TT>msgFile</TT> is the
generic name of the message file to be loaded. The <TT>msgNumber</TT>
parameter denotes the number of messages to be read in the file.The full name
of the loaded file is  <TT>$THOTDIR/config/$LANG-msgFile</TT>, where
<TT>$THOTDIR</TT> represents the root path of Thot hierarchy and
<TT>$LANG</TT> represents the current language (for example <TT>en</TT>).
<TT>$THOTDIR</TT> is computed by the Thot toolkit and <TT>$LANG</TT> can be
set in the user registry <TT>thot.ini</TT>.</P>

<HR>

<P>int TtaGetMessageTable(char *msgFile, int msgNumber)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>msgFile</EM>: the generic name of the message file.
<P>msgNumber: the number of messages.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>The messages table identifier or -1 if the table is not allocated and
loaded.
</DL>

<H3><A NAME="sectb82">8.2</A> Accessors</H3>

<H4><A NAME="sectc821">8.2.1</A> TtaGetMessage</H4>
<A NAME="L8968"></A>
<P>Returns the text of the corresponding message.</P>

<HR>

<P>char *TtaGetMessage(int msgTableID, int msgIndex)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>msgTableID</EM>: identifier of the messages table.
<P><EM>msgIndex</EM>: index of the message.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>Text of the message (an empty text if the table or the message is not
found).
</DL>
<A NAME="L9005"></A>
<H4><A NAME="sectc822">8.2.2</A> TtaDisplaySimpleMessage</H4>
<A NAME="L9007"></A>
<P>Displays the text of a simple message. This message is often displayed in
the message area of the main application window &frac34; if it exists &frac34;
or directed to the standard output for batch applications.</P>

<P>The msgType parameter defines the importance of the message:</P>

<UL>
<LI>INFO: the message is displayed in the message area of the main application
window just as an information.
<LI>OVERHEAD: the message replaces the previous message in the message area of
the main application window.
<LI>FATAL: the message stops the application with an  error code.
<LI>CONFIRM: the message pops a message box to display the message within and
waits for until the end user confirms the message has been read.
</UL>

<HR>

<P>void TtaDisplaySimpleMessage(int msgType, int msgTableID, int msgIndex)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>msgType</EM>: the message type (INFO,  OVERHEAD, FATAL, CONFIRM).</P>

<P><EM>msgTableID</EM>: identifier of the messages table (LIB for the standard
Thot messages).</P>

<P><EM>msgIndex</EM>: index of the message.</P>

</DL>

<H4><A NAME="sectc823">8.2.3</A> TtaDisplayMessage</H4>
<A NAME="L9057"></A>
<P>Displays a message mixing static text (the text of the message) with a
variable number of parameters. The static text plays the role of a format
(like the prinf format) and may include necessary format commandes for each
parameter: a %s for a string, a %d for an integer. Number and type of variable
parameters depend on format commands included in the message text.</P>

<P>.</P>

<HR>

<P>void TtaDisplayMessage(int msgType, msgTableID, int msgIndex, ...)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>msgType</EM>: the message type (INFO,  OVERHEAD, FATAL, CONFIRM).</P>

<P><EM>msgTableID</EM>: identifier of the messages table (LIB for the standard
Thot messages).</P>

<P><EM>msgIndex</EM>: index of the message.</P>

<P><EM>...</EM>: variable parameters.</P>

</DL>

<H2><A NAME="secta9">9</A> <A NAME="L9217">Dialogue</A></H2>

<P>The Thot editing tool kit provides dialogue functions. There are high level
functions that hide most of the complex aspects of OSF/Motif and thus allows
an application to use OSF/Motif very easily and dynamically (all dialogue
entities such as menus, buttons, forms, etc. can be created and modified at
any time). As these dialogue functions are already used internally by the
editing tool kit, another reason for an application to use it, is to present
the user with a homogeneous and consistent look and feel for the whole
application.</P>

<P>The functions described in this section require that file
<EM>dialogue.h</EM> be included in the module that calls them. They are
available only in the Thot Editor library.</P>

<P>Each dialogue element is identified by a unique reference. This reference
is associated to the dialogue element at the creation time and will be used
all along the time it exists to perform any action on it (intialization,
display, undisplay and destruction).</P>

<P>The application receives dialogue callbacks from created and displayed
dialogue elements through predefined specific callback procedures. The
application can define several callback procedures (at least one) and each
callback procedure can manage callbacks from several dialogue elements. Each
callback identifies the concerned element dialogue and allows the procedure to
switch on the correct management.</P>

<H3><A NAME="sectb91">9.1</A> Constructors</H3>

<H4><A NAME="sectc911">9.1.1</A> TtaSetCallback</H4>
<A NAME="L34387"></A>
<P>This function defines a callback procedure for a set of dialogue elements
(menus. forms, etc.). The function returns the current base value of concerned
dialogue elements and reserves the set of references contained between "base"
and "base+set-1". After that declaration dialogue elements can be created.
</P>

<P>When the user acts on these dialogue elements, the callback procedure is
called with three parameters:</P>

<UL>
<LI>the reference of the concerned dialogue element,
<LI>the type of the returned value (INTEGER_DATA or STRING_DATA) depending of
the dialogue element type (menu, form, text-form, etc.),
<LI>the returned data.
</UL>

<HR>

<P>int TtaSetCallback (Proc callbakProcedure, int set)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>callbakProcedure</EM>: the callback procedure to be called . That
procedure has to be previously declared like that:
void Proc (int reference, int typeData, char *data)
<P><EM>set</EM>: the number of concerned dialogue elements.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the base of dialogue element references.
</DL>

<H4><A NAME="sectc912">9.1.2</A> TtaSetBackup</H4>
<A NAME="L59308"></A>
<P>This function defines a backup procedure . If the application crashes for
any reason and almost one document is modified that procedure Backup is
called. That procedure has no parameter.</P>

<HR>

<P>void TtaSetBackup (Proc Backup)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>Backup</EM>: the  procedure to be called. That procedure has to be
previously declared like that:
void Proc ()
</DL>

<H4><A NAME="sectc913">9.1.3</A> TtaSetDocStatusUpdate</H4>
<A NAME="L59387"></A>
<P>This function defines a procedure which updates the application context
each time the document of a document changes.</P>

<P>When the status of a document changes (it becomes modified or unmodified)
the procedure DocStatusUpdate is called with two parameters:</P>

<UL>
<LI>the document identifier,
<LI>the new status status: TRUE if it's now modified, otherwise FALSE. 
</UL>

<HR>

<P>void TtaSetDocStatusUpdate (Proc DocStatusUpdate)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>DocStatusUpdate</EM>: the procedure to be called That procedure has to
be previously declared like that:
void Proc (Document doc, ThotBool modifed)
</DL>

<H4><A NAME="sectc914">9.1.4</A> TtaNewForm</H4>
<A NAME="L34475"></A>
<P>This function creates a form element attached to the ThotWidget parent.
When the parent ThotWidget is distroyed, the ThotWidget that realizes this
form is automatically destroyed. Usually the parent is the document view frame
returned by the API function <TT>TtaGetViewFrame (document, view) </TT>and the
form has to be destroyed before closing the document view.</P>

<P>As seen in the example below, the fonction automatically generates two
buttons on the bottom of the form:</P>

<UL>
<LI>a "confirm" button
<LI>and a "cancel/done" button.
</UL>

<P>The parameter dbutton controls the choice of the "cancel/done" button. Two
values are available: D_CANCEL or D_DONE.</P>
<IMG SRC="form.gif" ALT="Image form.gif">
<HR>

<P>void TtaNewForm (int ref, ThotWidget parent, char *title, ThotBool
horizontal, int packet, char button, int dbutton)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>parent</EM>: the ThotWidget parent (usually TtaGetViewFrame (document,
view)).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>horizontal</EM> is TRUE if dialogue elements included into the form are
arranged horizontally.</P>

<P><EM>packet</EM> number of dialogue elements in the same line if arranged
horizontally or in the same column is arranged vertically.</P>

<P><EM>button</EM> the mouse button used to select the element dialogue:</P>

<UL>
<LI>'L' for left button,
<LI>'M' for middle button,
<LI>'R' for right button.
</UL>

<P><EM>dbutton</EM> the type of "cancel/done" button: D_CANCEL or D_DONE.</P>

</DL>

<H4><A NAME="sectc915">9.1.5</A> <A NAME="L34518">TtaNewSheet</A></H4>
<A NAME="L34519"></A>
<P>This function creates a sheet element attached to the ThotWidget parent.
When the parent ThotWidget is destroyed, the ThotWidget that realizes this
sheet is automatically destroyed. Usually the parent is the document view
frame returned by the API function  TtaGetViewFrame (document, view)  and the
sheet has to be destroyed before closing the document view.</P>

<P>A sheet is similar to a form element, but only the "cancel/done" button is
automatically generated and other extra buttons are explicitly declared. The
parameter dbutton controls the choice of the "cancel/done" button. Two values
are available: D_CANCEL or D_DONE. In the example below, four extra buttons
had been declared: "Skip and next", "Skip (+dic)", "Replace and next" and
"Replace (+dic)".</P>
<IMG SRC="sheet.gif" ALT="Image sheet.gif">
<HR>

<P>void TtaNewSheet (int ref, ThotWidget parent, char *title, int number, char
*text, ThotBool horizontal, int packet, char button, int dbutton)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>parent</EM>: the ThotWidget parent (usually TtaGetViewFrame (document,
view)).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>number</EM>: number of extra buttons declared in the sheet.</P>

<P><EM>text</EM>: the list of strings declaring extra buttons ("A\0B\0" for
two extra buttons A and B).</P>

<P><EM>horizontal</EM> is TRUE if dialogue elements included into the form are
arranged horizontally.</P>

<P><EM>packet</EM> number of dialogue elements in the same line if arranged
horizontally or in the same column is arranged vertically.</P>

<P><EM>button</EM> the mouse button used to select the element dialogue:</P>

<UL>
<LI>'L' for left button,
<LI>'M' for middle button,
<LI>'R' for right button.
</UL>

<P><EM>dbutton</EM> the type of "cancel/done" button: D_CANCEL or D_DONE.</P>

</DL>

<H4><A NAME="sectc916">9.1.6</A> TtaNewDialogSheet</H4>
<A NAME="L35163"></A>
<P>This function creates a dialog sheet element attached to the ThotWidget
parent. When the parent ThotWidget is distroyed, the ThotWidget that realizes
this sheet is automatically destroyed. Usually the parent is the document view
frame returned by the API function  TtaGetViewFrame (document, view)  and the
sheet has to be destroyed before closing the document view.</P>

<P>A dialog sheet is similar to a sheet element, but no "cancel/done" button
is automatically generated.</P>

<HR>

<P>void TtaNewDialogSheet (int ref, ThotWidget parent, char *title, int
number, char *text, ThotBool horizontal, int packet, char button)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>parent</EM>: the ThotWidget parent (usually TtaGetViewFrame (document,
view)).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>number</EM>: number of extra buttons declared in the sheet.</P>

<P><EM>text</EM>: the list of strings declaring extra buttons ("A\0B\0" for
two extra buttons "A" and "B").</P>

<P><EM>horizontal</EM> is TRUE if dialogue elements included into the form are
arranged horizontally.</P>

<P><EM>packet</EM> number of dialogue elements in the same line if arranged
horizontally or in the same column is arranged vertically.</P>

<P><EM>button</EM> the mouse button used to select the element dialogue:</P>

<UL>
<LI>'L' for left button,
<LI>'M' for middle button,
<LI>'R' for right button.
</UL>

</DL>

<H4><A NAME="sectc917">9.1.7</A> TtaNewSubmenu</H4>
<A NAME="L34633"></A>
<P>This function creates a submenu element attached to a menu entry or a form
(form, sheet or dialog sheet). In a form, a submenu is displayed as a radio
menu (see the menu "Paper Format" in the example presented in <A
HREF="#sectc915">9.1.5</A>). Only one entry of this menu can be selected at
the same time.</P>

<P>Each entry is typed:</P>

<UL>
<LI>a simple button,
<LI>a link towards a form,
<LI>a link towards a submenu,
<LI>toggle button,
<LI>a separator.
</UL>

<HR>

<P>void TtaNewSubmenu (int ref, int ref_parent, int entry, char *title, int
number, char *text, char *equiv, ThotBool react)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a menu or a
form).</P>

<P><EM>entry</EM>: the entry index (0 to n) in the parent menu which the
submenu is attached to. For a submenu attached to  a form this paramameter is
not treated.</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>number</EM>: number of entries declared in the submenu.</P>

<P><EM>text</EM>: the list of strings declaring entries. Each entry starts
with a special character that fixes the entry function:</P>

<UL>
<LI>'B' the entry is a simple button,
<LI>'F' the entry calls a form,
<LI>'M' the entry calls a submenu,
<LI>'T' the entry is a toggle.
<LI>'S" the entry is a separator (the entry string is limited to this
character).
</UL>

<P>For example the text value "TA\0B" declares a toggle entry "A" and a button
entry "B".</P>

<P><EM>equiv</EM>: the list of strings declaring shortcuts attached to each
entry. This parameter can be NULL if no shortcut is declared.</P>

<P><EM>react</EM>: TRUE if the application wants to be informed as soon as the
user selects in this submenu in a form. FALSE if the application prefers to
wait for the confirmation of the form to receive the selected value.</P>

</DL>

<H4><A NAME="sectc918">9.1.8</A> TtaNewIconMenu</H4>
<A NAME="L34679"></A>
<P>This function creates a submenu element attached to a menu entry or a form
(form, sheet or dialog sheet). This submenu is composed of icons. Only one
entry of this menu can be selected at the same time. This menu is always
reactive.</P>

<HR>

<P>void TtaNewIconMenu (int ref, int ref_parent, int entry, char *title, int
number, Pixmap * icons, ThotBool horizontal)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a menu or a
form).</P>

<P><EM>entry</EM>: the entry index (0 to n) in the parent menu which the
submenu is attached to. For a submenu attached to  a form this paramameter is
not treated.</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>number</EM>: number of entries declared in the menu.</P>

<P><EM>icons</EM>: the list of pixmaps.</P>

<P><EM>horizontal</EM> is TRUE if entries are arranged horizontally.</P>

</DL>

<H4><A NAME="sectc919">9.1.9</A> TtaNewToggleMenu</H4>
<A NAME="L34656"></A>
<P>This function creates a toggle menu element attached to a  form (form,
sheet or dialog sheet). This menu is displayed as a toggle menu (see the menu
"Options" in the example presented in <A HREF="#sectc915">9.1.5</A>). Only or
more entries of this menu can be selected at the same time.</P>

<P>Each entry is typed:</P>

<UL>
<LI>a toggle,
<LI>a separator.
</UL>

<HR>

<P>void TtaNewToggleMenu (int ref, int ref_parent, char *title, int number,
char *text, char *equiv, ThotBool react)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a form).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>number</EM>: number of entries declared in the menu.</P>

<P><EM>text</EM>: the list of strings declaring entries. Each entry starts
with a special character that fixes the entry function:</P>

<UL>
<LI>'B' or 'T' the entry is a simple button,
<LI>'S" the entry is a separator (the entry string is limited to this
character).
</UL>

<P>For example the text value "TA\0S\0BC" declares an entry "A", a separator
and an entry "C".</P>

<P><EM>equiv</EM>: the list of strings declaring shortcuts attached to each
entry. This parameter can be NULL if no shortcut is declared.</P>

<P><EM>react</EM>: TRUE if the application wants to be informed as soon as the
user selects in this submenu in a form. FALSE if the application prefers to
wait for the confirmation of the form to receive the selected value.</P>

</DL>

<H4><A NAME="sectc9110">9.1.10</A> TtaNewSelector</H4>
<A NAME="L34702"></A>
<P>This function creates a selector element attached to a  form (form, sheet
or dialog sheet).</P>

<P>The selector can be displayed with or without a text input zone (controled
by the parameter <TT>withText</TT>) that allows user to choose a predefined
string into the selector or to insert directly  a free text. The selector can
be displayed with or without a label (controled by the parameter
<TT>label</TT>) that allow user to select this fixed.</P>

<P>In the previous example presented in <A HREF="#sectc915">9.1.5</A>, a
selector is displayed with the title "Spell checking ...", a text zone and the
label "W3C".</P>

<HR>

<P>void TtaNewSelector (int ref, int ref_parent, char *title, int number, char
*text, int height, char *label, ThotBool withText, ThotBool react)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a form).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>number</EM>: number of entries declared in the submenu.</P>

<P><EM>text</EM>: the list of strings declaring entries. For example the text
value "A\0B\0C" declares an entrries "A", "B" and "C".</P>

<P><EM>height</EM>: the height of the selector (number of entries
displayed).</P>

<P><EM>label</EM>: the label string of the extra entry or NULL.</P>

<P><EM>withText</EM>: TRUE if the application wants to display a text zone at
the selector bottom.</P>

<P><EM>react</EM>: TRUE if the application wants to be informed as soon as the
user selects in this selector. FALSE if the application prefers to wait for
the confirmation of the form to receive the selected value.</P>

</DL>

<H4><A NAME="sectc9111">9.1.11</A> TtaNewLabel</H4>
<A NAME="L34725"></A>
<P>This function creates a label element attached to a  form (form, sheet or
dialog sheet). In the previous example presented in <A
HREF="#sectc915">9.1.5</A>, there is a label element "Language: English".</P>

<HR>

<P>void TtaNewLabel (int ref, int ref_parent, char *text)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a form).</P>

<P><EM>text</EM>: the text of the label.</P>

</DL>

<H4><A NAME="sectc9112">9.1.12</A> TtaNewTextForm</H4>
<A NAME="L34748"></A>
<P>This function creates a text input zone attached to a  form (form, sheet or
dialog sheet). In the previous example presented in <A
HREF="#sectc915">9.1.5</A>, there is a text input zone without title.</P>

<HR>

<P>TtaNewTextForm (int ref, int ref_parent, char *title, int width, int
height, ThotBool react)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a form).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>width</EM>: number of charaters displayed.</P>

<P><EM>height</EM>: tnumber of lines displayed.</P>

<P><EM>react</EM>: TRUE if the application wants to be informed as soon as the
user inserts characters. FALSE if the application prefers to wait for the
confirmation of the form to receive the final string.</P>

</DL>

<H4><A NAME="sectc9113">9.1.13</A> TtaNewNumberForm</H4>
<A NAME="L34771"></A>
<P>This function creates an input zone for integer values attached to a  form
(form, sheet or dialog sheet). In the previous example presented in <A
HREF="#sectc915">9.1.5</A>, there is an input zone for integer values (from 1
to 10) displayed with the title "Number of proposals".</P>

<HR>

<P>void TtaNewNumberForm (int ref, int ref_parent, char *title, int min, int
max, ThotBool react)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>ref</EM>: the unique reference attached to the dialogue element.
<P><EM>ref_parent</EM>: the reference of parent element (a form).</P>

<P><EM>title</EM> the title or NULL.</P>

<P><EM>min</EM>: the minimum integer value.</P>

<P><EM>max</EM>: the maximum integer value.</P>

<P><EM>react</EM>: TRUE if the application wants to be informed as soon as the
user inserts characters. FALSE if the application prefers to wait for the
confirmation of the form to receive the final string.</P>

</DL>

<H4><A NAME="sectc9114">9.1.14</A> TtaDestroyDialogue</H4>

<P>This function destroys an existing dialogue element.</P>

<HR>

<P>void TtaDestroyDialogue (int ref)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>ref</EM>: the unique reference attached to the dialogue element.</P>

</DL>

<H4><A NAME="sectc9115">9.1.15</A> TtaListDirectory</H4>
<A NAME="L9232"></A>
<P>Creates one or two selectors that allow end-user to select a directory
and/or a file included within the current specified directory. This function
supposes that the application had first created a form where selectors have to
be inserted. The application is able to create either only the directory
selector or only the file selector. A suffix can be specified if the
application wants to filter a specific class of files. It is the
responsibility of the application to receive and handle the selectors
callback.</P>

<HR>

<P>void TtaListDirectory(char *aDirectory, int formRef, char *dirTitle, int
dirRef, char *suffix, char *fileTitle, int fileRef)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>aDirectory</EM>: the current designated directory.
<P><EM>formRef</EM>: the form identification.</P>

<P><EM>dirTitle</EM>: the title of the directory selector.</P>

<P><EM>dirRef</EM>: the directory selector identification or -1 if this
selector is not desired.</P>

<P><EM>suffix</EM>: the suffix used for filtering files (for example
".PIV")</P>

<P><EM>fileTitle</EM>: the title of the file selector.</P>

<P><EM>fileRef</EM>: the file selector identification or -1 if this selector
is not desired.</P>

</DL>

<H4><A NAME="sectc9116">9.1.16</A> TtaIsSuffixFileIn</H4>
<A NAME="L9290"></A>
<P>Returns True if the specified directory contains files with the specified
suffix.</P>

<HR>

<P>ThotBool TtaIsSuffixFileIn(char *aDirectory, char *suffix)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>aDirectory</EM>: the current designated directory.
<P><EM>suffix</EM>: the suffix used for filtering files (for example
".PIV")</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True or False.
</DL>

<H3><A NAME="sectb92">9.2</A> Modificators</H3>

<H4><A NAME="sectc921">9.2.1</A> TtaSetMenuForm</H4>
<A NAME="L35703"></A>
<P>Selects an entry in a radio menu (submenu) of a form.</P>

<HR>

<P>void TtaSetMenuForm (int ref, int entry)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>ref</EM>: the unique reference attached to the dialogue element.</P>

<P><EM>entry</EM>: the selected entry (0 to n).</P>

</DL>

<H4><A NAME="sectc922">9.2.2</A> TtaSetToggleMenu</H4>

<P>Changes the status of a toggle entry of a menu (submenu or toggle menu) in
a form.</P>

<HR>

<P>void TtaSetToggleMenu (int ref, int value, ThotBool on)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>ref</EM>: the unique reference attached to the dialogue element.</P>

<P><EM>entry</EM>: the selected entry (0 to n).</P>

<P><EM>on</EM>: fixes the status of the toggle; TRUE if the toggle is
selected.</P>

</DL>

<H4><A NAME="sectc923">9.2.3</A> TtaSetTextForm</H4>

<P>Changes the current value of the text form.</P>

<HR>

<P>void TtaSetTextForm (int ref, STRING text)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>ref</EM>: the unique reference attached to the dialogue element.</P>

<P><EM>text</EM>: the new string.</P>

</DL>

<H4><A NAME="sectc924">9.2.4</A> TtaShowDialogue</H4>

<P>This function displays an existing dialogue (form, sheet, dialog
sheet).</P>

<HR>

<P>void TtaShowDialogue (int ref, ThotBool remanent)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>ref</EM>: the unique reference attached to the dialogue element.</P>

<P><EM>remanent</EM>: TRUE if the dialogue element is not automatically
unmapped.</P>

</DL>

<H4><A NAME="sectc925">9.2.5</A> TtaUnmapDialogue</H4>

<P>This function undisplays an existing dialogue (form, sheet, dialog
sheet).</P>

<HR>

<P>void TtaUnmapDialogue (int ref)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>
<P><EM>ref</EM>: the unique reference attached to the dialogue element.</P>

</DL>

<H2><A NAME="secta10">10</A> <A NAME="L822">Documents and schemas</A></H2>

<P>The functions described in this section require that file
<EM>document.h</EM> be included in the module that calls them.</P>
<A NAME="L831"></A>
<DL>
<DT>Document identification</DT>

<DD>An application program using the Thot editing tool kit can handle several
documents at the same time. These documents can be defined by the same
structure schema or by different structure schemas as well. Before any other
operation can be performed, a document must be either created (<A
NAME="L840"></A>TtaNewDocument), if it does not exist yet, or opened
(TtaOpenDocument), if it exists in a file. These two functions return a value
of type Document that is then used for identifying the document to which
subsequent operations apply. The only exception is the function <A
NAME="L844"></A>TtaGiveSchemasOfDocument which accesses a document by its
name.
<P>The name of a document is a character string (maximum length is 19
characters, not including the extension) that is used for naming the file
containing the document and that appears in the user dialogue (Thot Editor
only).</P>

</DL>

<DL>
<DT>Document files</DT>

<DD>Documents are stored in Unix files. Actually, a single document is
represented by several files. All these files have the same name as the
document, with different extensions:
<UL>
<LI>The .PIV file contains the last version of the document (logical
structure, contents, logical attributes and specific presentation rules). A
.PIV file is created each time the document is saved, either by the user or by
the application program (function <A NAME="L866"></A>TtaSaveDocument). The
.PIV file is the file read by the <A NAME="L870"></A>TtaOpenDocument function.
<LI>The .OLD file contains the previous version of the document. It is a copy
of the .PIV file before the last save operation.
<LI>The .BAK file contains a version of the document that is written
periodically for allowing recovery from crashes. It is removed each time the
document is saved successfully, but if the system or the application crashes,
it must be renamed .PIV and can be used as an ordinary document file. 
<LI>The .SAV file is also a backup file. It is created by the tool kit when an
internal error occurs and when it can save the document. This file contains
the state of the document at the very moment of the crash. It can be used in
the same way as the .BAK file.
<LI>The .EXT and .REF files contain the representation of the links that
relate the document with other documents. These files do not exist if the
document has no relations (references) with other documents. If they exist,
they must be in the same directory as the .PIV file. They are read by the
function <A NAME="L890"></A>TtaOpenDocument.
</UL>

</DL>

<DL>
<DT>Directories</DT>

<DD>A list of directories, called the <EM>document path</EM>, is used for
searching the files needed when opening a document (.PIV, .REF and .EXT
files). This path is initially set by the environment variable THOTDOC and it
can be changed at any time by the function <A
NAME="L904"></A>TtaSetDocumentPath. When a document is created
(TtaNewDocument), all corresponding files are created in the first directory
of the document path.
<P>Another list of directories is used when searching the schemas needed by a
document that is created (<A NAME="L912"></A>TtaNewDocument) or opened
(TtaOpenDocument). The <EM>schema path</EM> is initially set by the
environment variable THOTSCH and it can be changed at any time by the function
<A NAME="L918"></A>TtaSetSchemaPath. This path is also used by the function <A
NAME="L922"></A>TtaNewNature.</P>

</DL>

<DL>
<DT>Access mode</DT>

<DD>When using Thot Editor, the application program may ask the tool kit to
prevent the user from modifying the document: an access mode (allowed values
are read/write and read only) is associated with the whole document. The
functions of the editing tool kit are not affected by the access mode; an
application program can modify a document even if it is in read only mode. The
access mode only applies to the operations performed by the user, who cannot
modify a document that is in read only mode. When creating or opening a
document, the access mode is set to read/write, but it can be changed at any
time by the function <A NAME="L935"></A>TtaSetDocumentAccessMode.
<P>An application program can more precisely control the operations that the
user is allowed to perform, by associating an access mode with each element in
a document. This is explained in section <A HREF="#secta11">11</A>.</P>

</DL>

<DL>
<DT>Natures</DT>

<DD>Many structured documents contain objects of different <EM>natures</EM>,
such as tables, equations, drawings, bibliographic items, etc. which are
themselves logically structured. For avoiding to define the structure of these
objects in the structure schemas of all document types, these objects are
defined in separate structure schemas, one for each nature of objects, and
they can be dynamically linked to document structure schemas. This can be
repeated recursively: if an object of a given nature includes objects of other
natures, its structure schema must include the structure schemas of the
included natures.
<P>When the first object of a given nature is created in a document or in an
object of another nature, the structure schema that defines the new nature
must be linked to the structure schema that defines the document or object in
which it is included. This is achieved by calling the function <A
NAME="L958"></A>TtaNewNature.</P>

</DL>

<DL>
<DT>Schema extensions</DT>

<DD>Documents produced by Thot may be processed by other applications, which
are either independent from the editor or included in it. Examples of such
applications are the comparison of two versions of a document (independent
from the editor) or the electronic index (included in the editor). Many of
these applications make use of their own structural elements or attributes,
which are related to the application itself and which are necessary for the
application, whatever the document type. A <EM>structure schema extension</EM>
is a special type of structure schema that defines attributes and elements of
that kind and that can be associated to the main structure schema of any
document for allowing an application to create in the document its own
attributes and elements, which are not defined in the document structure
schema. When several applications have to work on the same document, several
schema extensions can be associated to the main structure schema of that
document.
</DL>

<H3><A NAME="sectb101">10.1</A> Constructors</H3>

<H4><A NAME="sectc1011">10.1.1</A> TtaNewDocument</H4>
<A NAME="L981"></A>
<P>Creates the internal representation of a new document according to a given
structure schema. No file is created immediately, but the backup files (.BAK
and .SAV) and the document file (.PIV, see TtaNewDocument) will be created in
the first directory of the document path (see TtaSetDocumentPath).</P>

<HR>

<P>Document TtaNewDocument(char *structureSchema, char *documentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>structureSchema</EM>: name of the structure schema that defines the
type of document to be created.
<P><EM>documentName</EM>: name of the document to be created (maximum length
19 characters). The directory name is not part of this parameter (see <A
NAME="L1010"></A>TtaSetDocumentPath).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the document that has been created or 0 if the document has not been
created.
</DL>

<H4><A NAME="sectc1012">10.1.2</A> TtaOpenDocument</H4>
<A NAME="L1024"></A>
<P>Opens an existing document for subsequent operations.</P>

<HR>

<P>Document TtaOpenDocument(char *documentName, int accessMode)</P>

<HR>

<PRE>
Document TtaOpenDocument(documentName, accessMode)
char *documentName;
int accessMode;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>documentName</EM>: name of the file containing the document to be
open. (maximum length 19 characters). The directory name is not part of this
parameter (see <A NAME="L1049"></A>TtaSetDocumentPath).
<P><EM>accessMode</EM>: 0 = read only, 1 = read-write.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the opened document, or 0 if the document cannot be open.
</DL>

<H4><A NAME="sectc1013">10.1.3</A> TtaSaveDocument</H4>
<A NAME="L1066"></A>
<P>Saves a document into a file in Thot format (.PIV). The document is not
closed by the function and can still be accessed by the application
program.</P>

<HR>

<P>void TtaSaveDocument(Document document, char *documentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to be saved.
<P><EM>documentName</EM>: name of the file in which the document must be
saved. (maximum length 19 characters). The directory name is not part of this
parameter (see <A NAME="L1095"></A>TtaSetDocumentPath). If the documentName is
not the same as the one used when opening (see <A
NAME="L1099"></A>TtaOpenDocument) or creating (see <A
NAME="L1103"></A>TtaNewDocument) the document, a new file is created and the
file with the old name is unchanged, i. e. a new version is created. If
necessary, the old file can be removed by the function <A
NAME="L1107"></A>TtaRemoveDocument.</P>

</DL>

<H4><A NAME="sectc1014">10.1.4</A> TtaExportDocument</H4>
<A NAME="L13418"></A>
<P>Saves a document into a file in a particular format. The output format is
specified by a translation schema. The document is not closed by the function
and it can still be accessed by the application program.</P>

<HR>

<P>ThotBool TtaExportDocument(Document document, char *fileName, char
*TSchemaName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to be exported.
<P><EM>fileName</EM>: name of the file in which the document must be saved,
including the directory name.</P>

<P><EM>TSchemaName</EM>: name of the translation schema to be used. The
directory name must not be specified in parameter TSchemaName. See function
TtaSetSchemaPath.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>TRUE if the document has not saved.
</DL>

<H4><A NAME="sectc1015">10.1.5</A> TtaCloseDocument</H4>
<A NAME="L1112"></A>
<P>Closes a document that is no longer needed and releases all ressources
allocated to the document. This function does not save the document.</P>

<HR>

<P>void TtaCloseDocument(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document to be closed.
</DL>

<H4><A NAME="sectc1016">10.1.6</A> TtaRemoveDocument</H4>
<A NAME="L1137"></A>
<P>Closes a document, releases all ressources allocated to that document,
removes all files related to the document and updates all links connecting the
removed document with other documents.</P>

<HR>

<P>void TtaRemoveDocument(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document to be removed.
</DL>

<H4><A NAME="sectc1017">10.1.7</A> TtaSetDocumentPath</H4>
<A NAME="L1161"></A>
<P>Sets a new list of document directories. This list replaces the existing
one. It is used for searching a document when it is open either by the user or
by the application program (see <A NAME="L1169"></A>TtaOpenDocument). The
first directory in the list is used when a new document is created (see
TtaNewDocument).</P>

<HR>

<P>void TtaSetDocumentPath(char *path)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>path</EM>: the directory list, where directory names are separated by
the character ':'.
</DL>

<H4><A NAME="sectc1018">10.1.8</A> TtaAppendDocumentPath</H4>
<A NAME="L1189"></A>
<P>Appends a new directory in the list of document directories. The function
controls that the parameter is the name of an existing directory and sets an
error if it is not. If the new directory is within the list of document
directories yet, the function has no effect.</P>

<HR>

<P>void TtaAppendDocumentPath(aDirectory)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>aDirectory</EM>: the new directory name.
</DL>

<H4><A NAME="sectc1019">10.1.9</A> TtaSetSchemaPath</H4>
<A NAME="L1213"></A>
<P>Sets a new list of schema directories. This list replaces the existing one.
It is used for searching schemas.</P>

<HR>

<P>void TtaSetSchemaPath(char *path)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>path</EM>: the directory list, where directory names are separated by
the character ':'.
</DL>

<H3><A NAME="sectb102">10.2</A> Modificators</H3>

<H4><A NAME="sectc1021">10.2.1</A> TtaNewNature</H4>
<A NAME="L1242"></A>
<P>Adds a new nature in a structure schema and returns the structure schema of
the new nature. If the nature already exists in that structure schema, the
function simply returns the structure schema of that nature.</P>

<HR>

<P>SSchema TtaNewNature(SSchema schema, char *natureName, char
*presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>schema</EM>: the structure schema to which the nature is added.
<P><EM>natureName</EM>: name of the nature to be added in the structure
schema.</P>

<P><EM>presentationName</EM>: name of the presentation schema to be associated
with the extension schema. If presentationName is an empty string, the default
presentation schema is associated. If the nature already exists,
presentationName is ignored.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the structure schema of the new nature; NULL if the structure schema has
not been loaded.
</DL>

<H4><A NAME="sectc1022">10.2.2</A> TtaNewSchemaExtension</H4>
<A NAME="L1285"></A>
<P>Loads a structure schema extension and associates it with a given
document.</P>

<HR>

<P>SSchema TtaNewSchemaExtension(Document document, char *extensionName, char
*presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose structure schema must be extended.
<P><EM>extensionName</EM>: name of the extension schema.</P>

<P><EM>presentationName</EM>: name of the presentation schema to be associated
with the extension schema. If presentationName is an empty string, the default
presentation schema is associated.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the extension schema, NULL if the extension schema has not been loaded.
</DL>

<H4><A NAME="sectc1023">10.2.3</A> TtaRemoveSchemaExtension</H4>
<A NAME="L1330"></A>
<P>Removes a structure schema extension from a given document. Removes also
from the document all attributes and elements defined in that structure schema
extension.</P>

<HR>

<P>void TtaRemoveSchemaExtension(Document document, SSchema extension, int
*removedElements, int *removedAttributes)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>extension</EM>: the structure schema extension to be removed.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>removedElements</EM>: number of elements actually removed.
<P><EM>removedAttributes</EM>: number of attributes actually removed.</P>

</DL>

<H4><A NAME="sectc1024">10.2.4</A> TtaSetPSchema</H4>
<A NAME="L1377"></A>
<P>Sets or changes the main presentation schema of a document. The document
must be open, but no view must be open for that document.</P>

<HR>

<P>void TtaSetPSchema(Document document, char *presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>presentationName</EM>: Name of the presentation schema to be associated
with the document.</P>

</DL>

<H4><A NAME="sectc1025">10.2.5</A> TtaSetDocumentDirectory</H4>
<A NAME="L1408"></A>
<P>Sets the directory to which the document will be saved when calling
TtaSaveDocument.</P>

<HR>

<P>void TtaSetDocumentDirectory(Document document, char *directory)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose directory is set.
<P><EM>directory</EM>: new document directory.</P>

</DL>

<H4><A NAME="sectc1026">10.2.6</A> TtaSetDocumentName</H4>
<A NAME="L13459"></A>
<P>Sets or changes the name of a document. The document must be loaded.</P>

<HR>

<P>void TtaSetDocumentName(Document document, char *documentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose name is set.
<P><EM>documentName</EM>: new document name. This is only the name, without
any suffix, without directory name. See function TtaSetDocumentDirectory for
changing the directory of a document.
The name must not exceed 31 characters.</P>

</DL>

<H4><A NAME="sectc1027">10.2.7</A> TtaSetDocumentAccessMode</H4>
<A NAME="L1438"></A>
<P>Sets the access mode for a document.</P>

<HR>

<P>void TtaSetDocumentAccessMode(Document document, int accessMode)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose access mode is changed.
<P><EM>accessMode</EM>: 0 = read only, 1 = read-write.</P>

</DL>

<H4><A NAME="sectc1028">10.2.8</A> TtaSetDocumentBackUpInterval</H4>
<A NAME="L13494"></A>
<P>Sets the backup interval for a document.</P>

<HR>

<P>void TtaSetDocumentBackUpInterval(Document document, int interval)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose backup interval is changed.
<P><EM>interval</EM>: 0 : the backup mechanism must be disabled
positive integer : number of characters typed which triggers automatic save of
the document into a .BAK file.</P>

</DL>

<H4><A NAME="sectc1029">10.2.9</A> TtaSetNotificationMode</H4>
<A NAME="L1468"></A>
<P>Sets the ECF notification mode for a document.</P>

<HR>

<P>void TtaSetNotificationMode(Document document, int notificationMode)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose notification mode is changed.
<P><EM>notificationMode</EM>: 0 = only roots of created, copied and deleted
subtrees must be notified, 1 = all elements of created, copied and deleted
subtrees must be notified.</P>

</DL>

<H4><A NAME="sectc10210">10.2.10</A> TtaSetDocumentModified</H4>
<A NAME="L1498"></A>
<P>Notifies the tool kit that a document has been modified by the application.
As a consequence, the user will be asked to save the document when closing
it.</P>

<HR>

<P>void TtaSetDocumentModified(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<H4><A NAME="sectc10211">10.2.11</A> TtaSetDocumentUnmodified</H4>
<A NAME="L1523"></A>
<P>Notifies the tool kit that a document must be considered as not modified.
As a consequence, if no further modification is made to that document, the
user will not be asked to save the document when closing it.</P>

<HR>

<P>void TtaSetDocumentUnmodified(Document document)</P>

<HR>

<DL>
<DT>Parameter :</DT>

<DD>
<P><EM>document</EM> : the document.</P>

</DL>

<H3><A NAME="sectb103">10.3</A> Accessors</H3>

<H4><A NAME="sectc1031">10.3.1</A> TtaGetSchemaExtension</H4>

<P>Returns the extension structure schema associated with the given
document.</P>

<HR>

<P>SSchema TtaGetSchemaExtension(Document document, char *ExtensionName)</P>

<HR>

<DL>
<DT>Parameter :</DT>

<DD>
<P><EM>document</EM> : the document for which the extension structure schema
is asked.</P>

<P><EM>ExtensionName</EM> : the extension name.</P>

</DL>

<H4><A NAME="sectc1032">10.3.2</A> TtaGetDocumentName</H4>
<A NAME="L1551"></A>
<P>Returns the name of a document.</P>

<HR>

<P>char *TtaGetDocumentName(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>
<P><EM>document</EM>: the document whose name is asked.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that document.
</DL>

<H4><A NAME="sectc1033">10.3.3</A> TtaGetDocumentFromName</H4>
<A NAME="L1582"></A>
<P>Returns the document having a given name.</P>

<HR>

<P>Document TtaGetDocumentFromName(char *documentName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>
<P><EM>documentName</EM>: the document name.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the document having that name.
</DL>

<H4><A NAME="sectc1034">10.3.4</A> TtaGetDocumentSSchema</H4>
<A NAME="L1613"></A>
<P>Returns the main structure schema of a document.</P>

<HR>

<P>SSchema TtaGetDocumentSSchema(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the structure schema is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the structure schema of that document.
</DL>

<H4><A NAME="sectc1035">10.3.5</A> TtaGetSSchemaName</H4>
<A NAME="L1646"></A>
<P>Returns the name of a structure schema.</P>

<HR>

<P>char *TtaGetSSchemaName(SSchema schema)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>schema</EM>: the structure schema of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that structure schema.
</DL>

<H4><A NAME="sectc1036">10.3.6</A> TtaGetPSchemaName</H4>
<A NAME="L1678"></A>
<P>Returns the name of the presentation schema currently associated with a
given structure schema.</P>

<HR>

<P>char *TtaGetPSchemaName(SSchema schema)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>schema</EM>: the structure schema of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of the associated presentation schema.
</DL>

<H4><A NAME="sectc1037">10.3.7</A> TtaGetDocumentDirectory</H4>
<A NAME="L1710"></A>
<P>Returns the directory to which the document is supposed to be saved.</P>

<HR>

<P>void TtaGetDocumentDirectory(Document document, char *buffer, int
bufferLength)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>document</EM>: the document whose directory is asked.</P>

<P><EM>buffer</EM>: a buffer provided by the caller.</P>

<P><EM>bufferLength</EM>: the length of that buffer.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: the document directory.
</DL>

<H4><A NAME="sectc1038">10.3.8</A> TtaGetSSchema</H4>
<A NAME="L1755"></A>
<P>Returns a structure schema whose name is known and that is used in a given
document.</P>

<HR>

<P>SSchema TtaGetSSchema(char *name, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: the name of the structure schema of interest.
<P><EM>document</EM>: the document that uses this structure schema.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the structure schema having this name, or NULL if this structure schema is
not loaded or not used by the document.
</DL>

<H4><A NAME="sectc1039">10.3.9</A> TtaSameSSchemas</H4>
<A NAME="L1793"></A>
<P>Compares two structure schemas.</P>

<HR>

<P>int TtaSameSSchemas(SSchema schema1, SSchema schema2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>schema1</EM>: first structure schema.
<P><EM>schema2</EM>: second structure schema.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both schemas are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc10310">10.3.10</A> TtaGiveSchemasOfDocument</H4>
<A NAME="L1831"></A>
<P>Returns the names of the main structure schema and presentation schema
associated with a given document. The document does not need to be open and
the schemas are not loaded by this function.</P>

<HR>

<P>void TtaGiveSchemasOfDocument(char *documentName, char *structureName, char
*presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>documentName</EM>: Name of the document to be checked (maximum length
19 characters).
<P><EM>structureName</EM>: buffer.</P>

<P><EM>presentationName</EM>: buffer.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD><EM>structureName</EM>: Name of the document structure schema.
<P><EM>presentationName</EM>: Name of the document presentation schema.</P>

</DL>

<H4><A NAME="sectc10311">10.3.11</A> TtaNextSchemaExtension</H4>
<A NAME="L1881"></A>
<P>Returns a structure schema extension associated with a given document.</P>

<HR>

<P>void TtaNextSchemaExtension(Document document, SSchema *extension)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document of interest.
<P><EM>extension</EM>: a schema extension of that document. NULL for accessing
the first schema extension.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>extension</EM>: the schema extension that follows or the first schema
extension of the document if parameter extension is NULL. NULL if there is no
more schema extension.
</DL>

<H4><A NAME="sectc10312">10.3.12</A> TtaNextNature</H4>
<A NAME="L1920"></A>
<P>Returns the structure schema of a nature used in a given document.</P>

<HR>

<P>void TtaNextNature(Document document, SSchema *nature)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document of interest.
<P><EM>nature</EM>: the structure schema of a nature for that document. NULL
for accessing the first nature.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>nature</EM>: the structure schema of the next nature, or the structure
schema of the first nature of the document if parameter nature was NULL when
calling. NULL if there is no more nature for the document.
</DL>

<H4><A NAME="sectc10313">10.3.13</A> TtaIsDocumentModified</H4>
<A NAME="L1960"></A>
<P>Indicates whether a document has been modified by the user or not.
Modifications made by the application program are not considered, except when
explicitly notified by <A NAME="L1968"></A>TtaSetDocumentModified.</P>

<HR>

<P>int TtaIsDocumentModified(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the document has been modified by the user since it has been saved,
loaded or created, 0 if it has not been modified.
</DL>

<H4><A NAME="sectc10314">10.3.14</A> TtaGetDocumentBackUpInterval</H4>
<A NAME="L13531"></A>
<P>Returns the backup interval for a document.</P>

<HR>

<P>int TtaGetDocumentBackUpInterval(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document whose backup interval is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>0 : the backup mechanism is disabled
positive integer : number of typed characters which trigger an autamatic save
of the document into a .BAK file.
</DL>

<H4><A NAME="sectc10315">10.3.15</A> TtaGetDocumentAccessMode</H4>
<A NAME="L1996"></A>
<P>Returns the access mode for a document.</P>

<HR>

<P>int TtaGetDocumentAccessMode(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document whose access mode is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if access mode is read only, 1 if access mode is read-write.
</DL>

<H4><A NAME="sectc10316">10.3.16</A> TtaGetNotificationMode</H4>
<A NAME="L2028"></A>
<P>Returns the ECF notification mode for a document.</P>

<HR>

<P>int TtaGetNotificationMode(Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document whose notification mode is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>0 = if only roots of created and deleted subtrees must be notified,
<P>1 = all elements of created and deleted subtrees must be notified.</P>

</DL>

<H4><A NAME="sectc10317">10.3.17</A> TtaGetDocumentPath</H4>
<A NAME="L2064"></A>
<P>Returns the current list of the directories used when a document is open
(see <A NAME="L2072"></A>TtaOpenDocument).</P>

<HR>

<P>void TtaGetDocumentPath(char *buffer, int bufferLength)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>buffer</EM>: a buffer provided by the caller.
<P><EM>bufferLength</EM>: the length of that buffer.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: the list of directories. Directory names are separated by
the character ':'.
</DL>

<H4><A NAME="sectc10318">10.3.18</A> TtaGetSchemaPath</H4>
<A NAME="L2108"></A>
<P>Returns the current list of directories used for accessing schemas.</P>

<HR>

<P>void TtaGetSchemaPath(char *buffer, int bufferLength)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>buffer</EM>: a buffer provided by the caller.
<P><EM>bufferLength</EM>: the length of that buffer.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: the list of directories. Directory names are separated by
the character ':'.
</DL>

<H4><A NAME="sectc10319">10.3.19</A> TtaGetDocumentOfSavedElements</H4>
<A NAME="L2147"></A>
<P>Returns the document for which the last Copy or Cut command has been
issued.</P>

<HR>

<P>Document TtaGetDocumentOfSavedElements()</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>no parameter
</DL>

<DL>
<DT>Return value:</DT>

<DD>the document for which the last Copy or Cut command has been issued. 0 if
the clipboard is empty.
</DL>

<H2><A NAME="secta11">11</A> <A NAME="L2176">Tree structures</A></H2>

<P>The largest group of functions in the editing tool kit handles the tree
structures that represent the logical organization of a document.</P>

<P>The functions described in this section require that file <EM>tree.h</EM>
be included in the module that calls them.</P>

<DL>
<DT>Main tree and associated trees</DT>

<DD>A document is in fact represented by a <EM>forest</EM>, as several trees
may be necessary for representing its abstract structure. The <EM>main
tree</EM> represents the main stream of information in a document. In addition
to that tree, there may exist some <EM>associated trees</EM>, which represent
other streams of information, such as notes, illustrations, comments, etc.
These associated trees are specified in the structure schema of the document.
</DL>

<DL>
<DT>Structure of abstract trees</DT>

<DD>Several functions in this group allow to build or modify the structure of
an abstract tree. As stated above, the structure of these trees is constrained
by structure schemas. Therefore the programmer must be careful when handling
abstract trees. All functions that change a tree structure check that the
result will be consistent with the structure schema and they raise an error in
case of inconsistency.
<P>Checking can be made in two modes, a strict mode and a relaxed mode. In
strict mode, all mandatory elements must always be present. In relaxed mode,
even elements that are not stated optional in their structure schema can be
omitted. The checking mode apply to the operations made by the application
program, but also to the editing commands issued by the end-user, when using
ThotEditor. The function <A NAME="L2213"></A>TtaSetCheckingMode (see section
<A HREF="#sectc1128">11.2.8</A>) changes checking mode.</P>

<P>For building a correct tree, the programmer must follow the structure
schema. He or she can also consider existing Thot documents as examples. For
that purpose, the function <A NAME="L2222"></A>TtaListAbstractTree (see
section <A HREF="#sectc1151">11.5.1</A>) can produce a human-readable form of
an abstract tree.</P>

</DL>

<DL>
<DT>Element types</DT>

<DD>When creating or searching elements in an abstract tree, the type of the
concerned elements must be given. As presented in section <A
HREF="#secta4">4</A>, an element type contains a type number, but this number
does not appear explicitly in a structure schema: it is generated by the
schema compiler. For obtaining all type numbers of a structure schema, use the
command:
<EM>       printsch -h SchemaName
</EM>which lists on the standard output a file that can be included into a C
program. This file also contains all attribute numbers of the schema
</DL>

<DL>
<DT>Order of operations</DT>

<DD>As a general rule, as soon as an element or a tree has been created (by
functions <A NAME="L2250"></A>TtaNewElement, <A NAME="L2254"></A>TtaNewTree,
or <A NAME="L2258"></A>TtaCopyTree), it must be included into the main tree or
an associated tree of a document (by functions <A
NAME="L2262"></A>TtaInsertSibling, <A NAME="L2266"></A>TtaInsertFirstChild, or
<A NAME="L2270"></A>TtaAttachNewTree), prior any other function can be
performed.
</DL>

<DL>
<DT>Labels</DT>

<DD>Each element in a document has a unique identifier called a
<EM>label</EM>. Labels are automatically assigned to elements by all functions
that create new elements (<A NAME="L2284"></A>TtaNewElement, <A
NAME="L2288"></A>TtaNewTree, or <A NAME="L2292"></A>TtaCopyTree). Labels can
be accessed by functions <A NAME="L2296"></A>TtaSearchElementByLabel and <A
NAME="L2300"></A>TtaGetElementLabel.
</DL>

<DL>
<DT>Access rights</DT>

<DD>An access right can be associated with each element. Three access rights
are defined:
<DL>
<DT>Read/write</DT>

<DD>The element can be seen and modified by the user.
<DT>Read only</DT>

<DD>The element can be seen by the user, but no changes are allowed.
<DT>Hidden</DT>

<DD>The element is not displayed and cannot be changed by the user.
</DL>

<P>These rights only apply to the end user who manipulates a document
interactively with the commands provided by the Thot editor. They do not apply
to the application program that manipulate the document through the editing
tool kit.</P>

</DL>

<H3><A NAME="sectb111">11.1</A> Constructors</H3>

<H4><A NAME="sectc1111">11.1.1</A> TtaNewElement</H4>
<A NAME="L2345"></A>
<P>Creates a new element of a given type.</P>

<HR>

<P>Element TtaNewElement(Document document, ElementType elementType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the element is created.
<P><EM>elementType</EM>: type of the element to be created.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the created element.
</DL>

<H4><A NAME="sectc1112">11.1.2</A> TtaNewTree</H4>
<A NAME="L2383"></A>
<P>Creates a new element of a given type and all its descendants, according to
the structure schema.</P>

<HR>

<P>Element TtaNewTree(Document document, ElementType elementType , char
*label)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the tree is created.
<P><EM>elementType</EM>: type of the root element of the tree to be
created.</P>

<P><EM>label</EM>: label of the root element to be created. Empty string if
the value of the label is undefined.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the root element of the created tree.
</DL>

<H4><A NAME="sectc1113">11.1.3</A> TtaCopyTree</H4>
<A NAME="L2427"></A>
<P>Creates a copy of a tree.</P>

<HR>

<P>Element TtaCopyTree(Element sourceElement, Document sourceDocument,
Document destinationDocument, Element parent)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>sourceElement</EM>: element to be copied.
<P><EM>sourceDocument</EM>: the document containing the element to be
copied.</P>

<P><EM>destinationDocument</EM>: the document for which the copy must be
created.</P>

<P><EM>parent</EM>: element that will become the parent of the created
tree.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the root element of the created tree.
</DL>

<H4><A NAME="sectc1114">11.1.4</A> TtaCreateDescent</H4>
<A NAME="L25514"></A>
<P>Creates a new element of a given type and inserts it in the tree as a
descendant of a given element. All elements of the descent required by the
structure schema are also created.</P>

<HR>

<P>Element TtaCreateDescent(Document document, Element element, ElementType
elementType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the tree is created.
<P><EM>element</EM>: the element for which a descent will be created.</P>

<P><EM>elementType</EM>: type of the element to be created as the last
descendant.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the last descendant created or NULL if the element cannot be created. This
element is empty.
</DL>

<H4><A NAME="sectc1115">11.1.5</A> TtaCreateDescentWithContent</H4>
<A NAME="L25552"></A>
<P>Creates a new element of a given type and inserts it in the tree as a
descendant of a given element. All elements of the descent required by the
structure schema are created, as well as the content of the requested
element.</P>

<HR>

<P>Element TtaCreateDescentWithContent(Document document, Element element,
ElementType elementType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the tree is created.
<P><EM>element</EM>: the element for which a descent will be created.</P>

<P><EM>elementType</EM>: type of the element to be created as the last
descendant.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the last descendant created or NULL if the element cannot be created. If
not NULL, the minimum content of that element has been created.
</DL>

<H4><A NAME="sectc1116">11.1.6</A> TtaDeleteTree</H4>
<A NAME="L2522"></A>
<P>Deletes a tree (or a single element) and frees it. All references that
points at any element of that tree are cancelled. The deleted element must not
be used later.</P>

<HR>

<P>void TtaDeleteTree(Element element, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element (or root of the tree) to be deleted.
<P><EM>document</EM>: the document containing the element to be deleted.</P>

</DL>

<H4><A NAME="sectc1117">11.1.7</A> TtaAttachNewTree</H4>
<A NAME="L2553"></A>
<P>Attaches an entire tree (main tree or associated tree) to a document.</P>

<HR>

<P>void TtaAttachNewTree(Element tree, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>tree</EM>: root of the tree to be attached. This tree must be a valid
main tree or associated tree according to the document structure schema.
<P><EM>document</EM>: the document to which the tree is to be attached.</P>

</DL>

<H4><A NAME="sectc1118">11.1.8</A> TtaExportTree</H4>
<A NAME="L53265"></A>
<P>Saves an abstract tree into a file in a particular format. The output
format is specified by a translation schema.</P>

<HR>

<P>void TtaExportTree (Element element, Document document, char *fileName,
char *TSchemaName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the root of the tree to be exported
<P><EM>document</EM>: the document containing the tree to be exported.</P>

<P><EM>fileName</EM>: name of the file in which the tree must be saved,
including the directory name.</P>

<P><EM>TSchemaName</EM>: name of the translation schema to be used. The
directory name must not be specified in parameter TSchemaName. See function
TtaSetSchemaPath.</P>

</DL>

<H3><A NAME="sectb112">11.2</A> Modificators</H3>

<H4><A NAME="sectc1121">11.2.1</A> TtaInsertSibling</H4>
<A NAME="L2587"></A>
<P>Inserts an element in a tree, as an immediate sibling of a given element.
The element to be inserted must not yet be part of a document. You can call
<TT>TtaCanInsertSibling</TT> before to check whether that insertion is allowed
or not (see section <A HREF="#sectc11333">11.3.33</A>).</P>

<HR>

<P>void TtaInsertSibling(Element newElement, Element sibling, ThotBool before,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>newElement</EM>: the element (or root of the tree) to be inserted.
<P><EM>sibling</EM>: an element belonging to a tree. This element must not be
the root of a tree.</P>

<P><EM>before</EM>: if True, inserts newElement as previous sibling of
sibling, if False, inserts newElement as next sibling of sibling.</P>

<P><EM>document</EM>: the document to which both elements belong.</P>

</DL>

<H4><A NAME="sectc1122">11.2.2</A> TtaInsertFirstChild</H4>
<A NAME="L2629"></A>
<P>Inserts an element in a tree, as the first child of a given element. The
element to be inserted must not yet be part of a document. This function can
also be used for attaching an option to a choice. You can call
<TT>TtaCanInsertFirstChild</TT> before to check whether that insertion is
allowed or not (see section <A HREF="#sectc11334">11.3.34</A>).</P>

<HR>

<P>void TtaInsertFirstChild(Element *newElement, Element parent, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>newElement</EM>: the element (or root of the tree) to be inserted.
<P><EM>parent</EM>: an element belonging to a tree.</P>

<P><EM>document</EM>: the document to which both elements belong.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD>If newElement is an option that replaces the choice, newElement takes
<P>the value of parent.</P>

</DL>

<H4><A NAME="sectc1123">11.2.3</A> TtaCreateElement</H4>
<A NAME="L32712"></A>
<P>Creates an element of a given type and insert it at the current position
within a given document. The current position is defined by the current
selection. If the current position is a single position (insertion point) the
new element is simply inserted at that position. If one or several characters
and/or elements are selected, the new element is created at that position and
the selected characters/elements become the content of the new element,
provided the  structure schema allows it.</P>

<HR>

<P>void TtaCreateElement(ElementType elementType, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType</EM>: type of the element to be created.
<P><EM>document</EM>: the document for which the element is created.</P>

</DL>

<H4><A NAME="sectc1124">11.2.4</A> TtaInsertElement</H4>
<A NAME="L32720"></A>
<P>Creates an element of a given type and insert it at the current position
within a given document. The current position is defined by the current
selection. If the current position is a single position (insertion point) the
new element is simply inserted at that position. If one or several characters
and/or elements are selected, the new element is created before the first
selected character/element and the selected characters/elements are not
changed.</P>

<HR>

<P>void TtaInsertElement(ElementType elementType, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType</EM>: type of the element to be created.
<P><EM>document</EM>: the document for which the element is created.</P>

</DL>

<H4><A NAME="sectc1125">11.2.5</A> TtaRemoveTree</H4>
<A NAME="L2677"></A>
<P>Removes a tree (or a single element) from its tree, without freeing it.</P>

<HR>

<P>void TtaRemoveTree(Element element, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element (or root of the tree) to be removed.
<P><EM>document</EM>: the document containing the element to be removed.</P>

</DL>

<H4><A NAME="sectc1126">11.2.6</A> TtaSetAccessRight</H4>
<A NAME="L2707"></A>
<P>Sets the access rights for a given element. Access rights apply only during
the current editing session; they are not saved with the document. They must
be set each time the document is loaded.</P>

<HR>

<P>void TtaSetAccessRight(Element element, AccessRight right, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element.
<P><EM>right</EM>: access right for that element (ReadOnly, ReadWrite, Hidden,
Inherited).</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1127">11.2.7</A> TtaHolophrastElement</H4>
<A NAME="L2742"></A>
<P>Changes the holophrasting status of a given element.</P>

<HR>

<P>void TtaHolophrastElement(Element element, ThotBool holophrast, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element.
<P><EM>holophrast</EM>: True: the element gets holophrasted if it is not,
False: if the element is holphrasted, it gets expanded.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1128">11.2.8</A> <A NAME="L2778">TtaSetCheckingMode</A></H4>
<A NAME="L2779"></A>
<P>Changes checking mode.</P>

<HR>

<P>void TtaSetCheckingMode(ThotBool strict)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>strict</EM>: if True, the presence of all mandatory elements is
checked.
</DL>

<H3><A NAME="sectb113">11.3</A> Accessors</H3>

<H4><A NAME="sectc1131">11.3.1</A> TtaGetMainRoot</H4>
<A NAME="L2807"></A>
<P>Returns the root element of the main abstract tree representing a
document.</P>

<HR>

<P>Element TtaGetMainRoot(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the root element of the main abstract tree.
</DL>

<H4><A NAME="sectc1132">11.3.2</A> TtaNextAssociatedRoot</H4>
<A NAME="L2839"></A>
<P>Returns the root element of the associated tree that follows the tree to
which a given element belongs.</P>

<HR>

<P>void TtaNextAssociatedRoot(Document document, Element *root)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>root</EM>: the element for which the next associated tree is searched.
That element does not need to be the root of a tree. If root is NULL or if
root is an element in the main tree, the root of the first associated tree is
returned.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>root</EM>: the root element of the next associated tree. NULL if there
is no next associated tree for the document.
</DL>

<H4><A NAME="sectc1133">11.3.3</A> TtaGetFirstChild</H4>
<A NAME="L2879"></A>
<P>Returns the first child element of a given element.</P>

<HR>

<P>Element TtaGetFirstChild(Element parent)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parent</EM>: the element for which the first child element is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the first child element of parent; NULL if parent has no child.
</DL>

<H4><A NAME="sectc1134">11.3.4</A> TtaGetLastChild</H4>
<A NAME="L2911"></A>
<P>Returns the last child element of a given element.</P>

<HR>

<P>Element TtaGetLastChild(Element parent)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parent</EM>: the element for which the last child element is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the last child element of parent; NULL if parent has no child.
</DL>

<H4><A NAME="sectc1135">11.3.5</A> TtaGetFirstLeaf</H4>
<A NAME="L57990"></A>
<P>Returns the first leaf element of a given element.</P>

<HR>

<P>Element TtaGetFirstLeaf(Element parent)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parent</EM>: the element for which the first leaf element is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the first leaf element of parent; parent itself if it has no leaf.
</DL>

<H4><A NAME="sectc1136">11.3.6</A> TtaGetLastLeaf</H4>
<A NAME="L58021"></A>
<P>Returns the last leaf element of a given element.</P>

<HR>

<P>Element TtaGetLastLeaf(Element parent)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parent</EM>: the element for which the last leaf element is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the last leaf element of parent; parent itself if it has no leaf.
</DL>

<H4><A NAME="sectc1137">11.3.7</A> TtaPreviousSibling</H4>
<A NAME="L2943"></A>
<P>Returns the previous sibling element of a given element.</P>

<HR>

<P>void TtaPreviousSibling(Element *element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose previous sibling is asked.
</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>element</EM>: the previous sibling element, or NULL if there is no
previous sibling.
</DL>

<H4><A NAME="sectc1138">11.3.8</A> TtaNextSibling</H4>
<A NAME="L2977"></A>
<P>Returns the next sibling element of a given element.</P>

<HR>

<P>void TtaNextSibling(Element *element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose next sibling is asked.
</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>element</EM>: the next sibling element, or NULL if there is no next
sibling.
</DL>

<H4><A NAME="sectc1139">11.3.9</A> TtaGetSuccessor</H4>
<A NAME="L3010"></A>
<P>Returns the element that follows a given element at the same level or at
the first upper level where there is a following element.</P>

<HR>

<P>Element TtaGetSuccessor(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose successor is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the successor, or NULL if there is no successor.
</DL>

<H4><A NAME="sectc11310">11.3.10</A> TtaGetPredecessor</H4>
<A NAME="L3044"></A>
<P>Returns the element that precedes a given element at the same level or at
the first upper level where there is a preceding element.</P>

<HR>

<P>Element TtaGetPredecessor(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose predecessor is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the predecessor, or NULL if there is no predecessor.
</DL>

<H4><A NAME="sectc11311">11.3.11</A> TtaGetParent</H4>
<A NAME="L3077"></A>
<P>Returns the parent element (i.e. first ancestor) of a given element.</P>

<HR>

<P>Element TtaGetParent(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose the parent is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the parent element, or NULL if there is no parent (root).
</DL>

<H4><A NAME="sectc11312">11.3.12</A> TtaGetCommonAncestor</H4>
<A NAME="L3109"></A>
<P>Returns the common ancestor element of two given elements.</P>

<HR>

<P>Element TtaGetCommonAncestor(Element element1, Element element2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element1</EM>: the first element whose ancestor is asked.
<P><EM>element2</EM>: the second element whose ancestor is asked.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the common ancestor, or NULL if there is no common ancestor.
</DL>

<H4><A NAME="sectc11313">11.3.13</A> TtaGetTypedAncestor</H4>
<A NAME="L3147"></A>
<P>Returns the first ancestor of a given type for a given element.</P>

<HR>

<P>Element TtaGetTypedAncestor(Element element, ElementType ancestorType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element whose ancestor is asked.
<P><EM>ancestorType</EM>: type of the asked ancestor.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the ancestor, or NULL if there is no ancestor of that type.
</DL>

<H4><A NAME="sectc11314">11.3.14</A> TtaGetElementType</H4>
<A NAME="L3185"></A>
<P>Returns the type of a given element.</P>

<HR>

<P>ElementType TtaGetElementType(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>type of the element.
</DL>

<H4><A NAME="sectc11315">11.3.15</A> TtaGetElementTypeName</H4>
<A NAME="L3218"></A>
<P>Returns the name of an element type.</P>

<HR>

<P>char *TtaGetElementTypeName(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: element type.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that type.
</DL>

<H4><A NAME="sectc11316">11.3.16</A> TtaGetElementTypeOriginalName</H4>
<A NAME="L56825"></A>
<P>Returns the original name of an element type, as it is defined in the
structure schema.</P>

<HR>

<P>char *TtaGetElementTypeOriginalName(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: element type.
</DL>

<DL>
<DT>Return value:</DT>

<DD>original name of that type.
</DL>

<H4><A NAME="sectc11317">11.3.17</A> TtaGiveTypeFromName</H4>
<A NAME="L3250"></A>
<P>Gives an element type whose name is known (the structure schema that
defines that type must be loaded). That type is searched in a given structure
schema (elementType.ElSSchema) and in all structure schemas that are
extensions of that structure schema or natures used in that structure
schema.</P>

<HR>

<P>void TtaGiveTypeFromName(ElementType *elementType, char *name)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType.ElSSchema</EM>: the structure schema of interest.
<P><EM>name</EM>: the name of the type of interest.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>elementType</EM>: the type having this name, or elementType.ElTypeNum
= 0 if the type is not found.
</DL>

<H4><A NAME="sectc11318">11.3.18</A> TtaGiveTypeFromOriginalName</H4>
<A NAME="L56856"></A>
<P>Gives an element type whose original name (in the language it is given in
the structure schema) is known (the structure schema that defines that type
must be loaded). That type is searched in a given structure schema
(elementType.ElSSchema) and in all structure schemas that are extensions of
that structure schema or natures used in that structure schema.</P>

<HR>

<P>void TtaGiveTypeFromOriginalName(ElementType *elementType, char *name)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>elementType.ElSSchema</EM>: the structure schema of interest.
<P><EM>name</EM>: the original name of the type of interest.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>elementType</EM>: the type having this name, or elementType.ElTypeNum
= 0 if the type is not found.
</DL>

<H4><A NAME="sectc11319">11.3.19</A> TtaSameTypes</H4>
<A NAME="L3289"></A>
<P>Compares two element types.</P>

<HR>

<P>int TtaSameTypes(ElementType type1, ElementType type2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>type1</EM>: first element type.
<P><EM>type2</EM>: second element type.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both types are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc11320">11.3.20</A> TtaGetElementLabel</H4>
<A NAME="L3328"></A>
<P>Returns the label of a given element.</P>

<HR>

<P>char *TtaGetElementLabel(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>label of the element.
</DL>

<H4><A NAME="sectc11321">11.3.21</A> TtaIsConstant</H4>
<A NAME="L3360"></A>
<P>Indicates whether an element type is a constant.</P>

<HR>

<P>int TtaIsConstant(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: type to be tested.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 = the type is a constant, 0 = the type is not a constant.
</DL>

<H4><A NAME="sectc11322">11.3.22</A> TtaIsLeaf</H4>
<A NAME="L3392"></A>
<P>Indicates whether an element type is a leaf.</P>

<HR>

<P>int TtaIsLeaf(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: type to be tested.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the type is a leaf, 0 if the type is not a leaf.
</DL>

<H4><A NAME="sectc11323">11.3.23</A> TtaGetConstructOfType</H4>
<A NAME="L3426"></A>
<P>Returns the construct of an element type.</P>

<HR>

<P>Construct TtaGetConstructOfType(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: the element type of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the construct that defines the structure of that element type.
</DL>

<H4><A NAME="sectc11324">11.3.24</A> TtaGetConstruct</H4>
<A NAME="L3458"></A>
<P>Returns the construct of an element.</P>

<HR>

<P>Construct TtaGetConstruct(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the construct that defines the structure of that element.
</DL>

<H4><A NAME="sectc11325">11.3.25</A> TtaGetAccessRight</H4>
<A NAME="L3490"></A>
<P>Returns the access rights for a given element.</P>

<HR>

<P>AccessRight TtaGetAccessRight(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>access right for that element (ReadOnly, ReadWrite, Hidden, Inherited).
</DL>

<H4><A NAME="sectc11326">11.3.26</A> TtaIsHolophrasted</H4>
<A NAME="L3522"></A>
<P>Tests whether a given element is holphrasted or not.</P>

<HR>

<P>int TtaIsHolophrasted(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is holphrasted, 0 if not.
</DL>

<H4><A NAME="sectc11327">11.3.27</A> TtaIsReadOnly</H4>
<A NAME="L3555"></A>
<P>Tests whether a given element is protected against user modifications
(ReadOnly).</P>

<HR>

<P>int TtaIsReadOnly(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is protected, 0 if not.
</DL>

<H4><A NAME="sectc11328">11.3.28</A> TtaIsHidden</H4>
<A NAME="L3587"></A>
<P>Tests whether a given element is hidden to the user (Hidden).</P>

<HR>

<P>int TtaIsHidden(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is hidden, 0 if not.
</DL>

<H4><A NAME="sectc11329">11.3.29</A> TtaIsInAnInclusion</H4>
<A NAME="L3619"></A>
<P>Tests whether a given element is (in) an included element. An included
element is a "live" copy of another element.</P>

<HR>

<P>int TtaIsInAnInclusion(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element to be tested.
</DL>

<DL>
<DT>Return Value:</DT>

<DD>1 if the element is included, 0 if not.
</DL>

<H4><A NAME="sectc11330">11.3.30</A> TtaIsAncestor</H4>
<A NAME="L3652"></A>
<P>Tests if an element is an ancestor of another element.</P>

<HR>

<P>int TtaIsAncestor(Element element, Element ancestor)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: an element.
<P><EM>ancestor</EM>: the supposed ancestor of element.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if ancestor in an ancestor of element, 0 if not.
</DL>

<H4><A NAME="sectc11331">11.3.31</A> TtaIsBefore</H4>
<A NAME="L3690"></A>
<P>Tests if an element precedes another element in the preorder traversal of
the tree.</P>

<HR>

<P>int TtaIsBefore(Element element1, Element element2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element1</EM>: the first element.
<P><EM>element2</EM>: the second element.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the first element precedes the second element, 0 if not.
</DL>

<H4><A NAME="sectc11332">11.3.32</A> TtaIsFirstPairedElement</H4>
<A NAME="L3728"></A>
<P>Indicates if a given paired element is the first or the second of the
pair.</P>

<HR>

<P>int TtaIsFirstPairedElement(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the paired element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if it is the first element of the pair, 0 if it is the second.
</DL>

<H4><A NAME="sectc11333">11.3.33</A> <A
NAME="L32216">TtaCanInsertSibling</A></H4>
<A NAME="L32296"></A>
<P>Checks whether an element of a given type can be inserted in an abstract
tree as an immediate sibling of an existing element.</P>

<HR>

<P>ThotBool TtaCanInsertSibling(ElementType elementType, Element sibling,
ThotBool before, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: the element type to be checked.
<P><EM>sibling</EM>: an existing element which is part of an abstract
tree.</P>

<P><EM>before</EM>: if True, checks if insertion is allowed before element
"sibling".
If False, checks if insertion is allowed after element "sibling".</P>

<P><EM>document</EM>: the document to which element "sibling" belongs.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True if that element type can be inserted, False if the structure schema
does not allow that insertion.
</DL>

<H4><A NAME="sectc11334">11.3.34</A> <A
NAME="L32256">TtaCanInsertFirstChild</A></H4>
<A NAME="L32304"></A>
<P>Checks whether an element of a given type can be inserted in an abstract
tree as the first child of an existing element (parent).</P>

<HR>

<P>ThotBool TtaCanInsertFirstChild(ElementType elementType, Element parent,
Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: the element type to be checked.
<P><EM>parent</EM>: an existing element which is part of an abstract tree.</P>

<P><EM>document</EM>: the document to which element "parent" belongs.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True if that element type can be inserted, False if the structure schema
does not allow that insertion.
</DL>

<H4><A NAME="sectc11335">11.3.35</A> TtaGetDocument</H4>
<A NAME="L3760"></A>
<P>Returns the document containing a given element</P>

<HR>

<P>Document TtaGetDocument(Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element for which document is asked.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the document containing that element or 0 if the element has not been
inserted in any document.
</DL>

<H4><A NAME="sectc11336">11.3.36</A> TtaNextCopiedElement</H4>
<A NAME="L3793"></A>
<P>Returns one of the elements that have been copied into the ``clipboard'' by
the last Copy or Cut command. (This function is available only in the
ThotEditor library).</P>

<HR>

<P>void TtaNextCopiedElement(Element *element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: NULL if the first element of the clipboard is asked; an
element of the clipboard if the next one is asked.
</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>element</EM>: the asked element if it exists, or NULL if there is no
next element in the clipboard or if the clipboard is empty.
</DL>

<H4><A NAME="sectc11337">11.3.37</A> TtaGetCopiedDocument</H4>
<A NAME="L3826"></A>
<P>Returns the document from which the current content of the clipboard has
been copied or cut. (This function is available only in the ThotEditor
library).</P>

<HR>

<P>Document TtaGetCopiedDocument()</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>No parameter.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the document from which the current content of the clipboard has been
copied or cut; 0 if the clipboard is empty.
</DL>

<H3><A NAME="sectb114">11.4</A> Locators</H3>

<H4><A NAME="sectc1141">11.4.1</A> TtaSearchTypedElement</H4>
<A NAME="L3859"></A>
<P>Returns the first element of a given type. Searching can be done in a tree
or starting from a given element towards the beginning or the end of the
abstract tree.</P>

<HR>

<P>Element TtaSearchTypedElement(ElementType searchedType, SearchDomain scope,
Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedType</EM>: type of element to be searched. If
searchedType.ElSSchema is NULL, searchedType must be a basic type ; then the
next basic element of that type will be returned, whatever its structure
schema.
<P><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.</P>

<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if no element has been found.
</DL>

<H4><A NAME="sectc1142">11.4.2</A> TtaSearchTypedElementInTree</H4>
<A NAME="L57610"></A>
<P>Returns the first element of a given type. Searching can be done in a tree
or starting from a given element towards the beginning or the end of the
abstract tree.. In any case the returned element must be  part of the parent
tree.</P>

<HR>

<P>Element TtaSearchTypedElementInTree(ElementType searchedType, SearchDomain
scope, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedType</EM>: type of element to be searched. If
searchedType.ElSSchema is NULL, searchedType must be a basic type ; then the
next basic element of that type will be returned, whatever its structure
schema.
<P><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.</P>

<P><EM>parent</EM>: the limited tree where the searching can be done.</P>

<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if no element has been found.
</DL>

<H4><A NAME="sectc1143">11.4.3</A> TtaSearchElementByLabel</H4>
<A NAME="L3904"></A>
<P>Searches the element that has a given label. The search is done in a given
tree.</P>

<HR>

<P>Element TtaSearchElementByLabel(char *searchedLabel, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedLabel</EM>: label of element to be searched.
<P><EM>element</EM>: the element that is the root of the tree in which the
search is done.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if no element has been found.
</DL>

<H4><A NAME="sectc1144">11.4.4</A> TtaSearchEmptyElement</H4>
<A NAME="L3942"></A>
<P>Searches the next empty element. An empty element is either a compound
element without child or a leaf without content. Searching can be done in a
tree or starting from a given element towards the beginning or the end of the
abstract tree.</P>

<HR>

<P>Element TtaSearchEmptyElement(SearchDomain scope, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.
<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD>the element found, or NULL if not found.
</DL>

<H4><A NAME="sectc1145">11.4.5</A> TtaSearchOtherPairedElement</H4>
<A NAME="L3981"></A>
<P>Returns the element that is part of the same pair as a given element.</P>

<HR>

<P>Element TtaSearchOtherPairedElement(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element whose paired element is searched.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the paired element.
</DL>

<H4><A NAME="sectc1146">11.4.6</A> TtaSearchNoPageBreak</H4>
<A NAME="L4013"></A>
<P>Returns the first sibling element that is not a page break.</P>

<HR>

<P>Element TtaSearchNoPageBreak(Element element, ThotBool forward)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
<P><EM>forward</EM>: True for skipping the next page breaks, False for
skipping the previous ones.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the first sibling element, or NULL if there are only page breaks.
</DL>

<H3><A NAME="sectb115">11.5</A> Help</H3>

<H4><A NAME="sectc1151">11.5.1</A> <A
NAME="L4054">TtaListAbstractTree</A></H4>
<A NAME="L4055"></A>
<P>Produces in a file a human-readable form of an abstract tree.</P>

<HR>

<P>void TtaListAbstractTree(Element root, FILE *fileDescriptor)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>root</EM>: the root element of the tree to be listed.
<P><EM>fileDescriptor</EM>: file descriptor of the file that will contain the
list. This file must be open when calling the function.</P>

</DL>

<H2><A NAME="secta12">12</A> <A NAME="L4085">Contents</A></H2>

<P>The functions described in this section require that file
<EM>content.h</EM> be included in the module that calls them.</P>

<H3><A NAME="sectb121">12.1</A> Modificators</H3>

<H4><A NAME="sectc1211">12.1.1</A> TtaSetTextContent</H4>
<A NAME="L4100"></A>
<P>Changes the content of a Text basic element. The full content (if any) is
deleted and replaced by the new one. This function can also be used for
changing the content (the file name) of a Picture basic element.</P>

<HR>

<P>void TtaSetTextContent(Element element, char *content, Language language,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>content</EM>: new content for that element.</P>

<P><EM>language</EM>: language of that Text element (see section <A
HREF="#secta15">15</A>).</P>

<P><EM>document</EM>: the document containing that element.</P>

</DL>

<H4><A NAME="sectc1212">12.1.2</A> TtaAppendTextContent</H4>
<A NAME="L4144"></A>
<P>Appends a character string at the end of a Text basic element.</P>

<HR>

<P>void TtaAppendTextContent(Element element, char *content, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>content</EM>: the character string to be appended.</P>

<P><EM>document</EM>: the document containing that element.</P>

</DL>

<H4><A NAME="sectc1213">12.1.3</A> TtaInsertTextContent</H4>
<A NAME="L4181"></A>
<P>Inserts a character string in a text basic element.</P>

<HR>

<P>void TtaInsertTextContent(Element element, int position, char *content,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>position</EM>: rank of the character after which the new string must be
inserted. 0 for inserting before the first character.</P>

<P><EM>content</EM>: the character string to be inserted.</P>

<P><EM>document</EM>: the document containing the text element.</P>

</DL>

<H4><A NAME="sectc1214">12.1.4</A> TtaDeleteTextContent</H4>
<A NAME="L4223"></A>
<P>Deletes a character string in a text basic element.</P>

<HR>

<P>void TtaDeleteTextContent(Element element, int position, int length,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Text element to be modified.
<P><EM>position</EM>: rank of the first character to be deleted.</P>

<P><EM>length</EM>: length of the character string to be deleted.</P>

<P><EM>document</EM>: the document containing the text element.</P>

</DL>

<H4><A NAME="sectc1215">12.1.5</A> TtaSplitText</H4>
<A NAME="L4266"></A>
<P>Divides a text element into two elements.</P>

<HR>

<P>void TtaSplitText(Element element, int position, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the text element to be divided. A new text element
containing the second part of the text is created as the next sibling.
<P><EM>position</EM>: rank of the character after which the element must be
cut.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1216">12.1.6</A> TtaMergeText</H4>
<A NAME="L4302"></A>
<P>Merges two text elements.</P>

<HR>

<P>void TtaMergeText(Element element, Document document)</P>

<HR>

<PRE>
void TtaMergeText(element, document)
Element element;
Document document;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the first text element. Merging occurs only if
<P>the next sibling is a text element with the same attributes.</P>

<P><EM>document</EM>: the document to which the text element belongs.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>True if successful..
</DL>

<H4><A NAME="sectc1217">12.1.7</A> TtaSetGraphicsShape</H4>
<A NAME="L4343"></A>
<P>Changes the shape of a Graphics or Symbol basic element.</P>

<HR>

<P>void TtaSetGraphicsShape(Element element, char shape, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Graphics or Symbol.
<P><EM>shape</EM>: new shape for that element.</P>

<P><EM>document</EM>: the document containing that element.</P>

</DL>

<H4><A NAME="sectc1218">12.1.8</A> TtaAddPointInPolyline</H4>
<A NAME="L4380"></A>
<P>Adds a new point in a Polyline basic element.</P>

<HR>

<P>void TtaAddPointInPolyline(Element element, int rank, TypeUnit unit, int x,
int y, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the new point to be inserted. If rank is greater
than the actual number of points, the new point is appended. rank must be
strictly positive.</P>

<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

<P>x, y: coordinate of the new point, in units, relatively to the upper left
corner of the box. x and y must be positive or null.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc1219">12.1.9</A> TtaDeletePointInPolyline</H4>
<A NAME="L4421"></A>
<P>Deletes a point in a Polyline basic element.</P>

<HR>

<P>void TtaDeletePointInPolyline(Element element, int rank, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the point to be deleted. If rank is greater than the
actual number of points, the last point is deleted. rank must be strictly
positive.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc12110">12.1.10</A> TtaModifyPointInPolyline</H4>
<A NAME="L4457"></A>
<P>Changes the coordinates of a point in a Polyline basic element.</P>

<HR>

<P>void TtaModifyPointInPolyline(Element element, int rank, TypeUnit unit, int
x, int y, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the point to be modified. If rank is greater than
the actual number of points, the last point is changed. rank must be strictly
positive.</P>

<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

<P>x, y: new coordinates of the point, in units, relatively to the upper left
corner of the enclosing rectangle. x and y must be positive or null.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc12111">12.1.11</A> TtaChangeLimitOfPolyline</H4>
<A NAME="L4499"></A>
<P>Changes the coordinates of the lower left corner of the box containing a
Polyline basic element.</P>

<HR>

<P>void TtaChangeLimitOfPolyline(Element element, TypeUnit unit, int x, int y,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to be changed. This element must be a basic
element of type Polyline.
<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

<P>x, y: new coordinates of the lower left corner, in units, relatively to the
upper left corner of the box. x and y must be positive or null and the box
must contain all points of the polyline.</P>

<P><EM>document</EM>: the document containing the polyline element.</P>

</DL>

<H4><A NAME="sectc12112">12.1.12</A> TtaCopyPage</H4>
<A NAME="L4534"></A>
<P>Copies the page element source into the page element destination. Both page
elements must be in an abstract tree.</P>

<HR>

<P>void TtaCopyPage(Element destination, Element source)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>destination</EM>: identifier of the page element to be modified.
<P><EM>source</EM>: identifier of the source page element.</P>

</DL>

<H3><A NAME="sectb122">12.2</A> Accessors</H3>

<H4><A NAME="sectc1221">12.2.1</A> TtaGetVolume</H4>
<A NAME="L57000"></A>
<P>Returns the volume of an element. The volume of an element is the number of
characters needed to code the element contents. For a simple text element, it
is the text length. For a picture, it is the length of the file path. For a
constructed element, it is the sum of basic elements volumes.</P>

<HR>

<P>int TtaGetVolume(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>number of characters contined in the element.
</DL>

<H4><A NAME="sectc1222">12.2.2</A> TtaGetPictureType</H4>

<P>Returns the type of Picture element. The type is one of the following
values: xbm_type, eps_type, xpm_type, gif_type, jpeg_type, png_type,
unknow_type.</P>

<HR>

<P>PicType TtaGetPictureType(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a picture
element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>The type of the element.
</DL>

<H4><A NAME="sectc1223">12.2.3</A> TtaGetTextLength</H4>
<A NAME="L4570"></A>
<P>Returns the length of a Text basic element.</P>

<HR>

<P>int TtaGetTextLength(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Text.
</DL>

<DL>
<DT>Return value:</DT>

<DD>length (number of characters) of the character string contained in the
element. The null character terminating a C string is not counted.
</DL>

<H4><A NAME="sectc1224">12.2.4</A> TtaGiveTextContent</H4>
<A NAME="L4602"></A>
<P>Returns the content of a Text basic element.</P>

<HR>

<P>void TtaGiveTextContent(Element element, char *buffer, int *length,
Language *language)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Text.
<P><EM>buffer</EM>: the buffer that will contain the text.</P>

<P><EM>length</EM>: maximum length of that buffer.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>buffer</EM>: (the buffer contains the text, including the terminating
null character).
<P><EM>length</EM>: actual length of the text in the buffer, excluding the
null character terminating the string.</P>

<P><EM>language</EM>: language of the text (see section <A
HREF="#secta15">15</A>).</P>

</DL>

<H4><A NAME="sectc1225">12.2.5</A> TtaGiveSubString</H4>
<A NAME="L4660"></A>
<P>Returns a substring from a Text basic element.</P>

<HR>

<P>void TtaGiveSubString(Element element, char *buffer, int position, int
length)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Text.
<P><EM>buffer</EM>: the buffer that will contain the substring. This buffer
must be at least of size length.</P>

<P><EM>position</EM>: the rank of the first character of the substring. rank
must be strictly positive.</P>

<P><EM>length</EM>: the length of the substring. Must be strictly
positive.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>buffer</EM>: (the buffer contains the substring).
</DL>

<H4><A NAME="sectc1226">12.2.6</A> TtaGetGraphicsShape</H4>
<A NAME="L4711"></A>
<P>Returns the content of a Graphics or Symbol basic element.</P>

<HR>

<P>char TtaGetGraphicsShape(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element of interest. This element must be a basic
element of type Graphics or Symbol.
</DL>

<DL>
<DT>Return value:</DT>

<DD>a single character representing the shape of the graphics element or
symbol contained in the element.
</DL>

<H4><A NAME="sectc1227">12.2.7</A> TtaGetPolylineLength</H4>
<A NAME="L4744"></A>
<P>Returns the number of points in a Polyline basic element.</P>

<HR>

<P>int TtaGetPolylineLength(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the Polyline element. This element must be a basic
element of type Polyline.
</DL>

<H4><A NAME="sectc1228">12.2.8</A> TtaGivePolylinePoint</H4>
<A NAME="L4768"></A>
<P>Returns the coordinates of a point in a Polyline basic element.</P>

<HR>

<P>void TtaGivePolylinePoint(Element element, int rank, TypeUnit unit, int *x,
int *y)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the Polyline element. This element must be a basic
element of type Polyline.
<P><EM>rank</EM>: rank of the point in the PolyLine. If rank is greater than
the actual number of points, an error is raised. rank must be strictly
positive.</P>

<P><EM>unit</EM>: the absolute unit (UnPixel or UnPoint) used for the
values.</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD>x, y: coordinates of the point, in units, relatively to the upper left
corner of the enclosing rectangle.
</DL>

<H4><A NAME="sectc1229">12.2.9</A> TtaGetPageNumber</H4>
<A NAME="L4810"></A>
<P>Returns the page number of a Page basic element.</P>

<HR>

<P>int TtaGetPageNumber(Element pageElement)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>pageElement</EM>: the page element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>page number of that page element.
</DL>

<H4><A NAME="sectc12210">12.2.10</A> TtaGetPageView</H4>
<A NAME="L4842"></A>
<P>Returns the view corresponding to a Page basic element.</P>

<HR>

<P>int TtaGetPageView(Element pageElement)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>pageElement</EM>: the page element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>view of that page.
</DL>

<H2><A NAME="secta13">13</A> <A NAME="L4874">Logical attributes</A></H2>

<P>The functions described in this section require that file
<EM>attribute.h</EM> be included in the module that calls them.</P>

<P>When creating or searching attributes in an abstract tree, the type of the
concerned attributes must be given. As presented in section <A
HREF="#secta4">4</A>, an attribute type contains an attribute number, but this
number does not appear explicitly in a structure schema: it is generated by
the schema compiler. For obtaining all attribute numbers of a structure
schema, use the command:
<EM>       printsch -h SchemaName
</EM>which lists on the standard output a file that can be included into a C
program.</P>

<P>When a new attribute is created (function <A
NAME="L4893"></A>TtaNewAttribute), it must be attached (function <A
NAME="L4897"></A>TtaAttachAttribute) to an element which is itself part of an
abstract tree of a document, before any other action can be performed on that
attribute.</P>

<H3><A NAME="sectb131">13.1</A> Constructors</H3>

<H4><A NAME="sectc1311">13.1.1</A> TtaNewAttribute</H4>
<A NAME="L4907"></A>
<P>Creates an attribute that will be attached to an element.</P>

<HR>

<P>Attribute TtaNewAttribute(AttributeType attributeType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attributeType</EM>: type of the attribute to be created.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the attribute that has been created.
</DL>

<H4><A NAME="sectc1312">13.1.2</A> TtaAttachAttribute</H4>
<A NAME="L4940"></A>
<P>Attaches an attribute to an element.</P>

<HR>

<P>void TtaAttachAttribute(Element element, Attribute attribute, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to which the attribute has to be attached.
<P><EM>attribute</EM>: the attribute to be attached.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1313">13.1.3</A> TtaRemoveAttribute</H4>
<A NAME="L4976"></A>
<P>Removes an attribute from an element and release that attribute.</P>

<HR>

<P>void TtaRemoveAttribute(Element element, Attribute attribute, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element with which the attribute is associated.
<P><EM>attribute</EM>: the attribute to be removed.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H3><A NAME="sectb132">13.2</A> Modificators</H3>

<H4><A NAME="sectc1321">13.2.1</A> TtaSetAttributeValue</H4>
<A NAME="L5016"></A>
<P>Changes the value of an attribute of type integer or enumerate.</P>

<HR>

<P>void TtaSetAttributeValue(Attribute attribute, int value, Element element,
Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute to be modified.
<P><EM>value</EM>: new value of the attribute.</P>

<P><EM>element</EM>: the element with which the attribute is associated, NULL
if the attribute is not yet associated with an element.</P>

<P><EM>document</EM>: the document to which the element belongs. Must be 0 if
element is NULL.</P>

</DL>

<H4><A NAME="sectc1322">13.2.2</A> TtaSetAttributeText</H4>
<A NAME="L5059"></A>
<P>Changes the value of an attribute of type text.</P>

<HR>

<P>void TtaSetAttributeText(Attribute attribute, char *buffer, Element
element, Document document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute to be modified.
<P><EM>buffer</EM>: character string representing the new value of the
attribute.</P>

<P><EM>element</EM>: the element with which the attribute is associated, NULL
if the attribute is not yet associated with an element.</P>

<P><EM>document</EM>: the document to which the element belongs. Must be 0 if
element is NULL.</P>

</DL>

<H3><A NAME="sectb133">13.3</A> Accessors</H3>

<H4><A NAME="sectc1331">13.3.1</A> TtaNextAttribute</H4>
<A NAME="L5105"></A>
<P>Returns the first attribute associated with a given element (if attribute
is NULL) or the attribute that follows a given attribute of a given
element.</P>

<HR>

<P>void TtaNextAttribute(Element element, Attribute *attribute)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>attribute</EM>: an attribute of that element, or NULL if the first
attribute is asked.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>attribute</EM>: the next attribute, or NULL if attribute is the last
attribute of the element.
</DL>

<H4><A NAME="sectc1332">13.3.2</A> TtaGetAttribute</H4>
<A NAME="L5145"></A>
<P>Returns an attribute of a given type associated with a given element.</P>

<HR>

<P>Attribute TtaGetAttribute(Element element, AttributeType 
attributeType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>attributeType</EM>: type of the desired attribute.. If the attribute
"Language" is searched, attributeType.AttrTypeNum must be 1. If the attribute
"Language" is searched whatever its structure schema,
attributeType.AttrSSchema must be NULL. A NULL attributeType.AttrSSchema is
accepted only when an attribute "Language" is searched.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the attribute found, or NULL if the element does not have this type of
attribute.
</DL>

<H4><A NAME="sectc1333">13.3.3</A> TtaGiveAttributeType</H4>
<A NAME="L5183"></A>
<P>Returns the type of a given attribute.</P>

<HR>

<P>void TtaGiveAttributeType(Attribute attribute, AttributeType 
attributeType, int *attrKind)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
<P><EM>attrKind</EM>: kind of the attribute: 0 = Enumerate, 1 = Integer, 2 =
Text, 3 = Reference</P>

</DL>

<H4><A NAME="sectc1334">13.3.4</A> TtaGiveAttributeTypeFromName</H4>
<A NAME="L5224"></A>
<P>Retrieves the type of an attribute from its name.</P>

<HR>

<P>void TtaGiveAttributeTypeFromName(char *name, Element element,
AttributeType  *attributeType, int *attrKind)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: name of the attribute.
<P><EM>element</EM>: the element with which the attribute is associated.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
<P><EM>attrKind</EM>: kind of the attribute: 0 = Enumerate, 1 = Integer, 2 =
Text, 3 = Reference</P>

</DL>

<H4><A NAME="sectc1335">13.3.5</A> TtaGiveAttributeTypeFromOriginalName</H4>
<A NAME="L56928"></A>
<P>Retrieves the type of an attribute from its original name (in the language
it is defined in the structure schema).</P>

<HR>

<P>void TtaGiveAttributeTypeFromOriginalName(char *name, Element element,
AttributeType  *attributeType, int *attrKind)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: original name of the attribute.
<P><EM>element</EM>: the element with which the attribute is associated.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
<P><EM>attrKind</EM>: kind of the attribute: 0 = Enumerate, 1 = Integer, 2 =
Text, 3 = Reference</P>

</DL>

<H4><A NAME="sectc1336">13.3.6</A> TtaGetAttributeName</H4>
<A NAME="L5272"></A>
<P>Returns the name of an attribute type.</P>

<HR>

<P>char *TtaGetAttributeName(AttributeType attributeType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that type.
</DL>

<H4><A NAME="sectc1337">13.3.7</A> TtaGetAttributeOriginalName</H4>
<A NAME="L56968"></A>
<P>Returns the original name of an attribute type (in the language it is
defined in the structure schema).</P>

<HR>

<P>char *TtaGetAttributeOriginalName(AttributeType attributeType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attributeType</EM>: type of the attribute.
</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that type.
</DL>

<H4><A NAME="sectc1338">13.3.8</A> TtaSameAttributeTypes</H4>
<A NAME="L5304"></A>
<P>Compares two attribute types.</P>

<HR>

<P>int TtaSameAttributeTypes(AttributeType type1, AttributeType type2)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>type1</EM>: first attribute type.
<P><EM>type2</EM>: second attribute type.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both types are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc1339">13.3.9</A> TtaGetAttributeValue</H4>
<A NAME="L5342"></A>
<P>Returns the value of a given attribute of type integer or enumerate.</P>

<HR>

<P>int TtaGetAttributeValue(Attribute attribute)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>Value of that attribute.
</DL>

<H4><A NAME="sectc13310">13.3.10</A> TtaGetAttributeValueName</H4>
<A NAME="L57254"></A>
<P>Returns the name of a value of an attribute of type enumerate.</P>

<HR>

<P>char *TtaGetAttributeValueName (AttributeType attributeType, intvalue);</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>
<P><EM>attributeType</EM>: type of the the attribute of interest.</P>

<P><EM>value</EM>: the value of interest.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>name of that value or empty string if error.
</DL>

<H4><A NAME="sectc13311">13.3.11</A> TtaGetAttributeValueFromName</H4>
<A NAME="L57288"></A>
<P>Retrieves the int value of an attribute of type enumerate from its
name.</P>

<HR>

<P>int TtaGetAttributeValueFromName (char *name, AttributeType
attributeType);</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: name of the value of interest.
<P><EM>attributeType</EM>: type of the the attribute of interest.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the corresponding int value, or 0 if error.
</DL>

<H4><A NAME="sectc13312">13.3.12</A> TtaGetTextAttributeLength</H4>
<A NAME="L5375"></A>
<P>Returns the length of a given attribute of type text.</P>

<HR>

<P>int TtaGetTextAttributeLength(Attribute attribute)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return values:</DT>

<DD>length of the character string contained in the attribute.
</DL>

<H4><A NAME="sectc13313">13.3.13</A> TtaGiveTextAttributeValue</H4>
<A NAME="L5407"></A>
<P>Returns the value of a given attribute of type text.</P>

<HR>

<P>void TtaGiveTextAttributeValue(Attribute attribute, char *buffer, int
*length)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
<P><EM>buffer</EM>: address of the buffer that will contain the value of the
attribute.</P>

<P><EM>length</EM>: size of the buffer (in bytes).</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD><EM>buffer</EM>: character string representing the value of the attribute.
<P><EM>length</EM>: actual length of the character string.</P>

</DL>

<H3><A NAME="sectb134">13.4</A> Locators</H3>

<H4><A NAME="sectc1341">13.4.1</A> TtaSearchAttribute</H4>
<A NAME="L5460"></A>
<P>Searches the next element that has a given attribute. Searching can be done
in a subtree or starting from a given element towards the beginning or the end
of the abstract tree.</P>

<HR>

<P>void TtaSearchAttribute(AttributeType searchedAttribute, SearchDomain
scope, Element element, Element *elementFound, Attribute *attributeFound)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>searchedAttribute</EM>: attribute to be searched. If
searchedAttribute.AttrSSchema is NULL, the next element that has an attribute
is seached, whatever the attribute.
<P><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.</P>

<P><EM>element</EM>: the element that is the root of the tree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>elementFound</EM>: the element found, or NULL if not found.
<P><EM>attributeFound</EM>: the searched attribute, or NULL if not found.</P>

</DL>

<H2><A NAME="secta14">14</A> <A NAME="L5513">References and links</A></H2>

<P>The functions described in this section require that file
<EM>reference.h</EM> be included in the module that calls them.</P>

<H3><A NAME="sectb141">14.1</A> Modificators</H3>

<H4><A NAME="sectc1411">14.1.1</A> TtaSetReference</H4>
<A NAME="L5528"></A>
<P>Changes (or sets) the target of a reference element. The reference element
must be part of an abstract tree.</P>

<HR>

<P>void TtaSetReference(Element element, Document document, Element target,
Document targetDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the reference element to be set.
<P><EM>document</EM>: the document containing the reference element.</P>

<P><EM>target</EM>: the target element (NULL for resetting the reference).</P>

<P><EM>targetDocument</EM>: the document containing the target element.</P>

</DL>

<H4><A NAME="sectc1412">14.1.2</A> TtaNewInclusion</H4>
<A NAME="L5571"></A>
<P>Creates an inclusion of a given element.</P>

<HR>

<P>Element TtaNewInclusion(Document document, Element target, Document
targetDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the inclusion is created.
<P><EM>target</EM>: the element to be included.</P>

<P><EM>targetDocument</EM>: the document containing the element to be
included.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the created inclusion.
</DL>

<H4><A NAME="sectc1413">14.1.3</A> TtaCopyReference</H4>
<A NAME="L5615"></A>
<P>Copies a reference element into another reference element. Both reference
elements must be in an abstract tree.</P>

<HR>

<P>void TtaCopyReference(Element element, Element source, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the reference element to be set.
<P><EM>source</EM>: the element to be copied.</P>

<P><EM>document</EM>: the concerned document.</P>

</DL>

<H4><A NAME="sectc1414">14.1.4</A> TtaSetAttributeReference</H4>
<A NAME="L5645"></A>
<P>Changes the value of an attribute of type reference</P>

<HR>

<P>void TtaSetAttributeReference(Attribute attribute, Element element,
Document document, Element target, Document targetDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the attribute to be changed.
<P><EM>element</EM>: the element with which the attribute is associated.</P>

<P><EM>document</EM>: the document containing the attribute.</P>

<P><EM>target</EM>: the target element (NULL for resetting the reference).</P>

<P><EM>targetDocument</EM>: the document containing the target element.</P>

</DL>

<H4><A NAME="sectc1415">14.1.5</A> TtaCopyAttributeReference</H4>
<A NAME="L5694"></A>
<P>Copies the reference attribute source into the reference attribute
attribute. Both attributes must be attached to an element in an abstract
tree.</P>

<HR>

<P>void TtaCopyAttributeReference(Attribute attribute, Element element,
Attribute source)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute</EM>: the reference attribute to be set.
<P><EM>element</EM>: the element to which attribute is attached.</P>

<P><EM>source</EM>: the source attribute.</P>

</DL>

<H4><A NAME="sectc1416">14.1.6</A> TtaCopyIncludedElem</H4>
<A NAME="L46842"></A>
<P>Up to date the value of inclusion element with the value of its source.</P>

<HR>

<P>void     TtaCopyIncludedElem( Element element, Document document)</P>

<HR>

<DL>
<DT>Parameters</DT>

<DD><I>element</I>: the element to be up to dated.
<P><I>document</I>: the document that contains the element.</P>

</DL>

<H4><A NAME="sectc1417">14.1.7</A> TtaUpdateInclusionElements</H4>
<A NAME="L43583"></A>
<P>Up to date the value of inclusions that belong to the document.</P>

<P>If loadExternalDoc is TRUE, the inclusions whose the sources belong to
another document, are up to date too. In this case, the other documents are
opened temporarely. If removeExclusions is TRUE, the exclusions are removed
from the documents opened temporarely.</P>

<HR>

<P>void  TtaUpdateInclusionElements(Document document, ThotBool
loadExternalDoc, ThotBool removeExclusions)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><I>document</I>: the document in question.
<P><I>loadExternalDoc</I>: TRUE if it is necessary to up to date the
inclusions whose the sources belong to another (external) document.</P>

<P><I>removeExclusions</I>: TRUE if exclusions of external documents have to
be removed when these ones are temporarely opened.</P>

</DL>

<H3><A NAME="sectb142">14.2</A> Accessors</H3>

<H4><A NAME="sectc1421">14.2.1</A> TtaGiveReferredElement</H4>
<A NAME="L5735"></A>
<P>Returns the element referred by a given reference element.</P>

<HR>

<P>void TtaGiveReferredElement(Element element, Element *target, char
*targetDocumentName, Document *targetDocument)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the reference element.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>target</EM>: the referred element, or NULL if that element is not
accessible (empty reference or referred document not open).
<P><EM>targetDocumentName</EM>: name of the document containing the referred
element; empty string if the referred element is in the same document as the
reference element.</P>

<P><EM>targetDocument</EM>: the document containing the referred element; 0 if
the document containing the referred element is not loaded or if the referred
element is in the same document as the reference element.</P>

</DL>

<H4><A NAME="sectc1422">14.2.2</A> TtaIsElementTypeReference</H4>
<A NAME="L5783"></A>
<P>Indicates whether an element type is a reference.</P>

<HR>

<P>int TtaIsElementTypeReference(ElementType elementType)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>elementType</EM>: type to be tested.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 = the type is a reference, 0 = the type is not a reference.
</DL>

<H4><A NAME="sectc1423">14.2.3</A> TtaSameReferences</H4>
<A NAME="L5815"></A>
<P>Compares two reference elements.</P>

<HR>

<P>int TtaSameReferences(Element element1, Element element2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element1</EM>: first reference element.
<P><EM>element2</EM>: second reference element.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both references are different, 1 if they are identical.
</DL>

<H4><A NAME="sectc1424">14.2.4</A> TtaGiveReferenceAttributeValue</H4>
<A NAME="L5853"></A>
<P>Returns the value of a given attribute of type reference</P>

<HR>

<P>void TtaGiveReferenceAttributeValue(Attributeattribute, Element *target,
char *targetDocumentName, Document *targetDocument)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>attribute</EM>: the attribute of interest.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>target</EM>: the element referred by the attribute, or NULL if that
element is not accessible (empty reference or referred document not loaded)
<P><EM>targetDocumentName</EM>: name of the document containing the referred
element; empty string if the referred element is in the same document as the
attribute.</P>

<P><EM>targetDocument</EM>: the document containing the referred element; 0 if
the document containing the referred element is not loaded or if the referred
element is in the same document as the attribute.</P>

</DL>

<H4><A NAME="sectc1425">14.2.5</A> TtaIsElementReferred</H4>
<A NAME="L5901"></A>
<P>Tells whether a given element is the target of a reference or not.</P>

<HR>

<P>int TtaIsElementReferred(Element element)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>element</EM>: the element.
</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the element is referred by another element or an attribute, 0 if not.
</DL>

<H4><A NAME="sectc1426">14.2.6</A> TtaSameReferenceAttributes</H4>
<A NAME="L5933"></A>
<P>Compares two reference attributes.</P>

<HR>

<P>int TtaSameReferenceAttributes(Attribute attribute1, Attribute
attribute2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>attribute1</EM>: first reference attribute.
<P><EM>attribute2</EM>: second reference attribute.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both references are different, 1 if they are identical.
</DL>

<H3><A NAME="sectb143">14.3</A> Locators</H3>

<H4><A NAME="sectc1431">14.3.1</A> TtaNextLoadedReference</H4>
<A NAME="L5976"></A>
<P>Searches a reference that has a given element as a target and that belongs
to a document currently loaded.</P>

<HR>

<P>void TtaNextLoadedReference(Element target, Document targetDocument,
Element *referenceElement, Attribute *referenceAttribute, Document
*referenceDocument)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>target</EM>: the target element.
<P><EM>targetDocument</EM>: the document to which the target element
belongs.</P>

<P><EM>referenceElement</EM>: previous element found by the function; NULL if
the first reference is searched. (Both referenceElement and referenceAttribute
must be NULL if the first reference is searched.)</P>

<P><EM>referenceAttribute</EM>: previous reference attribute found; NULL if
the first reference is searched or if the previous reference found by the
function was an element.</P>

<P><EM>referenceDocument</EM>: document to which the previous reference found
belongs; Zero if the first reference is searched.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>referenceAttribute</EM>: the reference attribute found. NULL if the
reference found is an element or if no reference is found.
<P><EM>referenceElement</EM>: the element found. If referenceAttribute is
NULL, this element is a reference element, else it is the element with which
the reference attribute found is associated. If both referenceAttribute and
referenceElement are NULL, then no reference has been found.</P>

<P><EM>referenceDocument</EM>: the document to which the reference found
belongs. Zero if no reference has been found.</P>

</DL>

<H4><A NAME="sectc1432">14.3.2</A> TtaNextUnloadedReferringDocument</H4>
<A NAME="L6042"></A>
<P>Returns the name of a document that is not currently loaded and that
contains references to a given target element.</P>

<HR>

<P>void TtaNextUnloadedReferringDocument(Element target, Document
targetDocument, char *referringDocumentName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>target</EM>: the target element.
<P><EM>targetDocument</EM>: the document to which the target element
belongs.</P>

<P><EM>referringDocumentName</EM>: name of the previous document found. Empty
string if the first referring document is searched.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>referringDocumentName</EM>: name of the document found. Empty string
if no referring document has been found.
</DL>

<H4><A NAME="sectc1433">14.3.3</A> TtaSearchReferenceElement</H4>
<A NAME="L6087"></A>
<P>Searches the next reference element. Searching can be done in a subtree or
starting from a given element towards the beginning or the end of the abstract
tree.</P>

<HR>

<P>Element TtaSearchReferenceElement(SearchDomain scope, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>scope</EM>: SearchForward, SearchBackward or SearchInTree.
<P><EM>element</EM>: the element that is the root of the subtree (if scope =
SearchInTree) or the starting element (if scope = SearchForward or
SearchBackward).</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the element found, or NULL if not found.
</DL>

<H2><A NAME="secta15">15</A> <A NAME="L6125">Languages</A></H2>

<P>Group language contains the functions for managing natural languages. These
functions require that file <EM>language.h</EM> be included in the module that
calls them.</P>

<P>Thot needs to know in which language each basic text element is written,
for instance for hyphenating words or for checking the spelling. Therefore, an
attribute called Language is defined by default in each structure schema and
it can be associated with any element (see section <A HREF="#secta13">13</A>).
A text element inherits the language specified by it first ancestor having a
Language attribute, unless it carries its own Language attribute.</P>

<P>The tool kit maintains a table of all languages used in the documents that
it handles. Each language has a name and an associated alphabet. Other
information may be associated to a language, such as a dictionary (for
hyphenation or spelling checking). A language is identified by an identifier
of type <EM>Language</EM>.</P>

<P>There are five predefined languages, whose names are : ISO_latin_1,
Fran&ccedil;ais, English, Symbol and Greek. ``Languages'' ISO_latin_1 and
Symbol are not natural languages in the same sense as Fran&ccedil;ais, English
or Greek. They are used when a character string must be written in the
corresponding alphabet, but is not candidate to such linguistic processing as
word hyphenation or spelling checking. For instance, a piece of C program
should be considered as written in the language ISO_latin_1; a mathematical
symbol such as  or  should be considered as written in the language
Symbol.</P>

<P>Other predefined languages, called <EM>typographic languages</EM>, are used
by a typographic checker (acronym, short, expo). The tool kit maintains a
table of all typographic languages used in the documents that it handles. Each
typographic language has a name and an associated alphabet. Other information
may be associated to a language, such as a dictionary (for typographic
checking). A typographic language is identified by an identifier of type
<EM>Language</EM>.</P>

<H3><A NAME="sectb151">15.1</A> Constructors</H3>

<H4><A NAME="sectc1511">15.1.1</A> <A NAME="L6156">TtaNewLanguage</A></H4>
<A NAME="L6157"></A>
<P>Declares a new language, its alphabet and optionally the names of the
principal and secondary dictionaries. All languages used in a Thot document
must be explicitly declared, except for predefined languages. Thot registers
all declared languages and allocates a different identifier to each of them.
his function does not load dictionaries but loads their name. If
<EM>principalDictionary</EM> and/or <EM>secondDictionary</EM> are not NULL
values, dictionaries are loaded when necessary from files
$DICOPAR/principalDictionary and or $DICOPAR/secondDictionary. If an
application redeclares an existing language, this new declaration has no
effect.</P>

<HR>

<P>Language TtaNewLanguage(char *languageName, char languageAlphabet, char
*principalDictionary, char *secondDictionary)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageName</EM>: name of the language.
<P><EM>languageAlphabet</EM>: alphabet to be used for writing that
language:</P>

<P>`L' for ISO-Latin-1, `G' for Symbol (Greek).</P>

<P><EM>principalDictionary</EM>: name of the principal dictionary or NULL.</P>

<P><EM>secondDictionary</EM>: name of the secondary dictionary or NULL.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>identifier of the new language or 0 if the language cannot be added.
</DL>

<H4><A NAME="sectc1512">15.1.2</A> TtaRemoveLanguage</H4>
<A NAME="L36560"></A>
<P>Remove a language from the Thot language table. The removed language may be
a predefined language or a language added by TtaNewLanguage (see section <A
HREF="#sectc1511">15.1.1</A>).</P>

<HR>

<P>void TtaRemoveLanguage(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the language to be removed.
</DL>

<H4><A NAME="sectc1513">15.1.3</A> TtaLoadLanguageDictionaries</H4>
<A NAME="L6220"></A>
<P>Loads the dictionary associated with a language, if it is not loaded yet
and registers that a dictionary associated with this language has been
loaded.</P>

<HR>

<P>ThotBool TtaLoadLanguageDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: name of the concerned language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>-1 if the mandatory dictionary can not be loaded.
<P>0 if no dictionary has been loaded.</P>

<P>1 if the mandatory dictionary is loaded.</P>

</DL>

<H4><A NAME="sectc1514">15.1.4</A> TtaUnLoadLanguageDictionaries</H4>
<A NAME="L6258"></A>
<P>Unloads dictionaries associated with a given language.</P>

<HR>

<P>void TtaUnLoadLanguageDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the language.
</DL>

<H4><A NAME="sectc1515">15.1.5</A> TtaLoadTypoDictionaries</H4>
<A NAME="L13840"></A>
<P>Loads the dictionary associated with a typographic language, if it is not
loaded yet and registers that a dictionary associated with this typographic
language has been loaded.</P>

<HR>

<P>ThotBool TtaLoadTypoDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the concerned typographic language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>-1 if the mandatory dictionary can not be loaded.
<P>0 if no dictionary has been loaded.</P>

<P>1 if the mandatory dictionary is loaded.</P>

</DL>

<H4><A NAME="sectc1516">15.1.6</A> TtaUnLoadTypoDictionaries</H4>
<A NAME="L13878"></A>
<P>Unloads dictionaries associated with a given typographic language.</P>

<HR>

<P>void TtaUnLoadTypoDictionaries(Language languageId)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>languageId</EM>: identifier of the concerned typographic language.
</DL>

<H3><A NAME="sectb152">15.2</A> Accessors</H3>

<H4><A NAME="sectc1521">15.2.1</A> TtaGetLanguageIdFromName</H4>
<A NAME="L6287"></A>
<P>Returns the identifier of a language that matches a language name. If this
language name is unknown, returns the identifier of a typographic language
that matches this language name..</P>

<HR>

<P>Language TtaGetLanguageIdFromName(char *languageName)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageName</EM>: name of the language or of the typographic
language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>identifier of that language or of the typographic language or 0 if the
language is unknown.
</DL>

<H4><A NAME="sectc1522">15.2.2</A> TtaGetDefaultLanguage</H4>
<A NAME="L6319"></A>
<P>Returns the identifier of the default language.</P>

<HR>

<P>Language TtaGetDefaultLanguage()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>identifier of the default language.
</DL>

<H4><A NAME="sectc1523">15.2.3</A> TtaGetLanguageIdFromAlphabet</H4>
<A NAME="L6340"></A>
<P>Returns the identifier of the first language that uses a given
alphabet.</P>

<HR>

<P>Language TtaGetLanguageIdFromAlphabet(char *languageAlphabet)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageAlphabet</EM>: the alphabet of interest (`L' = latin, `G' =
greek).
</DL>

<DL>
<DT>Return value:</DT>

<DD>identifier of that language or 0 if the language is unknown.
</DL>

<H4><A NAME="sectc1524">15.2.4</A> TtaGetAlphabet</H4>
<A NAME="L6372"></A>
<P>Returns the alphabet associated with a given language.</P>

<HR>

<P>char TtaGetAlphabet(Language languageId)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageId</EM>: name of the language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>a character that identifies the alphabet (`L' = latin, `G' = greek).
</DL>

<H4><A NAME="sectc1525">15.2.5</A> TtaGetLanguageName</H4>
<A NAME="L6405"></A>
<P>Returns the name of a given language.</P>

<HR>

<P>char *TtaGetLanguageName(Language languageId)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>languageId</EM>: identifier of the language.
</DL>

<DL>
<DT>Return value:</DT>

<DD>the name of the language.
</DL>

<H4><A NAME="sectc1526">15.2.6</A> TtaGetLanguageNameFromCode</H4>
<A NAME="L36161"></A>
<P>Returns the name of a language whose RFC-1766 code is known</P>

<HR>

<P>char *TtaGetLanguageNameFromCode (char *code)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>code</EM>: code of the language, according to RFC-1766, a superset of
ISO-639
</DL>

<DL>
<DT>Return value:</DT>

<DD>the name of the language.
</DL>

<H4><A NAME="sectc1527">15.2.7</A> TtaGetLanguageCodeFromName</H4>
<A NAME="L36192"></A>
<P>Returns the RFC-1766 code of a language whose name is known.</P>

<HR>

<P>char *TtaGetLanguageCodeFromName (char *name)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>name</EM>: the name of the language, for instance "English", "French",
"American", etc.
</DL>

<DL>
<DT>Return value:</DT>

<DD>code of the language, according to RFC-1766, a superset of ISO-639.
</DL>

<H4><A NAME="sectc1528">15.2.8</A> TtaGetPrincipalDictionary</H4>
<A NAME="L6437"></A>
<P>Returns a pointer to the principal dictionary associated to a language.</P>

<HR>

<P>Dictionary TtaGetPrincipalDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
language.
</DL>

<H4><A NAME="sectc1529">15.2.9</A> TtaGetSecondaryDictionary</H4>
<A NAME="L6460"></A>
<P>Returns a pointer to the secondary dictionary associated to a language.</P>

<HR>

<P>Dictionary TtaGetSecondaryDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
language.
</DL>

<H4><A NAME="sectc15210">15.2.10</A> TtaGetPrincipalTypoDictionary</H4>
<A NAME="L13912"></A>
<P>Returns a pointer to the principal dictionary associated to a typographic
language.</P>

<HR>

<P>Dictionary TtaGetPrincipalTypoDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
typographic language.
</DL>

<H4><A NAME="sectc15211">15.2.11</A> TtaGetSecondaryTypoDictionary</H4>
<A NAME="L13935"></A>
<P>Returns a pointer to the secondary dictionary associated to a typographic
language.</P>

<HR>

<P>Dictionary TtaGetSecondaryTypoDictionary(Language languageId)</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the pointer to that dictionary or NULL if there is no dictionary for this
typographic language.
</DL>

<H4><A NAME="sectc15212">15.2.12</A> TtaGetNumberOfLanguages</H4>
<A NAME="L6483"></A>
<P>Returns the current number of languages known by Thot.</P>

<HR>

<P>int TtaGetNumberOfLanguages()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>the current number of languages.
</DL>

<H2><A NAME="secta16">16</A> <A NAME="L6504">Specific presentation</A></H2>

<P>The functions described in this section require that file
<EM>presentation.h</EM> be included in the module that calls them.</P>

<P>When a new specific presentation rule is created (functions <A
NAME="L6516"></A>TtaNewPRule, TtaNewPRuleForNamedView and <A
NAME="L6520"></A>TtaCopyPRule), it must be attached (function <A
NAME="L6524"></A>TtaAttachPRule) to an element which is itself part of an
abstract tree of a document, before any other action can be performed on that
specific presentation rule.</P>

<H3><A NAME="sectb161">16.1</A> Constructors</H3>

<H4><A NAME="sectc1611">16.1.1</A> TtaNewPRule</H4>
<A NAME="L6534"></A>
<P>Creates a new presentation rule of a given type for a given view of a given
document.</P>

<HR>

<P>PRule TtaNewPRule(int presentationType, View view, Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>presentationType</EM>: type of the presentation rule to be created.
Available values are PRSize, PRStyle, PRFont, PRUnderline, PRThickness,
PRIndent, PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle,
PRLineWeight, PRFillPattern, PRBackground, PRForeground, PRHyphenate, PRWidth,
PRHeight, PRVertPos, PRHorizPos.
<P><EM>view</EM>: the view (this view must be open).</P>

<P><EM>document</EM>: the document.</P>

</DL>

<DL>
<DT>PReturn value:</DT>

<DD>new presentation rule.
</DL>

<H4><A NAME="sectc1612">16.1.2</A> TtaNewPRuleForNamedView</H4>
<A NAME="L6578"></A>
<P>Creates a new presentation rule of a given type for a given view of a given
document. The view is identified by its name.</P>

<HR>

<P>PRule TtaNewPRuleForNamedView(int presentationType, char *viewName,
Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>presentationType</EM>: type of the presentation rule to be created.
Available values are PRSize, PRStyle, PRFont, PRUnderline, PRThickness,
PRIndent, PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle,
PRLineWeight, PRFillPattern, PRBackground, PRForeground, PRHyphenate, PRWidth,
PRHeight, PRVertPos, PRHorizPos.
<P><EM>viewName</EM>: the name of the view (this view does not need to be
open).</P>

<P><EM>document</EM>: the document.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>new presentation rule.
</DL>

<H4><A NAME="sectc1613">16.1.3</A> TtaCopyPRule</H4>
<A NAME="L6623"></A>
<P>Creates a new presentation rule and initializes it with a copy of an
existing presentation rule.</P>

<HR>

<P>PRule TtaCopyPRule(PRule pRule)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>pRule</EM>: presentation rule to be copied.
</DL>

<DL>
<DT>Return value:</DT>

<DD>new presentation rule.
</DL>

<H4><A NAME="sectc1614">16.1.4</A> TtaAttachPRule</H4>
<A NAME="L6655"></A>
<P>Attaches a presentation rule to an element.</P>

<HR>

<P>void TtaAttachPRule(Element element, PRule pRule, Document document)</P>

<HR>

<PRE>
void TtaAttachPRule(element, pRule, document)
Element element;
PRule pRule;
Document document;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to which the presentation rule has to be
attached.
<P><EM>pRule</EM>: the presentation rule to be attached.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H4><A NAME="sectc1615">16.1.5</A> TtaRemovePRule</H4>
<A NAME="L6692"></A>
<P>Removes a presentation rule from an element and release that rule.</P>

<HR>

<P>void TtaRemovePRule(Element element, PRule pRule, Document document</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element with which the presentation rule is
associated.
<P><EM>pRule</EM>: the presentation rule to be removed.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<H3><A NAME="sectb162">16.2</A> Modificators</H3>

<H4><A NAME="sectc1621">16.2.1</A> TtaSetPRuleValue</H4>
<A NAME="L6732"></A>
<P>Changes the value of a presentation rule. The presentation rule must be
attached to an element that is part of a document.</P>

<HR>

<P>void TtaSetPRuleValue(Element element, PRule pRule, int value, Document
document)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element to which the presentation rule is attached.
<P><EM>pRule</EM>: the presentation rule to be changed.</P>

<P><EM>value</EM>: the value to be set.</P>

<P><EM>document</EM>: the document to which the element belongs.</P>

</DL>

<DL>
<DT>Valid values according to rule type:</DT>

<DD><EM>PRSize</EM>: an integer between 6 and 72 (body size in points).
<P><EM>PRStyle</EM>: StyleRoman, StyleBold, StyleItalics, StyleOblique,
StyleBoldItalics, StyleBoldOblique.</P>

<P><EM>PRFont</EM>: FontTimes, FontHelvetica, FontCourier.</P>

<P><EM>PRUnderline</EM>: NoUnderline, Underline, Overline, CrossOut.</P>

<P><EM>PRThickness</EM>: ThinUnderline, ThickUnderline.</P>

<P><EM>PRIndent</EM>: a positive, null or negative integer (indentation in
points).</P>

<P><EM>PRLineSpacing</EM>: a positive integer (line spacing in points).</P>

<P><EM>PRDepth</EM>: a positive integer (depth of the element).</P>

<P><EM>PRAdjust</EM>: AdjustLeft, AdjustRight, Centered, LeftWithDots.</P>

<P><EM>PRJustify</EM>: Justified, NotJustified.</P>

<P><EM>PRHyphenate</EM>: Hyphenation, NoHyphenation.</P>

<P><EM>PRLineStyle</EM>: SolidLine, DashedLine, DottedLine.</P>

<P><EM>PRLineWeight</EM>: a positive or null integer (stroke width for
graphics).</P>

<P><EM>PRFillPattern</EM>: rank of the pattern in the file thot.pattern.</P>

<P><EM>PRBackground</EM>: rank of the background color in the file
thot.color.</P>

<P><EM>PRForeground</EM>: rank of the foreground color in the file
thot.color.</P>

<P><EM>PRWidth, PRHeight, PRVertPos, PRHorizPos</EM>: a positive or null
integer.</P>

</DL>

<H4><A NAME="sectc1622">16.2.2</A> TtaSetPRuleView</H4>
<A NAME="L36750"></A>
<P>Sets the view to which a presentation rule applies. The presentation rule
must not be attached yet to an element.</P>

<HR>

<P>void TtaSetPRuleView (PRule pRule, int view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule to be changed.
<P><EM>view</EM>: the value to be set.</P>

</DL>

<H4><A NAME="sectc1623">16.2.3</A> TtaChangeBoxSize</H4>
<A NAME="L6840"></A>
<P>Changes the height and width of the box corresponding to an element in a
given view.</P>

<HR>

<P>void TtaChangeBoxSize(Element element, Document document, View view, int
deltaX, int deltaY, TypeUnit unit)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>deltaX</EM>: width increment in units (positive, negative or zero).</P>

<P><EM>deltaY</EM>: height increment in units (positive, negative or
zero).</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<H4><A NAME="sectc1624">16.2.4</A> TtaChangeBoxPosition</H4>
<A NAME="L6887"></A>
<P>Moves the box of an element in a given view.</P>

<HR>

<P>void TtaChangeBoxPosition(Element element, Document document, View view,
int deltaX, int deltaY, TypeUnit unit)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>deltaX</EM>: horizontal shift in units (positive, negative or
zero).</P>

<P><EM>deltaY</EM>: vertical shift in units (positive, negative or zero).</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<H3><A NAME="sectb163">16.3</A> Accessors</H3>

<H4><A NAME="sectc1631">16.3.1</A> TtaGiveBoxSize</H4>
<A NAME="L6940"></A>
<P>Returns the height and width of the box corresponding to an element in a
given view.</P>

<HR>

<P>void TtaGiveBoxSize(Element element, Document document, View view, TypeUnit
unit, int *width, int *height)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>width</EM>: box width in units.
<P><EM>height</EM>: box height in units.</P>

</DL>

<H4><A NAME="sectc1632">16.3.2</A> TtaGiveBoxPosition</H4>
<A NAME="L6987"></A>
<P>Returns the x and y coordinates of the box corresponding to an element in a
given view. The returned coordinates indicate the distance between the upper
left corner of the box and the upper left corner of its parent box.</P>

<HR>

<P>void TtaGiveBoxPosition(Element element, Document document, View view,
TypeUnit unit, int *xCoord, int *yCoord)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>xCoord</EM>: distance from the left edge of the parent box to the left
edge of the box, in units.
<P><EM>yCoord</EM>: distance from the top edge of the parent box to the top
edge of the box, in units.</P>

</DL>

<H4><A NAME="sectc1633">16.3.3</A> TtaGiveBoxAbsPosition</H4>
<A NAME="L59864"></A>
<P>Returns the x and y coordinates of the box corresponding to an element in a
given view. The returned coordinates indicate the distance between the upper
left corner of the box and the upper left corner of its window.</P>

<HR>

<P>void TtaGiveBoxAbsPosition(Element element, Document document, View view,
TypeUnit unit, int *xCoord, int *yCoord)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>document</EM>: the document to which the element belongs.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>unit</EM>: the unit used for the values.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>xCoord</EM>: distance from the left edge of the window to the left
edge of the box, in units.
<P><EM>yCoord</EM>: distance from the top edge of the window to the top edge
of the box, in units.</P>

</DL>

<H4><A NAME="sectc1634">16.3.4</A> TtaGiveWindowSize</H4>
<A NAME="L59909"></A>
<P>Returns the height and width of the window corresponding to a given
view.</P>

<HR>

<P>void TtaGiveWindowSize(Document document, View view, TypeUnit unit, int
*width, int *height)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD>
<P><EM>document</EM>: the document of interest.</P>

<P><EM>view</EM>: the view.</P>

<P><EM>unit</EM>: the unit used for the return values (only UnPixel and
UnPoint are allowed).</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>width</EM>: window width in units.
<P><EM>height</EM>: window height in units.</P>

</DL>

<H4><A NAME="sectc1635">16.3.5</A> TtaNextPRule</H4>
<A NAME="L7035"></A>
<P>Returns the first presentation rule associated with a given element (if
pRule is NULL) or the presentation rule that follows a given rule of a given
element.</P>

<HR>

<P>void TtaNextPRule(Element element, PRule *pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>pRule</EM>: a presentation rule of that element, or NULL if the first
rule is asked.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD><EM>pRule</EM>: the next presentation rule, or NULL if pRule is the last
rule of the element.
</DL>

<H4><A NAME="sectc1636">16.3.6</A> TtaGetPRule</H4>
<A NAME="L7074"></A>
<P>Returns a presentation rule of a given type associated with a given
element.</P>

<HR>

<P>PRule TtaGetPRule(Element element, int presentationType)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>element</EM>: the element of interest.
<P><EM>presentationType</EM>: type of the desired presentation rule. Available
values are PRSize, PRStyle, PRFont, PRUnderline, PRThickness, PRIndent,
PRLineSpacing, PRDepth, PRAdjust, PRJustify, PRLineStyle, PRLineWeight,
PRFillPattern, PRBackground, PRForeground, PRHyphenate, PRWidth, PRHeight,
PRVertPos, PRHorizPos.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the presentation rule found, or NULL if the element does not have this
type of presentation rule.
</DL>

<H4><A NAME="sectc1637">16.3.7</A> TtaGetPRuleType</H4>
<A NAME="L7113"></A>
<P>Returns the type of a presentation rule.</P>

<HR>

<P>int TtaGetPRuleType(PRule pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>type of that presentation rule. Available values are PRSize, PRStyle,
PRFont, PRUnderline, PRThickness, PRIndent, PRLineSpacing, PRDepth, PRAdjust,
PRJustify, PRLineStyle, PRLineWeight, PRFillPattern, PRBackground,
PRForeground, PRHyphenate, PRWidth, PRHeight, PRVertPos, PRHorizPos.
</DL>

<H4><A NAME="sectc1638">16.3.8</A> TtaGetPRuleValue</H4>
<A NAME="L7145"></A>
<P>Returns the value of a presentation rule.</P>

<HR>

<P>int TtaGetPRuleValue(PRule pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule of interest.
</DL>

<DL>
<DT>Return values according to rule type:</DT>

<DD><EM>PRSize</EM>: an integer between 6 and 72 (body size in points).
<P><EM>PRStyle</EM>: StyleRoman, StyleBold, StyleItalics, StyleOblique,
StyleBoldItalics, StyleBoldOblique.</P>

<P><EM>PRFont</EM>: FontTimes, FontHelvetica, FontCourier.</P>

<P><EM>PRUnderline</EM>: NoUnderline, Underline, Overline, CrossOut.</P>

<P><EM>PRThickness</EM>: ThinUnderline, ThickUnderline.</P>

<P><EM>PRIndent</EM>: a positive, null or negative integer (indentation in
points).</P>

<P><EM>PRLineSpacing</EM>: a positive integer (line spacing in points).</P>

<P><EM>PRDepth</EM>: a positive integer (depth of the element).</P>

<P><EM>PRAdjust</EM>: AdjustLeft, AdjustRight, Centered, LeftWithDots.</P>

<P><EM>PRJustify</EM>: Justified, NotJustified.</P>

<P><EM>PRHyphenate</EM>: Hyphenation, NoHyphenation.</P>

<P><EM>PRLineStyle</EM>: SolidLine, DashedLine, DottedLine.</P>

<P><EM>PRLineWeight</EM>: a positive or null integer (stroke width for
graphics).</P>

<P><EM>PRFillPattern</EM>: rank of the pattern in the file thot.pattern.</P>

<P><EM>PRBackground</EM>: rank of the background color in the file
thot.color.</P>

<P><EM>PRForeground</EM>: rank of the foreground color in the file
thot.color.</P>

<P><EM>PRWidth, PRHeight, PRVertPos, PRHorizPos</EM>: a positive or null
integer.</P>

</DL>

<H4><A NAME="sectc1639">16.3.9</A> TtaGetPRuleUnit</H4>
<A NAME="L57691"></A>
<P>Returns the unit of a presentation rule. This unit could be UnRelative,
UnXHeight, UnPoint, UnPixel, UnPercent.</P>

<HR>

<P>int TtaGetPRuleUnit(PRule pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule of interest.
</DL>

<DL>
<DT>Return values according to rule type:</DT>

<DD>
<P>The unit of the rule type<EM> PRSize, PRIndent, PRLineSpacing,
PRLineWeight, PRWidth, PRHeight, PRVertPos, PRHorizPos</EM> or UnRelative if
there is not unit for this rule.</P>

</DL>

<H4><A NAME="sectc16310">16.3.10</A> TtaGetPRuleView</H4>
<A NAME="L36850"></A>
<P>Returns the number of the view to which a presentation rule applies.</P>

<HR>

<P>int TtaGetPRuleView(PRule pRule)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule</EM>: the presentation rule of interest.
</DL>

<DL>
<DT>Return value:</DT>

<DD>number of the view to which a presentation rule applies.
</DL>

<H4><A NAME="sectc16311">16.3.11</A> TtaSamePRules</H4>
<A NAME="L7235"></A>
<P>Compares two presentation rules associated with the same element or with
different elements.</P>

<HR>

<P>int TtaSamePRules(PRule pRule1, PRule pRule2)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>pRule1</EM>: first presentation rule to be compared.
<P><EM>pRule2</EM>: second presentation rule to be compared.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if both rules are different, 1 if they are identical.
</DL>

<H2><A NAME="secta17">17</A> Style</H2>

<P>The functions described in this section require that file <EM>style.h</EM>
be included in the module that calls them. They are available only in the Thot
Editor library.</P>

<P>These functions allow the application to define either generic style or
specific style. Generic style is stored in an extended presentation schema
attached to the document and specific style is attached to elements. The
application needs to create a generic context to set, get or update a  generic
style rule  and  needs to create a specific context to set, get or update a
specific style rule.</P>

<H3><A NAME="sectb171">17.1</A> Constructors</H3>

<H4><A NAME="sectc1711">17.1.1</A> TtaGetSpecificStyleContext</H4>
<A NAME="L58658"></A>
<P>Create a context for setting or getting a specific style attached to an
element.</P>

<P>The specific context contains:</P>
<PRE>
Document   doc;/* document number */
SSchema    schema;/* associated structure */
int        type;      /* type of element */
ThotBool   destroy;   /* destructive mode */
</PRE>

<HR>

<P>PresentationContext TtaGetSpecificStyleContext (Document doc) </P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>doc</EM>: the document for which the context is created
</DL>

<DL>
<DT>Return value:</DT>

<DD>a pointer to the allocated context.
</DL>

<H4><A NAME="sectc1712">17.1.2</A> TtaGetGenericStyleContext</H4>
<A NAME="L58710"></A>
<P>Create a context for setting or getting a specific style attached to an
element.</P>

<P>The generiic context contains:</P>
<PRE>
Document doc;/* document number */
SSchema  schema;/* associated structure */
int      type;      /* type of element */
ThotBool destroy;   /* destructive mode */
int      box; /* specific presentation box if any */
int      attr;     /* or attribute */
int      attrval;  /* and the corresponding value */
char    *class;    /* class or box name */
int      classattr;/* class attribute */
int      attrelem; /* elem porting the attribute */
int      ancestors[MAX_ANCESTORS];/* ancestors type*/
int      ancestors_nb[MAX_ANCESTORS];/* number for each */
</PRE>

<HR>

<P>GenericContext TtaGetGenericStyleContext (Document doc)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>doc</EM>: the document for which the context is created 
</DL>

<DL>
<DT>Return value:</DT>

<DD>a pointer to the allocated context.
</DL>

<H3><A NAME="sectb172">17.2</A> Modificators</H3>

<H4><A NAME="sectc1721">17.2.1</A> TtaSetStylePresentation</H4>
<A NAME="L58745"></A>
<P>Add a style rule to an element (specific) or to an extended presentation
schema (generic).</P>

<HR>

<P>int  TtaSetStylePresentation (unsigned int type, Element el, PSchema tsch,
PresentationContext context, PresentationValue value )</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>type</EM>: type of the rule TRWidth, TRHeight, etc. (see
presentation.h).
<P><EM>el</EM>: element concerned (if specific) or Null</P>

<P><EM>tsch</EM>:  presentation schema concerned (if generic) or Null</P>

<P><EM>conte</EM>:  the specific or generic context.</P>

<P><EM>value</EM>: value associated to the typed rule.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>0 if the operation has been executed successfully.
</DL>

<H4><A NAME="sectc1722">17.2.2</A> TtaUpdateStylePresentation</H4>
<A NAME="L58780"></A>
<P>Apply added style rules to an element (specific) or to an extended
presentation schema (generic).</P>

<HR>

<P>void TtaUpdateStylePresentation (Element el, PSchema tsch,
PresentationContext context)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>el</EM>: element concerned (if specific) or Null
<P><EM>tsch</EM>:  presentation schema concerned (if generic) or Null</P>

<P><EM>conte</EM>:  the specific or generic context.</P>

</DL>

<H4><A NAME="sectc1723">17.2.3</A> TtaCleanStylePresentation</H4>
<A NAME="L58815"></A>
<P>Remove style rules of an element (specific) or of an extended presentation
schema (generic).</P>

<HR>

<P>void TtaCleanStylePresentation (Element el, PSchema tsch, Document doc)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>el</EM>: element concerned (if specific) or Null
<P><EM>tsch</EM>:  presentation schema concerned (if generic) or Null</P>

<P><EM>doc</EM>: the document concerned</P>

</DL>

<H3><A NAME="sectb173">17.3</A> Accessors</H3>

<H4><A NAME="sectc1731">17.3.1</A> TtaGetStylePresentation</H4>
<A NAME="L59247"></A>
<P>Add a style rule to an element (specific) or to an extended presentation
schema (generic).</P>

<HR>

<P>int  TtaGetStylePresentation (unsigned int type, Element el, PSchema tsch,
PresentationContext context, PresentationValue *value )</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>type</EM>: type of the rule TRWidth, TRHeight, etc. (see
presentation.h).
<P><EM>el</EM>: element concerned (if specific) or Null</P>

<P><EM>tsch</EM>:  presentation schema concerned (if generic) or Null</P>

<P><EM>conte</EM>:  the specific or generic context.</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD>0 if the operation has been executed successfully.
<P><EM>value</EM>: value associated to the typed rule.</P>

</DL>

<H4><A NAME="sectc1732">17.3.2</A> </H4>

<H2><A NAME="secta18">18</A> <A NAME="L7272">Views</A></H2>

<P>The functions described in this section require that file <EM>view.h</EM>
be included in the module that calls them. They are available only in the Thot
Editor library.</P>

<H3><A NAME="sectb181">18.1</A> Constructors</H3>

<H4><A NAME="sectc1811">18.1.1</A> TtaOpenMainView</H4>
<A NAME="L7287"></A>
<P>Opens the main view of a document. This document must have a PSchema (see
<A NAME="L7295"></A>TtaSetPSchema).</P>

<HR>

<P>View TtaOpenMainView(Document document, int x, int y, int w, int h)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which a window must be open.
<P><EM>x, y</EM>: coordinate (in millimeters) of the upper left corner of the
window that will display the view.</P>

<P><EM>w, h</EM>: width and height (in millimeters) of the upper left corner
of the window that will display the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view opened or 0 if the view cannot be opened.
</DL>

<H4><A NAME="sectc1812">18.1.2</A> TtaOpenView</H4>
<A NAME="L7334"></A>
<P>Opens a view for a document. This document must have a PSchema (see <A
NAME="L7342"></A>TtaSetPSchema).</P>

<HR>

<P>View TtaOpenView(Document document, char *viewName, int x, int y, int w,
int h)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>viewName</EM>: name of the view to be opened.</P>

<P><EM>x, y</EM>: coordinate (in millimeters) of the upper left corner of the
window that will display the view.</P>

<P><EM>w, h</EM>: width and height (in millimeters) of the upper left corner
of the window that will display the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view opened or 0 if the view cannot be opened.
</DL>

<H4><A NAME="sectc1813">18.1.3</A> TtaOpenSubView</H4>
<A NAME="L7386"></A>
<P>Opens a view that shows only a subtree. This document must have a PSchema
(see <A NAME="L7394"></A>TtaSetPSchema).</P>

<HR>

<P>View TtaOpenSubView(Document document, char *viewName, int x, int y, int w,
int h, Element subtree)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>viewName</EM>: name of the view to be opened.</P>

<P>x, y: coordinate (in millimeters) of the upper left corner of the</P>

<P>window that will display the view.</P>

<P>w, h: width and height (in millimeters) of the upper left corner of the</P>

<P>window that will display the view.</P>

<P><EM>subtree</EM>: root element of the subtree to be shown in the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view opened or 0 if the view cannot be opened.
</DL>

<H4><A NAME="sectc1814">18.1.4</A> TtaChangeViewTitle</H4>
<A NAME="L7449"></A>
<P>Changes the title of a view.</P>

<HR>

<P>void TtaChangeViewTitle(Document document, View view, char *title)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>view</EM>: the view .</P>

<P>title: the new title.</P>

</DL>

<H4><A NAME="sectc1815">18.1.5</A> TtaCloseView</H4>
<A NAME="L7484"></A>
<P>Closes a view.</P>

<HR>

<P>void TtaCloseView(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which a view must be closed.
<P><EM>view</EM>: the view to be closed.</P>

</DL>

<H3><A NAME="sectb182">18.2</A> Modificators</H3>

<H4><A NAME="sectc1821">18.2.1</A> TtaSetSensibility</H4>
<A NAME="L7519"></A>
<P>Changes the current sensibility used to display a given view of a given
document.</P>

<HR>

<P>void TtaSetSensibility(Document document, View view, int value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

<P><EM>value</EM>: new value of the sensibility.</P>

</DL>

<H4><A NAME="sectc1822">18.2.2</A> TtaSetZoom</H4>
<A NAME="L7555"></A>
<P>Changes the current zoom used to display a given view of a given
document.</P>

<HR>

<P>void TtaSetZoom(Document document, View view, int value)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

<P><EM>value</EM>: new value of the zoom.</P>

</DL>

<H4><A NAME="sectc1823">18.2.3</A> TtaShowElement</H4>
<A NAME="L7591"></A>
<P>Shows a given element in a given view of a given document.</P>

<HR>

<P>void TtaShowElement(Document document, View view, Element element, int
position)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the element to be shown belongs.
Cannot be 0.
<P><EM>view</EM>: the view where the element must be shown.</P>

<P><EM>element</EM>: the element to be shown.</P>

<P><EM>position</EM>: position of the top of the element in the window.
Supposing that the y axis is oriented from the top of the window (coordinate
0) to the bottom (coordinate 100, whatever the actual height of the window),
position is the desired y coordinate of the top of the element. This value is
can be negative.</P>

</DL>

<H4><A NAME="sectc1824">18.2.4</A> TtaRaiseView</H4>
<A NAME="L28968"></A>
<P>Maps and raises a given view of a given document.</P>

<HR>

<P>void TtaRaiseView(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the element to be shown belongs.
Cannot be 0.
<P><EM>view</EM>: the view where the element must be shown.</P>

</DL>

<H4><A NAME="sectc1825">18.2.5</A> TtaSetDisplayMode</H4>
<A NAME="L7634"></A>
<P>Changes display mode for a document. Three display modes are available
(DisplayImmediately, DeferredDisplay and NoComputedDisplay). In the immediate
mode, each modification made in the abstract tree of a document is immediately
reflected in all opened views where the modification can be seen. In the
deferred mode, the programmer can decide when the modifications are made
visible to the user; this avoids the image of the document to blink when
several elementary changes are made successively. Modifications are displayed
when mode is changed to DisplayImmediately. In the NoComputedDisplay mode, the
modifications are not displayed and not computed by the editor; the execution
is more rapid but the current image is lost. When mode is changed to
DisplayImmediately or DeferredDisplay, the image is completely redrawn by the
editor. An application that handles several documents at the same time can
choose different modes for different documents. When a document is open or
created, it is initially in the immediate mode.</P>

<HR>

<P>void TtaSetDisplayMode(Document document, DisplayMode newDisplayMode)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>NewDisplayMode</EM>: new display mode for that document.</P>

</DL>

<H3><A NAME="sectb183">18.3</A> Accessors</H3>

<H4><A NAME="sectc1831">18.3.1</A> TtaGetSensibility</H4>
<A NAME="L7668"></A>
<P>Reads the current sensibility used to display a given view of a given
document.</P>

<HR>

<P>int TtaGetSensibility(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>current value of the sensibility.
</DL>

<H4><A NAME="sectc1832">18.3.2</A> TtaGetZoom</H4>
<A NAME="L7707"></A>
<P>Reads the current zoom used to display a given view of a given
document.</P>

<HR>

<P>int TtaGetZoom(Document document, View view)</P>

<HR>

<PRE>
int TtaGetZoom(document, view)
Document document;
View view;
</PRE>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document. Cannot be 0.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>current value of the zoom.
</DL>

<H4><A NAME="sectc1833">18.3.3</A> TtaGetFirstElementShown</H4>
<A NAME="L56625"></A>
<P>Returns the first visible element in the view of the document. The function
returns also, the position of the top of this element within the view.</P>

<HR>

<P>Element TtaGetFirstElementShown (Document document, View view, int
*position)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return parameter:</DT>

<DD>
<P><EM>position</EM>: position of the top of the element in the window.
Supposing that the y axis is oriented from the top of the window (coordinate
0) to the bottom (coordinate 100, whatever the actual height of the window),
position is the desired y coordinate of the top of the element. This value is
can be negative.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>current display mode for that document.
</DL>

<H4><A NAME="sectc1834">18.3.4</A> TtaGetDisplayMode</H4>
<A NAME="L7745"></A>
<P>Returns the current display mode for a document.</P>

<HR>

<P>DisplayMode TtaGetDisplayMode(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>current display mode for that document.
</DL>

<H4><A NAME="sectc1835">18.3.5</A> TtaIsPSchemaValid</H4>
<A NAME="L7777"></A>
<P>Checks if a presentation schema can be applied to a document of a given
class. No document is needed and the schemas are not loaded by this
function.</P>

<HR>

<P>int TtaIsPSchemaValid(char *structureName, char *presentationName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>structureName</EM>: Name of the document class.
<P><EM>presentationName</EM>: Name of the presentation schema to be
checked.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>1 if the presentation schema can be applied, 0 if it can not.
</DL>

<H4><A NAME="sectc1836">18.3.6</A> TtaGiveViewsToOpen</H4>
<A NAME="L7816"></A>
<P>Returns the names of the views that can be opened for a document.</P>

<HR>

<P>void TtaGiveViewsToOpen(Document document, char *buffer, int nbViews)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document.
<P><EM>buffer</EM>: a buffer that will contain the result.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>buffer</EM>: list of view names. Each name is a character string with
a final '\0'. Names of views that are already open have a '*' at the end.
<P><EM>nbViews</EM>: number of names in the list, 0 if not any view can be
open.</P>

</DL>

<H4><A NAME="sectc1837">18.3.7</A> TtaGetViewName</H4>
<A NAME="L7861"></A>
<P>Returns the name of an open view.</P>

<HR>

<P>char *TtaGetViewName(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the view belongs.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>Name of the view. The buffer must be provided by the caller.
</DL>

<H4><A NAME="sectc1838">18.3.8</A> TtaGetViewFromName</H4>
<A NAME="L7899"></A>
<P>Returns the identifier of a view of a given document from its name.</P>

<HR>

<P>View TtaGetViewFromName(Document document, char *viewName)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the view belongs.
<P><EM>viewName</EM>: the name of the view.</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>the view. 0 if no view of that name is currently open for the document.
</DL>

<H4><A NAME="sectc1839">18.3.9</A> TtaGiveActiveView</H4>
<A NAME="L7938"></A>
<P>Returns the active view and the document to which that view belongs. The
active view is the one that receives the characters typed by the user.</P>

<HR>

<P>void TtaGiveActiveView(Document *document, View *view)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>No parameter.
</DL>

<DL>
<DT>Return values:</DT>

<DD><EM>document</EM>: the active document.
<P><EM>view</EM>: the active view.</P>

</DL>

<H4><A NAME="sectc18310">18.3.10</A> TtaIsViewOpened</H4>
<A NAME="L29017"></A>
<P>Indicates whether a view is opened.</P>

<HR>

<P>ThotBool TtaIsViewOpened(Document document, View view)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
<P><EM>view</EM>: the view.</P>

</DL>

<DL>
<DT>Return values:</DT>

<DD> True if the view is already opened.
</DL>

<H3><A NAME="sectb184">18.4</A> Help</H3>

<H4><A NAME="sectc1841">18.4.1</A> TtaListView</H4>
<A NAME="L25772"></A>
<P>Produces in a file a human-readable form of the current picture of the
document view.</P>

<HR>

<P>void TtaListView(Document document, View view, FILE *fileDescriptor)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to be listed.
<P><EM>view</EM>: the view to be listed.</P>

<P><EM>fileDescriptor</EM>: file descriptor of the file that will contain the
list. This file must be open when calling the function.</P>

</DL>

<H2><A NAME="secta19">19</A> <A NAME="L7975">Selection</A></H2>

<P>The functions described in this section require that file
<EM>selection.h</EM> be included in the module that calls them. They are
available only in the Thot Editor library.</P>

<P>These functions allow an application program to change the selection set by
the user of the Thot Editor. The selection is the part of a document that will
be concerned by the next editing command issued by the end user. Tool kit
functions that modify a document are independent from the selection in the
sense that they can change any part of a document independently of the current
selection; but, when necessary, they can also have access to the current user
selection, by using the following functions.</P>

<H3><A NAME="sectb191">19.1</A> Constructors</H3>

<H4><A NAME="sectc1911">19.1.1</A> TtaSelectElement</H4>
<A NAME="L7993"></A>
<P>Selects a single element. This element is highlighted in all views where it
can be displayed. If it cannot be displayed in any existing view, a new view
is eventually open for displaying it.</P>

<HR>

<P>void TtaSelectElement(Document document, Element selectedElement)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document containing the element to be selected.
<P><EM>selectedElement</EM>: the element to be selected. NULL for cancelling
the selection in the document.</P>

</DL>

<H4><A NAME="sectc1912">19.1.2</A> TtaSelectView</H4>
<A NAME="L37101"></A>
<P>Define the selected view of the document. This function has no effect if
the document is not the current selected document and if the current selected
element is an associated element.</P>

<HR>

<P>void TtaSelectView(Document document, View view)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document containing the eselected lement.
<P><EM>view</EM>: one view where the selected element is displayed.</P>

</DL>

<H4><A NAME="sectc1913">19.1.3</A> TtaSelectString</H4>
<A NAME="L8024"></A>
<P>Selects a substring or places the insertion caret within a Text basic
element. This substring is highlighted in all views where it can be
displayed.</P>

<HR>

<P>void TtaSelectString(Document document, Element textElement, int
firstCharacter, int lastCharacter)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document containing the string to be selected.
<P><EM>textElement</EM>: the Text element containing the string to be
selected.</P>

<P><EM>firstCharacter</EM>: position within the text element of the first
character to be selected.</P>

<P><EM>lastCharacter</EM>: position within the text element of the last
character to be selected, 0 if a caret is to be placed before the position of
the character of rank firstCharacter.</P>

</DL>

<H4><A NAME="sectc1914">19.1.4</A> TtaExtendSelection</H4>
<A NAME="L8066"></A>
<P>Extends the current selection to a given element.</P>

<HR>

<P>void TtaExtendSelection(Document document, Element element, int
lastCharacter)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the selection must be extended.
<P><EM>element</EM>: the element to which the selection must be extended.</P>

<P><EM>lastCharacter</EM>: position within this element of the last character
to be selected. 0 if the whole element must be selected.</P>

</DL>

<H4><A NAME="sectc1915">19.1.5</A> TtaAddElementToSelection</H4>
<A NAME="L57829"></A>
<P>Add a new element to the current selection.  The new selection may then
contain separate elements.</P>

<HR>

<P>void TtaAddElementToSelection (Document document, Element element)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which the element belongs.  This
element must belong to the same document as the elements selected by previous
calls to TtaAddElementToSelection and by the last call to TtaSelectElement.
<P><EM>element</EM>: the element to be added to the current selection.</P>

</DL>

<H4><A NAME="sectc1916">19.1.6</A> TtaSelectInterval</H4>
<A NAME="L8103"></A>
<P>If a pair of paired elements is selected, select also all elements between
the two paired elements. Nothing is done if the current selection is not a
pair.</P>

<HR>

<P>void TtaSelectInterval()</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD>No parameter
</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H4><A NAME="sectc1917">19.1.7</A> TtaUnselect</H4>
<A NAME="L8132"></A>
<P>Turns the selection off for a document.</P>

<HR>

<P>void TtaUnselect(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the selection must be turned off
</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H4><A NAME="sectc1918">19.1.8</A> TtaSwitchSelection</H4>
<A NAME="L57860"></A>
<P>Switche the selection  on or off  in a view. </P>

<HR>

<P>void TtaSwitchSelection (Document document, View view, ThotBool show)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the selection must be switched
off or on
<P><EM>view</EM>: the view for which the selection must be switched off or
on</P>

<P><EM>show</EM>: indicate whether the selection must be switched off or
on</P>

</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H4><A NAME="sectc1919">19.1.9</A> TtaSetSelectionMode</H4>
<A NAME="L8165"></A>
<P>Change selection mode. If withMenu = False functions TtaSelectElement,
TtaSelectString, TtaExtendSelection and TtaUnselect do not update the menus
that depend on the selection and do not display the selection message. Default
mode is withMenu = True.</P>

<HR>

<P>void TtaSetSelectionMode(ThotBool withMenu)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>withMenu</EM>: the new selection mode.
</DL>

<DL>
<DT>Return value:</DT>

<DD>No return value
</DL>

<H3><A NAME="sectb192">19.2</A> Accessors</H3>

<H4><A NAME="sectc1921">19.2.1</A> TtaGetSelectedDocument</H4>
<A NAME="L46786"></A>
<P>Returns the selected document.</P>

<HR>

<P>Document TtaGetSelectedDocument ()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD><EM>document</EM>: the selected document or 0.
</DL>

<H4><A NAME="sectc1922">19.2.2</A> TtaIsDocumentSelected</H4>
<A NAME="L33392"></A>
<P>Indicates whether a document is selected.</P>

<HR>

<P>ThotBool TtaIsDocumentSelected(Document document)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document.
</DL>

<DL>
<DT>Return value:</DT>

<DD>True if the current selection concerns this document.
</DL>

<H4><A NAME="sectc1923">19.2.3</A> TtaIsSelectionEmpty</H4>
<A NAME="L57652"></A>
<P>Indicates whether there is an empty selection (a caret).</P>

<HR>

<P>ThotBool TtaIsSelectionEmpty()</P>

<HR>

<DL>
<DT>Return value:</DT>

<DD>True if here is a current selection and this selection is empty (a caret).
</DL>

<H4><A NAME="sectc1924">19.2.4</A> TtaGiveFirstSelectedElement</H4>
<A NAME="L8202"></A>
<P>Returns the first element in the current selection in a given document. If
this element is a Text element and if only a substring is selected, return
also the rank of the first and last characters in the selection. If the
current selection is an insert caret, the first character follows the last
one. </P>

<HR>

<P>void TtaGiveFirstSelectedElement(Document document, Element
*selectedElement, int *firstCharacter, int *lastCharacter)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the selection is asked.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>selectedElement</EM>: the first selected element, NULL if no element
is selected in the document.
<P><EM>firstCharacter</EM>: rank of the first character in the selection, or 0
if the whole element is in the selection.</P>

<P><EM>lastCharacter</EM>: rank of the last character in the selection, or 0
if the</P>

<P>whole element is in the selection.</P>

</DL>

<H4><A NAME="sectc1925">19.2.5</A> TtaGiveLastSelectedElement</H4>
<A NAME="L57897"></A>
<P>Returns the last element in the current selection in a given document. If
this element is a Text element and if only a substring is selected, return
also the rank of the first and last characters in the selection.</P>

<HR>

<P>void TtaGiveLastSelectedElement(Document document, Element
*selectedElement, int *firstCharacter, int *lastCharacter)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>document</EM>: the document for which the selection is asked.
</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>selectedElement</EM>: the last selected element, NULL if no element is
selected in the document.
<P><EM>firstCharacter</EM>: rank of the first character in the selection, or 0
if the whole element is in the selection.</P>

<P><EM>lastCharacter</EM>: rank of the last character in the selection, or 0
if the</P>

<P>whole element is in the selection.</P>

</DL>

<H4><A NAME="sectc1926">19.2.6</A> TtaGiveNextSelectedElement</H4>
<A NAME="L8252"></A>
<P>Returns the element that follows a given element in the current selection
in a given document. If this element is a Text element and if only a substring
is selected, return also the rank of the first and last characters in the
selection.</P>

<HR>

<P>void TtaGiveNextSelectedElement(Document document, Element
*selectedElement, int *firstCharacter, int *lastCharacter)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document for which the selection is asked.
<P><EM>selectedElement</EM>: the current element.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>selectedElement</EM>: the next selected element, NULL if this was the
last selected element in the document.
<P><EM>firstCharacter</EM>: rank of the first character in the selection, or 0
if the whole element is in the selection.</P>

<P><EM>lastCharacter</EM>: rank of the last character in the selection, or 0
if the</P>

<P>whole element is in the selection.</P>

</DL>

<H4><A NAME="sectc1927">19.2.7</A> TtaGiveNextElement</H4>
<A NAME="L57940"></A>
<P>Returns the element that follows a given element in the selection
order.</P>

<HR>

<P>void TtaGiveNextElement(Document document, Element *eselectedElement,
Element last)</P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>document</EM>: the document to which element belongs.
<P><EM>element</EM>: the current element.</P>

<P><EM>last</EM>: end of the range to be searched, usually last selected
element.</P>

</DL>

<DL>
<DT>Return parameters:</DT>

<DD><EM>element</EM>: the next element in the selection order. NULL if not
found.
</DL>

<H2><A NAME="secta20">20</A> Printing</H2>

<P>The procedures described in this section are for printing Thot documents.
Their use require that file <EM>print.h</EM> be included in the modules that
call them. They are available only in the Thot Editor library.</P>

<P>These procedures let the application launch the printing process, also
specify print parameters, and define an export function for pre-processing
documents to be printed.</P>

<H3><A NAME="sectb201">20.1</A> Constructors</H3>

<H4><A NAME="sectc2011">20.1.1</A> TtaPrint</H4>

<P>This procedure prints some views of a document with current print
parameters. The names of the views to be printed have to be consistant with
those given in the presentation schema used for printing. The application may
change the presentation schema of the document if it does not match the paper
size specified in the parameters (The paper size relative to a presentation
schema are given in the <I>.conf </I>file).</P>

<HR>

<P>void TtaPrint(Document document, char *viewName, char cssNames)</P>

<HR>

<DL>
<DT>Paramters:</DT>

<DD><EM>document </EM>: the document to be printed.
<P><EM>viewNames </EM>: the names of the views to be printed, seprated by a
blank character.</P>

<P><EM>cssNames </EM>: the names of the css to be applied, seprated by a blank
character.</P>

</DL>

<H3><A NAME="sectb202">20.2</A> Modificators</H3>

<H4><A NAME="sectc2021">20.2.1</A> TtaSetPrintExportProc</H4>

<P>This procedure let an application have its own export function before
printing a document. If an application wants to pre-process a document before
printing it, it can be done by specifing an export procedure used instead the
standard one. </P>

<P>The export function have to create the pivot file with the given filename
and path and save the document to be printed into it. It returns TRUE if the
export was succesful. The export function have the following prototype :</P>

<P>ThotBool exportFunc (Document document, char * docName, char* dirName)</P>

<HR>

<P>void TtaSetPrintExportFunc (Func exportFunc)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>exportProc</EM>: the export procedure or NULL to restore the standard
export.
</DL>

<H4><A NAME="sectc2022">20.2.2</A> TtaSetPrintSchema</H4>

<P>This procedure defines the presentation schema that has to be used by the
editor when printing or saving a PostScript file. By default, he name is ""
and the editor searches in the configuration file $STRUCTURE.conf the first
presentation schema supporting the current paper format (A4 or US). To return
to the default status, the application has to resets the empty name "".</P>

<HR>

<P>void TtaSetPrintSchema (char *name)</P>

<HR>

<DL>
<DT>Parameter :</DT>

<DD><EM>name</EM>: The schema name without the suffix .PRS.
</DL>

<H4><A NAME="sectc2023">20.2.3</A> TtaSetPrintParameter</H4>

<P>Thit procedure changes a print paramenter. Modifiable parameters belongs to
PrintParameter type. The different parameters are listed below, with the range
of their values.</P>

<P> </P>

<DL><I>
<DT>PrintParameter</DT>

<DD>Range</I>
<DT>PP_FirstPage</DT>

<DD>0 to 999
<DT>PP_LastPage</DT>

<DD>0 to 999
<DT>PP_Scale</DT>

<DD>10 to 300
<DT>PP_NumberCopies</DT>

<DD>1 to 100
<DT>PP_ManualFeed</DT>

<DD>PP_ON or PP_OFF
<DT>PP_PagesPerSheet</DT>

<DD>1, 2 or 4
<DT>PP_PaperSize</DT>

<DD>PP_A4 or PP_US
<DT>PP_Destination</DT>

<DD>PP_PRINTER or PP_PS
</DL>

<P> </P>

<HR>

<P>void TtaSetPrintParameter (PrintParameter parameter, int value) </P>

<HR>

<DL>
<DT>Parameters:</DT>

<DD><EM>parameter </EM>: A print parameter.
<P><I>value</I> : The new value of the parameter.</P>

</DL>

<H4><A NAME="sectc2024">20.2.4</A> TtaSetPrintCommand</H4>

<P>This procedure modifies the system printing command called by the editor
(the default value is given by the parameter THOTPRINT in <I>.thotrc</I>
file). It may be used for changing the printer name or a printer-side printing
option.</P>

<HR>

<P>void TtaSetPrintCommand (char *command)</P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>command </EM>: The printing command.
</DL>

<H4><A NAME="sectc2025">20.2.5</A> TtaSetPsFile</H4>

<P>This procedure modifies the current path used by the editor when saving a
PostScript file.</P>

<HR>

<P>void TtaSetPsFile (char *path)</P>

<HR>

<DL>
<DT>Parameter :</DT>

<DD><EM>path</EM>: The PostScript file path.
</DL>

<H3><A NAME="sectb203">20.3</A> Accessors</H3>

<H4><A NAME="sectc2031">20.3.1</A> TtaIsPrintting</H4>

<P>This function returns TRUE when the current application is a print.ing
process.</P>

<HR>

<P>ThotBool TtaIsprinting ()</P>

<HR>

<DL>
<DT>Return value :</DT>

<DD>TRUE when it's aprinting process, FALSE otherwise.
</DL>

<H4><A NAME="sectc2032">20.3.2</A> TtaGetPrintParameter</H4>

<P>Thit procedure returns a print paramenter value. Modifiable parameters
belongs to PrintParameter type. The different parameters are listed below,
with the range of their values.</P>

<P> </P>

<DL><I>
<DT>PrintParameter</DT>

<DD>Range</I>
<DT>PP_FirstPage</DT>

<DD>0 to 999
<DT>PP_LastPage</DT>

<DD>0 to 999
<DT>PP_Scale</DT>

<DD>10 to 300
<DT>PP_NumberCopies</DT>

<DD>1 to 100
<DT>PP_ManualFeed</DT>

<DD>PP_ON or PP_OFF
<DT>PP_PagesPerSheet</DT>

<DD>1, 2 or 4
<DT>PP_PaperSize</DT>

<DD>PP_A4 or PP_US
<DT>PP_Destination</DT>

<DD>PP_PRINTER or PP_PS
</DL>

<P> </P>

<HR>

<P>int TtaGetPrintParameter (PrintParameter parameter) </P>

<HR>

<DL>
<DT>Parameter:</DT>

<DD><EM>parameter </EM>: A print parameter.
</DL>

<DL>
<DT>Return value:</DT>

<DD>The current value of the parameter.
</DL>

<H4><A NAME="sectc2033">20.3.3</A> TtaGetPrintCommand</H4>

<P>This procedure returns the current printing command.</P>

<HR>

<P>void TtaGetPrintCommand (char *command)</P>

<HR>

<DL>
<DT>Return parameter:</DT>

<DD><EM>command </EM>: The current printing command.
</DL>

<H4><A NAME="sectc2034">20.3.4</A> TtaGetPsFile</H4>

<P>This procedure returns the current path used by the editor when saving a
PostScript file.</P>

<HR>

<P>void TtaGetPsFile (char *path)</P>

<HR>

<DL>
<DT>Return parameter:</DT>

<DD><EM>path</EM>: The current PostScript file path.
</DL>

</BODY>
</HTML>
